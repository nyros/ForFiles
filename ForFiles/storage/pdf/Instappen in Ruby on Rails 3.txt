I N S TA P P E N
IN

RUBY
ON
RAILS 3
Robin Brouwer

Titel:
Auteur:
Omslag:
Uitgever:

Instappen in Ruby on Rails 3
Robin Brouwer
Leo Scholtes
45north

ISBN:

978-90-818029-0-1

Eerste druk: sept. 2011
Copyright 2011, Robin Brouwer.
Dit boek is gelicenceerd onder de voorwaarden van de Creative Commons
Naamsvermelding-NietCommercieel-GeenAfgeleideWerken 3.0 overeenkomst:
http://creativecommons.org/licenses/by-nc-nd/3.0/nl/

"Rails", "Ruby on Rails", and the Rails logo are registered trademarks of David
Heinemeier Hansson. All rights reserved.
http://rubyonrails.org/
Rails is released under the MIT license.
http://www.opensource.org/licenses/mit-license.php
Ruby under the Ruby License.
http://www.ruby-lang.org/en/LICENSE.txt

Voorwoord
Van harte welkom bij mijn allereerste boek en het eerste deel in de ‘Instappen in’-serie.
Mijn naam is Robin Brouwer en ik ben een all-round webdeveloper met een Bachelor in
Communication & Multimedia Design. Ik noem mezelf all-round, omdat ik veel
verschillende programmeertalen ken en een erg brede kennis heb op het gebied van
webdevelopment. Ik vind het ontzettend leuk om deze kennis te delen en heb een tijdje
geleden besloten om dit onder andere in boekvorm te doen.

45north
Ik werk full-time bij het webdevelopment bureau 45north. Dit is een klein bedrijf in
Amsterdam dat zich richt op het maken van weboplossingen voor allerlei verschillende
klanten. Van simpele websites tot en met complexe webapplicaties: we doen het allemaal.
Dit doen we meestal in Ruby on Rails: het framework dat we gebruiken.
Ik werk hier ofﬁcieel als back-end developer, maar doe naast mijn reguliere
werkzaamheden ook een hoop andere dingen bij 45north. Zo houd ik me bezig met project
management, begeleiding, kennisdeling binnen het bedrijf en doe ik zo nu en dan wat
front-end gerelateerde zaken. Mijn specialisatie is Ruby on Rails en dat is ook meteen de
reden waarom ik dit heb gekozen als onderwerp voor mijn eerste boek.
Zoals ik al aangaf vind ik het erg leuk om mijn kennis te delen. Zo schrijf ik zo nu en dan
berichten voor de weblog van 45north. Mocht je hierin interesse hebben kun je een kijkje
nemen op 45north.nl/atoms. Ik ben ook redelijk actief op Twitter, dus als je wilt kun je me
volgen op @RobinBrouwer. Je kunt dit uiteraard ook gewoon niet doen en lekker verder
gaan met het lezen van mijn boek.

Mijn dank gaat uit naar ...
Ik wil hierbij graag iedereen bedanken die me heeft geholpen bij het realiseren van dit
boek. Allereerst wil ik 45north bedanken voor de hulp bij het uitbrengen van het boek en
het feit dat ik ook tijdens werktijd aan dit boek mocht werken. Ik wil ook graag mijn
proeﬂezers bedanken. Anne van den Hoogen, Ingmar van Stipriaan en Bart Goselink:
hartelijk bedankt!
Ik wil Anne en Ingmar extra bedanken voor hun enorme feedback lijsten. Jullie zijn zo
nauwkeurig hierin, echt top! Ook wil ik Joachim Nolten en Daniël Zwijnenburg bedanken
voor hun input bij het uitleggen van de wat complexere materie en Leo Scholtes voor het
maken van de mooie omslag.
Hiernaast wil ik uiteraard mijn ouders, broer en zusje bedanken. Gewoon omdat ze er
altijd voor me zijn geweest en me steunen in alles wat ik doe.
Nogmaals: bedankt allemaal!
2 - Instappen in Ruby on Rails 3 - Robin Brouwer

Instappen in
Dit is het eerste deel in de ‘Instappen in’-serie die ik aan het schrijven ben. Ik schrijf deze
serie in het Nederlands, zodat de drempel lager is en alles - hopelijk - een stuk duidelijker
wordt. De ‘Instappen in’ serie is namelijk vooral gericht op beginners. Dit boek is gericht
op beginners die al enige programmeerervaring hebben en zich willen verdiepen in
bepaalde programmeertalen of programmeeromgevingen.

Ruby on Rails
Ik ga je in dit boek laten kennismaken met de wondere wereld van Ruby én Rails. Er zijn
verschillende redenen waarom ik ervoor heb gekozen om in mijn eerste boek over dit
onderwerp te schrijven.
Allereerst is Ruby on Rails mijn specialisme. Ik programmeer erg graag in dit framework
en vertel er ook erg graag over. Ik geef zo nu en dan les in Ruby on Rails en heb al een
aantal workshops over dit onderwerp gegeven. Het schrijven van een boek was eigenlijk
een vrij logische stap voor mij.
Ik wil hiernaast graag de Nederlandse Ruby on Rails community vergroten. Een
Nederlands boek over het framework kan hierbij goed helpen. Hiernaast is er naar mijn
weten maar één Nederlands boek over Ruby on Rails, die alweer vrij verouderd is. Een
mooi gat in de markt wat mij betreft.
Ook hadden we bij 45north iets nodig om de interne opleiding van nieuwe medewerkers
te verbeteren. Een zelfgeschreven boek is hiervoor natuurlijk erg handig. Ik zal
begeleidende presentaties gaan maken, zodat ik mooie Ruby on Rails lessen kan geven op
zowel scholen als bij 45north.

Gratis e-book
Ik heb ervoor gekozen om dit boek als gratis e-book uit te brengen. Als je liever het boek
analoog leest is het mogelijk om het als gewoon boek te bestellen. Het boek wordt gedrukt
via een print-on-demand service en kun je bestellen via het volgende adres:
http://instappenin.nl/ruby-on-rails-3

Feedback
Ik sta altijd open voor feedback. Als je fouten tegenkomt in het boek of bepaalde gedeeltes
niet echt begrijpt, dan zou ik het erg op prijs stellen als je dit naar me stuurt. Ik zal dan in
een nieuwe versie van dit boek de aanpassingen doorvoeren. Feedback kun je naar
robin@45north.nl sturen. Alvast hartelijk bedankt en veel plezier bij het lezen van dit boek.

3 - Instappen in Ruby on Rails 3 - Robin Brouwer

Inhoudsopgave
1. Inleiding

8

2. Filosoﬁe van Rails

10

2.1 MVC (Model View Controller)

10

2.2 DRY (Don't Repeat Yourself)

12

2.3 OOP (Object Oriented Programming)

13

2.4 Fat Model, Skinny Controller

14

2.5 CoC (Convention over Conﬁguration)

14

2.6 REST (Representational State Transfer)

15

2.7 Samenvatting

16

3. Ruby leren

18

3.1 Waarom Ruby?

20

3.2 Strings

20

3.3 Numbers

21

3.4 Variables

23

3.5 Arrays

26

3.6 Hashes

28

3.7 If/else statements

30

3.8 Booleans

34

3.9 Iterators

35

3.10 Date, DateTime en Time

38

3.11 Classes en Modules

39

3.12 Procedures

46

3.13 Ruby conventies

47

3.14 Samenvatting

60

4 - Instappen in Ruby on Rails 3 - Robin Brouwer

4. Beginnen met Rails

61

4.1 Installeren

61

4.2 Nieuwe applicatie

61

4.3 Mapstructuur

63

4.4 Scripts

64

4.5 Environments

67

4.6 Console

67

4.7 Samenvatting

70

5. Model

71

5.1 Naamgeving conventies

71

5.2 Genereren van een Model

71

5.3 Migrations

72

5.4 Seeds

78

5.5 Data manipuleren

79

5.6 Rails Scopes

84

5.7 Named Scopes

90

5.8 Validatie

92

5.9 Callbacks

100

5.10 Relaties

103

5.11 attr_accessor en attr_accessible

112

5.12 Samenvatting

115

6. View

116

6.1 Controller aanmaken

116

6.2 Ruby tags

118

6.3 Layouts

120

6.4 Rails helpers

122

6.5 Custom helpers

132
5 - Instappen in Ruby on Rails 3 - Robin Brouwer

6.6 Partials

135

6.7 Haml

138

6.8 Samenvatting

139

7. Controller

141

7.1 Requests afhandelen

141

7.2 CRUD

148

7.3 Fat Model, Skinny Controller

154

7.4 Sessions

156

7.5 ApplicationController

158

7.6 Filters

160

7.7 Samenvatting

161

8. Routing

162

8.1 Root

162

8.2 Match

163

8.3 RESTful resources

166

8.4 Namespace

170

8.5 Samenvatting

173

9. Je eerste applicatie

174

9.1 Rails applicatie maken

174

9.2 Model aanmaken en migraten

175

9.3 CRUD maken

178

9.4 To-do’s afvinken

186

9.5 Has many comments

189

9.6 Gebruikersbeheer

192

9.7 Samenvatting

206

10. Unobtrusive JavaScript
10.1 Unobtrusive

207
207

6 - Instappen in Ruby on Rails 3 - Robin Brouwer

10.2 Rails en UJS

209

10.3 In onze applicatie stoppen

213

10.4 Samenvatting

219

11. Locales

220

11.1 Hiërarchie van locales

220

11.2 Locales aanroepen

224

11.3 Verwisselen van taal

226

11.4 Samenvatting

229

12. Mailer

230

12.1 Mailer aanmaken

230

12.2 Acties aanmaken

231

12.3 Mail versturen

234

12.4 Environment gegevens

235

12.5 Samenvatting

237

13. Uploaden

238

13.1 Formulier

238

13.2 Model

239

13.3 ImageMagick

243

13.4 Paperclip

244

13.5 Samenvatting

245

14. Tips

247

14.1 Plugins en gems

247

14.2 Debuggen

259

14.5 Testen

261

14.4 Handige links om verder te gaan

263

14.5 Rails 3.1

265

14.6 Ingestapt!

271
7 - Instappen in Ruby on Rails 3 - Robin Brouwer

1. Inleiding
Misschien heb je er al een keer over gehoord: Ruby on Rails. Sites als Twitter, Basecamp,
Hulu en Github zijn ermee gemaakt en tegenwoordig hoor je er steeds meer over. Maar
wat is Ruby on Rails nou precies? Hoe kan je het gebruiken? En ook niet onbelangrijk: wat
heb je eraan?
Ruby on Rails is een zogenaamd ‘Webapplication Framework’. Een Webapplication
Framework kun je gebruiken om gemakkelijk en snel complexe webapplicaties te maken.
Veel code is al voor je geschreven, waardoor je veel minder hoeft te doen. Het framework
is vaak ook zo opgebouwd dat je veel gestructureerder moet werken, waardoor er een
soort standaard ontstaat om applicaties voor het web te ontwikkelen. Ruby on Rails is zo’n
framework. Je kunt er snel en gemakkelijk webapplicaties mee maken, het biedt heel veel
voorgeschreven code aan en zorgt voor een standaard manier van werken.
Rails is de naam van het framework. Het framework maakt gebruik van de
programmeertaal ‘Ruby’. Dit is een programmeertaal die in 1995 is ontwikkeld door de
Japanner Yukihiro Matsumoto. Ruby is van origine een taal om desktop applicaties mee te
maken. Sinds de introductie van Ruby on Rails in juli 2004 - door David Heinemeier
Hansson - is dit drastisch veranderd. Ruby wordt nu meer gezien als een taal voor
webapplicaties.
In dit boek leer ik je de basis van Ruby én Rails en vertel ik hoe je je nog meer kunt
verdiepen in de materie. Je gaat je in dit boek bezighouden met Ruby on Rails versie 3.0.
Deze versie van Rails is op 29 augustus 2010 uitgekomen en biedt een heleboel nieuwe
mogelijkheden en veranderingen ten opzichte van voorgaande versies. Als je een paar keer
Rails 2.3 hebt gebruikt en meer wilt weten over Rails 3 is dit een goed boek voor je. Heb je
nog nooit met Rails gewerkt? Dan is dit een perfect boek voor je. Het heet niet voor niets
‘Instappen in Ruby on Rails 3’.
Als je al veel met Ruby on Rails hebt gewerkt kan dit boek een heleboel herhaling voor je
zijn. In dat geval kun je het beste tutorials op het internet afgaan of een geavanceerder
boek lezen. Maar ook voor de gevorderde Ruby on Rails programmeur kan dit boek
interessant zijn. Misschien kom je zelfs wat handige dingen tegen die je nog niet wist.
Onthoud echter dat dit een boek is voor programmeurs die niet tot nauwelijks ervaring
hebben met Ruby en Rails.

8 - Instappen in Ruby on Rails 3 - Robin Brouwer

Op het moment dat dit boek uitkomt is Rails 3.1 al gelanceerd. Ik had gehoopt dat
ik het boek ver voor de lancering van Rails 3.1 klaar zou hebben. Dit is echter door
drukte met school en werk niet gelukt. Daarom heb ik aan het einde van dit boek
nog een gedeelte over Rails 3.1 geschreven. Hierin behandel ik de belangrijkste
veranderingen. Ook zal ik gedurende het boek van dit soort blokjes plaatsen met
extra informatie over Rails 3.1. Als je Rails 3.1 wilt gebruiken tijdens het lezen van
dit boek kan dat dus gewoon. Je moet dan wel deze blokjes in de gaten houden.

Ik ga er in dit boek vanuit dat je enige kennis hebt op het gebied van programmeren. En
dan bedoel ik niet dat je al een enorm goede programmeur moet zijn voordat je dit boek
kunt lezen. Ik verwacht wel dat je weet wat een Array is, een String, hoe ‘iterators’ werken
en meer van dat soort basis-kennis. Ik leg deze dingen wel uit, maar zal er niet te diep op
ingaan.
Naast programmeren verwacht ik dat je enige kennis hebt van werken in de command
line, ook wel ‘terminal’ genoemd. Ik verwacht dat je in de terminal kunt navigeren en
simpele commando’s kunt uitvoeren. Als je dit kunt zal het gebruikmaken van de terminal
je gemakkelijk afgaan. Heb je er nooit mee gewerkt? Dan kan het iets lastiger worden. Je
moet namelijk meerdere keren de terminal gebruiken om bepaalde bestanden te genereren
en scripts uit te voeren. Volg daarom een aantal tutorials om meer over de terminal te
weten te komen. Google is hierbij je vriend.
Laten we nu maar snel beginnen met het leren van Ruby on Rails. Ik wens je veel plezier
bij het lezen van dit boek!

9 - Instappen in Ruby on Rails 3 - Robin Brouwer

2. Filosoﬁe van Rails
Het eerste waar ik graag aandacht aan wil besteden is de ﬁlosoﬁe achter Ruby on Rails. Ja,
er schuilt een heuse ﬁlosoﬁe achter Ruby on Rails. Er zijn een aantal belangrijke zaken die
je moet begrijpen en altijd in je achterhoofd moet houden tijdens het programmeren. Deze
zogenaamde conventies zal ik je nu stuk voor stuk uitleggen.

2.1 MVC (Model View Controller)
Allereerst ga ik het hebben over de zogenaamde MVC structuur die gebruikt wordt
binnen Rails. MVC staat voor ‘Model View Controller’ en is een manier waarop een
applicatie kan worden ingedeeld. Je hebt een Model die communiceert met de database,
een View die iets aan de gebruiker laat zien en een Controller die alle requests van de
gebruiker afhandelt. Deze drie onderdelen kunnen met elkaar communiceren, waardoor
de applicatie die je maakt iets anders in elkaar steekt. Op een rijtje:
1) Model: communiceert met de database;
2) View: maakt de pagina voor de browser;
3) Controller: handelt requests af die de gebruiker verstuurt.
Allereerst is het handig om te kijken hoe een typische HTML website werkt. Een website
die alleen uit HTML bestaat maakt totaal geen gebruik van Controllers of Models. Het is
alleen een View die steeds aan de gebruiker wordt getoond. Als diagram ziet dat er zo uit:

Een wat complexere website die bijvoorbeeld van PHP gebruikmaakt heeft wel een Model,
View en Controller, maar deze zijn vaak allemaal samengepropt in één bestand. Dit geldt
natuurlijk niet voor elke PHP website. Er zijn zat PHP frameworks die het werken in PHP
wat draaglijker kan maken. Maar aangezien PHP een taal is die heel gemakkelijk is om te
leren - waardoor veel onervaren programmeurs het gebruiken - zullen bepaalde websites
toch op zo’n ongestructureerde manier in elkaar zitten. Als diagram kan dit er dan als
volgt uitzien:

10 - Instappen in Ruby on Rails 3 - Robin Brouwer

Een website die volgens de MVC structuur werkt zit een stuk anders in elkaar. De drie
onderdelen zijn van elkaar gescheiden en communiceren met elkaar. Als je gaat zoeken
naar goede diagrammen hiervoor zul je vele verschillende soorten tegenkomen. Hoe de
MVC structuur ongeveer werkt in Ruby on Rails zie je in het volgende diagram:

Je ziet duidelijk een verschil in een website zonder en met MVC structuur. Bij de MVC
structuur van Ruby on Rails doet de browser als eerste een request naar de Controller. Dit
is meestal een HTTP request die gebruikmaakt van een bepaalde HTTP method (GET,
POST, PUT of DELETE). De Controller kan dan via de Model allerlei data uit de database
halen, erin stoppen, aanpassen of verwijderen. Het resultaat hiervan wordt teruggestuurd
naar de Controller. De Controller kan hierna de View aanspreken, zodat er een pagina kan
worden gegenereerd voor de browser. De View kan nog met de Model communiceren om
wat extra opdrachten uit te voeren of checks te doen op bepaalde zaken. Als de View
helemaal klaar is wordt deze gestuurd naar de browser. De browser zorgt er dan voor dat
er iets moois op het scherm komt.
Een View is meestal opgebouwd uit HTML of XHTML en kan met behulp van wat CSS
en/of JavaScript worden omgezet naar iets waar de gebruiker iets mee kan doen. Er
kunnen echter ook Views worden gegenereerd met RSS, XML of JSON. Hoe je dit allemaal
kunt doen zal ik natuurlijk in dit boek uitleggen.
Hier nog een keer op een rijtje:
11 - Instappen in Ruby on Rails 3 - Robin Brouwer

1)
2)
3)
4)
5)
6)
7)
8)

De Browser stuurt een request naar de Controller;
De Controller roept een Model aan;
De Model doet eventueel iets met de database;
De Model stuurt het resultaat naar de Controller;
De Controller stuurt alles door naar de View;
De View wordt gegeneerd en de Model wordt eventueel weer aangesproken;
De View wordt naar de Browser gestuurd;
De gebruiker krijgt de pagina te zien.

De MVC structuur klinkt misschien wat complex, maar als je er eenmaal aan gewend bent
wil je eigenlijk niet meer anders. Probeer goed in je hoofd te stampen wat MVC is en hoe
het precies in elkaar zit.

2.2 DRY (Don't Repeat Yourself)
Het volgende onderdeel van de ﬁlosoﬁe achter Ruby on Rails is DRY. Dit staat voor “Don’t
Repeat Yourself” en houdt in dat je je zo min mogelijk moet herhalen. Als je merkt dat je
code twee keer opschrijft ben je niet DRY bezig en moet je goed nadenken hoe je het beter
kunt oplossen. Het is de bedoeling dat je alle code maar één keer schrijft en steeds verwijst
naar deze code als je het meerdere keren moet uitvoeren. Als er dan een keer iets moet
veranderen hoef je dit maar op één plaats te doen. Je hoeft dan niet alle bestanden door te
kijken en alles opnieuw aan te passen. Dit scheelt veel tijd en maakt je project een heel stuk
overzichtelijker.
Een klein voorbeeld om het te illustreren. Stel je hebt een plaatje die je meerdere keren
gebruikt op je website. Bijvoorbeeld een plaatje die wordt gebruikt voor alle ‘edit’
knoppen in de admin. Deze wil je op verschillende plaatsen neerzetten. Je hebt dit gedaan,
maar opeens krijg je van de klant te horen dat ze het plaatje niet mooi vinden en dat er iets
anders moet komen. Dan moet jij alle bestanden langs om de edit-knop aan te passen.
Misschien vergeet je zelfs dat de knop op een paar extra plaatsen is gezet die nu dus
onveranderd blijven. Niet erg handig natuurlijk. Als je vanaf het begin rekening had
gehouden met het DRY-principe had je maar één keer de knop hoeven aan te passen.
Scheelt veel tijd en voorkomt kleine foutjes. Ruby on Rails biedt een aantal erg handige
functies om je webapplicatie zo DRY mogelijk te houden. Hier later meer over.
Als je merkt dat je code gaat herhalen weet je dat je niet DRY bezig bent en even achter de
oren moet krabben. Elke keer als je copy-paste binnen het project moet je even stilstaan of
er niet een betere manier is. Het is belangrijk dat er een belletje gaat rinkelen als dit
gebeurt. In het begin is dit nog lastig, maar als je dit steeds meer doet zul je dit soort
foutjes steeds vaker opmerken. Het maakt je een betere programmeur en zorgt ervoor dat
het een stuk gemakkelijker wordt om een applicatie te maken en aan te passen. Stamp
deze conventie daarom goed in je hoofd: je zult het nodig hebben.

12 - Instappen in Ruby on Rails 3 - Robin Brouwer

2.3 OOP (Object Oriented Programming)
Dit is een term die je heel vaak voorbij ziet komen in de programmeerwereld. Het
zogenaamde ‘Object Oriented Programming’ is namelijk een veelgebruikte manier van
programmeren. Helaas gebruikt niet iedereen deze methode. Er zijn genoeg
programmeurs die deze methode niet gebruiken uit luiheid, onwetendheid of misschien
zelfs onmacht. Het is namelijk niet erg gemakkelijk om echt goed object georiënteerd te
werken. Het vergt behoorlijk wat discipline.
Het object georiënteerd programmeren houdt in dat je jouw applicatie opbouwt uit allerlei
objecten. Deze objecten hebben hun eigen functies en eigenschappen. Het registreren van
een klik op een knop doe je bijvoorbeeld niet op de pagina waar de knop staat, maar op de
knop. De knop is een object en het object registreert of erop wordt geklikt. Als je dan vaker
deze knop wilt gebruiken hoef je alleen die knop ergens anders neer te zetten. Het
registreren van kliks erop gebeurt niet op de pagina, waardoor je niet nog een keer
dezelfde code hoeft te schrijven. Dit is iets wat veel beginnende ActionScript 3.0
programmeurs fout doen, waardoor er heel veel dubbele code ontstaat.
Een ander voorbeeld is het maken van een auto voor een game. De auto is een object. Dit
object heeft verschillende eigenschappen, waaronder de snelheid van de auto. Binnen deze
auto heb je onder andere de wielen. Elk wiel is een apart object en heeft unieke
eigenschappen, waaronder de bandenspanning en de schade op de band. Er kunnen weer
functies binnen het wiel zitten om het te laten draaien als de auto gaat rijden. De status
van de banden kan weer invloed hebben op de auto, waardoor de snelheid van de auto
verandert. De auto is een object die opgedeeld is in meerdere kleine objecten die allemaal
communiceren met elkaar. Op deze manier kun je gemakkelijk de schade op verschillende
onderdelen binnen de auto in de gaten houden, waardoor je een stuk gemakkelijker een
complexere racegame kan maken. Bedenk je eens als dit allemaal in één Class gezet moet
worden. Dat zijn dan enorm veel - onoverzichtelijke - regels code.
In Ruby on Rails is het object georiënteerd programmeren vooral aanwezig binnen de
MVC structuur. Een Model is een object waarmee je data uit een tabel kunt halen. Dit
object heeft verschillende unieke functies en eigenschappen die kunt aanspreken. Ook
Controllers zijn objecten. Als je bijvoorbeeld een aantal pagina’s hebt waarin je artikelen
kunt bekijken, aanpassen en verwijderen zul je een Controller nodig hebben voor deze
artikelen. De Views die bij deze Controller horen zijn ook weer aparte objecten. Het is
misschien een stuk abstracter dan het voorbeeld met de auto, maar het bestaat nog steeds
uit meerdere objecten. Je hele applicatie zal opgebouwd zijn uit verschillende onderdelen,
waardoor je niet één groot onoverzichtelijk bestand krijgt.
Je moet OOP echter niet verwarren met DRY. Het DRY principe gaat erom dat je je niet
herhaalt. Door object georiënteerd te werken zorg je ervoor dat je ‘DRY-er’ bezig bent. Je
kunt echter nog steeds object georiënteerd werken zonder je aan het DRY principe te
houden. Als bepaalde functies binnen de objecten meerdere keren voorkomen en identiek
13 - Instappen in Ruby on Rails 3 - Robin Brouwer

zijn, ben je misschien wel object georiënteerd bezig, maar lap je het DRY werken aan je
laars. Een dilemma waar je zelf de beste oplossing voor moet vinden.

2.4 Fat Model, Skinny Controller
Om voort te borduren op DRY en OOP is er nog een andere conventie waar je bij moet
stilstaan: Fat Model, Skinny Controller. Dit houdt in dat er zo min mogelijk code moet
staan in je Controller en dat je Model alle belangrijke code moet bevatten. De Model is
namelijk een object die je op meerdere locaties kunt aanspreken. Hoe meer functies je in de
Model bouwt, des te meer mogelijkheden je hebt om functies uit te voeren op andere
locaties. Veel code waarvan je in eerste instantie zou denken dat het in de Controller moet
kun je verplaatsen naar de Model, waardoor je applicatie dynamischer kan worden. Deze
manier van werken zorgt ervoor dat je zowel DRY als object georiënteerd bezig bent.
Dit principe is nogal lastig uit te leggen als je nog niet precies weet hoe een Rails applicatie
eruit ziet. Daarom zal ik hier later in dit boek dieper op ingaan met een aantal
voorbeelden.

2.5 CoC (Convention over Conﬁguration)
In Ruby on Rails is het de bedoeling dat je je aan bepaalde conventies gaat houden. Tijdens
het programmeren van een Rails applicatie moet je hier dus ook rekening mee houden. Zo
is er een bepaalde mapstructuur die je moet gebruiken en is de naamgeving van bepaalde
elementen in de applicatie ontzettend belangrijk.
De mapstructuur zorgt ervoor dat iedereen op dezelfde manier werkt en op dezelfde
plaatsen bestanden opslaat. Zo is er een speciale map voor javascripts, stylesheets en
beelden. De Models, Views en Controllers hebben ook ieder een speciale map en als je
scripts wilt opslaan is hier ook een plaats voor gereserveerd. De naamgeving van de
elementen in de applicatie is ook erg belangrijk. Zo moet een Model altijd in het
enkelvoud geschreven zijn. Als je je hieraan houdt zal veel overbodig werk voor je worden
gedaan. Als je namelijk een Model in het enkelvoud schrijft zal Rails automatisch zoeken
naar een tabelnaam in de database die het meervoud hiervan is. Je hoeft niet op te geven
met welke tabel de Model moet communiceren. Je kunt wel aangeven dat de Model een
bepaalde tabel moet gebruiken, maar dit is niet aan te raden.
Dat is dan ook gelijk de essentie van ‘Convention over Conﬁguration’. Je kunt van alles
conﬁgureren in de Rails applicatie, maar als je je aan de conventies houdt hoef je veel
minder te doen. Je kunt een Model in het meervoud schrijven en daarin aangeven aan
welke tabel de Model is gekoppeld, maar als je gewoon het enkelvoud aanhoudt zal het
allemaal voor je worden geregeld. Je kunt ook javascripts en stylesheets ergens anders
opslaan, maar dan zul je wat extra’s moeten doen om je Views hieraan te koppelen. Je kunt
ook direct vanuit de Controller communiceren met de database, maar dan zal je applicatie
een heel stuk minder ﬂexibel zijn. Conﬁgureren kan, maar het is beter als je je houdt aan
de conventies.

14 - Instappen in Ruby on Rails 3 - Robin Brouwer

2.6 REST (Representational State Transfer)
Misschien heb je al een keer iets gehoord over de term ‘REST’ of ‘RESTful’. Het staat voor
‘Representational State Transfer’ en houdt in dat de url’s in je applicatie niet aangeven wat
er met data moet gebeuren. Dit gebeurt door middel van zogenaamde HTTP methods:
GET, POST, PUT en DELETE. Als je volgens het REST principe werkt ben je ‘RESTful’
bezig en bestaat je applicatie uit ‘RESTful routing’. Deze term zul je nog vaak tegenkomen.
Een website die niet met RESTful routing werkt zou bijvoorbeeld van dit soort url’s
kunnen bevatten om een product te tonen en te verwijderen:

http://www.webshop.com/products/show/1
http://www.webshop.com/products/delete/2

Je ziet dat in de url staat aangegeven wat er moet gebeuren met de data. Het gaat om
producten van een webshop. De cijfers geven het ID aan in de database. Je ziet ‘show’ en
‘delete’ staan om aan te geven wat er met deze rijen in de ‘products’ tabel moet gebeuren.
Dit zijn de zogenaamde ‘Controller acties’. Bij ‘show’ moet de rij worden getoond en bij
‘delete’ moet deze worden verwijderd. Het is natuurlijk niet handig als de gebruiker
gemakkelijk via de url kan aangeven of iets moet worden verwijderd. Dat is ook gelijk een
van de problemen die REST oplost.
Als je deze twee url’s RESTful wilt maken moet je er voor zorgen dat ‘show’ en ‘delete’
eruit worden gehaald en dat dit wordt aangegeven met een HTTP method.

http://www.webshop.com/products/2	
http://www.webshop.com/products/2	

# HTTP method: GET
# HTTP method: DELETE

De url’s zien er een stuk netter uit en er wordt goed gebruikgemaakt van de diverse
HTTP methods. Er zijn in totaal vier HTTP methods die in Ruby on Rails worden gebruikt
voor de RESTful routing.

GET 	
POST 	
PUT	
	
DELETE 	

Gebruik
Gebruik
Gebruik
Gebruik

je
je
je
je

om
om
om
om

aan
aan
aan
aan

te
te
te
te

geven
geven
geven
geven

dat
dat
dat
dat

je
je
je
je

iets
iets
iets
iets

wilt
wilt
wilt
wilt

laten zien
toevoegen
aanpassen
verwijderen

Als je weet wat een actie doet kun je aangeven naar welke HTTP method deze actie moet
luisteren. Als je dan een andere HTTP method gebruikt zal de actie het niet begrijpen en
een error teruggeven. Dit zorgt ervoor dat je beter moet nadenken wat je acties precies
doen, waardoor je een stuk gestructureerder te werk gaat binnen je applicatie.

15 - Instappen in Ruby on Rails 3 - Robin Brouwer

In oudere versies van Ruby on Rails was het nog erg gemakkelijk om het RESTful werken
aan je laars te lappen. Je kon in de URL’s stoppen wat er met de data moest gebeuren en
het RESTful werken stond standaard uit. In Rails 3 is dit wat lastiger geworden. Je moet
wat dingen aanpassen om op de oude manier te blijven werken. De RESTful routing staat
standaard aan en is de standaard manier van werken binnen Rails 3. Ik raad je daarom ook
aan om dit te doen. Het brengt veel voordelen met zich mee en zorgt ervoor dat een
heleboel werk niet hoeft te worden gedaan. Een simpel voorbeeld is hoe formulieren
werken in Ruby on Rails als je RESTful werkt. Als je bijvoorbeeld een product wilt
toevoegen via een formulier hoef je alleen maar aan Rails mee te geven om welk object het
gaat. Rails maakt automatisch het juiste formulier aan met de juiste url en de HTTP
method. Als je niet RESTful werkt zul je dit allemaal zelf moeten doen (denk weer aan
Convention over Conﬁguration).
Er zijn echter een aantal kanttekeningen te noemen bij het RESTful werken.
1) RESTful is een manier van werken, maar niet per se de beste manier. Er zijn ook andere
manieren om de routing van je website aan te pakken. De Ruby on Rails community
heeft echter wel het RESTful werken omarmt. Het lijkt me daarom wel verstandig als je
hieraan meedoet als je Rails wilt leren.
2) Je hoeft het niet per se te gebruiken. Je kunt het ook gewoon niet doen. Het zorgt er niet
voor dat je applicatie het opeens niet meer doet. Zo kun je voor veel acties GET
gebruiken zonder na te denken wat er gebeurt met de actie. Als je de oude manier van
routing wilt gebruiken kan dat ook.
3) Het RESTful werken moet niet een restrictie voor je worden. Als je iets wilt doen, maar
het lukt je niet om dit voor elkaar te krijgen doordat je RESTful werkt (zal niet vaak
gebeuren), dan moet je je er niet aan vasthouden.
4) Je moet het niet te strict nemen. REST is niet iets heiligs, dus wees niet bang als je het
een keertje vergeet te gebruiken of het op een verkeerde manier toepast.
5) PUT, DELETE en POST kun je niet zomaar gebruiken in een <a href>. Je moet JavaScript
gebruiken om dit voor elkaar te krijgen. Rails biedt wel de mogelijkheid om dit soort <a
href>‘s te maken, maar het gebruikt nog steeds JavaScript. Als je gebruikers geen
JavaScript gebruiken kan dit een probleem zijn. Alle HTTP methods werken wel in
formulieren.
Houdt deze kanttekeningen in je achterhoofd, maar ga wel RESTful werken als je met
Ruby on Rails bezig bent. Hoe je precies RESTful kunt werken met Ruby on Rails zal ik
later behandelen.

2.7 Samenvatting
Dit waren de belangrijkste conventies binnen Ruby on Rails. Zoals je ziet is de ﬁlosoﬁe
achter Ruby on Rails een stuk complexer dan een simpele PHP website die je in elkaar zet.
Er is door meerdere mensen goed over nagedacht en er zullen vast hevige discussies zijn
geweest over een aantal punten. Probeer daarom deze conventies te onthouden en na te
leven. Het zal je Ruby on Rails leven een stuk aangenamer maken.
16 - Instappen in Ruby on Rails 3 - Robin Brouwer

Hier nog een keer de conventies op een rijtje:
- Model View Controller;
- Don't Repeat Yourself;
- Object Oriented Programming;
- Fat Model, Skinny Controller;
- Convention over Conﬁguration;
- Representational State Transfer.

17 - Instappen in Ruby on Rails 3 - Robin Brouwer

3. Ruby leren
Voordat we beginnen met Ruby on Rails ga ik je de basis leren van de programmeertaal
Ruby. Ik zal niet te diep ingaan op de materie. Dit boek gaat vooral over Rails. Als je meer
over Ruby wilt lezen raad ik je aan om in de Ruby documentatie te duiken. Deze kun je
vinden op de volgende website: http://ruby-doc.org. Als je heel snel met Ruby wilt spelen
zonder het te installeren raad ik je aan om een kijkje te nemen naar Try Ruby: http://
tryruby.org.
Als je een compleet boek wilt hebben over Ruby kun je het ‘Pickaxe’
boek kopen. Dit is een dik boek met alles wat je nodig hebt om goed te
worden in Ruby.
Programming Ruby 1.9 (3rd edition)
http://pragprog.com/titles/ruby3/programming-ruby-1-9
(TinyURL: http://tinyurl.com/7xfvk7)

Ik ga in dit boek werken met Ruby 1.9. Op het moment van schrijven is versie 1.9.2 de
nieuwste versie. Er zijn wat verschillen ten opzichte van versie 1.8.7, dus als je Ruby 1.8 al
onder de knie hebt zul je misschien wat nieuwe dingen tegenkomen. Je kunt nog steeds
gebruikmaken van Ruby 1.8 voor dit boek, maar dan moet je vooral opletten bij de Hashes
die worden gebruikt. Dit zit namelijk iets anders in elkaar in Ruby 1.9. Als je Ruby al kent
en je wilt weten wat er nieuw is in versie 1.9, dan kun je het beste de onderstaande link
bekijken.
What’s new in Ruby 1.9
http://svn.ruby-lang.org/repos/ruby/tags/v1_9_1_0/NEWS
(TinyURL: http://tinyurl.com/b3fj2z)
Je zult na dit hoofdstuk niet gelijk een ‘Ruby pro’ zijn, maar zult wel de beginselen van
Ruby begrijpen. Om echt goed te worden in Ruby moet je oefenen, oefenen en nog eens
oefenen. Allerlei ‘tips & tricks’ zoeken op internet is ook een goede manier om jezelf te
verbeteren.
Om de voorbeelden in dit hoofdstuk uit te proberen moet je eerst Ruby installeren op je
computer. Een Mac heeft standaard Ruby geïnstalleerd, maar een Windows computer niet.
Zorg er dus voor dat Ruby is geïnstalleerd als je Windows draait. Het is trouwens handig
om gelijk RVM (Ruby Version Manager) te installeren als je een Mac hebt. Hiermee kun je
erg gemakkelijk nieuwe versies van Ruby installeren en beheren.
Ruby Version Manager
http://rvm.beginrescueend.com
18 - Instappen in Ruby on Rails 3 - Robin Brouwer

(TinyURL: http://tinyurl.com/n87ecb)
Als je eenmaal Ruby hebt geïnstalleerd is het tijd om Ruby te schrijven. Er zijn
verschillende manieren om je Ruby code te schrijven en te testen. De eerste manier is door
het te stoppen in een Ruby bestand. Dit is een bestand met de extensie ‘.rb’. In deze
bestanden kun je alleen Ruby schrijven.
In het Ruby bestand kun je onder andere een script schrijven. Denk aan een script
waarmee je door allerlei bestanden heenloopt en steeds iets doet met deze bestanden. Als
je dit script dan ‘uitvoert’ wordt het script gedraaid en wordt er iets speciaals gedaan met
de bestanden.
Bij de voorbeelden in dit hoofdstuk zullen we werken in een bestand genaamd
‘ruby_leren.rb’. Maak dit bestand aan en stop het volgende erin:
	
puts "Hello world"

Om het script uit te voeren kun je het volgende commando geven in Terminal (Mac) of
cmd.exe (Windows):
	
ruby ruby_leren.rb

Door eerst ‘ruby’ te schrijven geef je aan dat je een Ruby script wilt uitvoeren. Hierna geef
je de bestandsnaam op. Let wel op dat je het correcte pad naar dit bestand opgeeft. Om
zeker te weten dat dit goed gaat kun je het bestand naar de terminal slepen. Het complete
pad wordt hier dan automatisch neergezet.
Als je het bestand uitvoert zie je ‘Hello world’ in de terminal staan. Als je dat ‘puts’
weghaalt zal je niks te zien krijgen. De ‘puts’ functie zorgt er dus voor dat het resultaat
wordt getoond in de terminal. Als je een lang script hebt geschreven is het handig om zo
nu en dan ‘puts’ te gebruiken om aan te geven waar je precies bent in het script.
Naast het uitvoeren van Ruby bestanden is er ook een andere manier om je Ruby code uit
te testen. Deze methode werkt echter alleen op de Mac. Voer het volgende commando uit
in de terminal:
	
irb

19 - Instappen in Ruby on Rails 3 - Robin Brouwer

Er zal nu een speciale command line komen waarin je Ruby kunt schrijven. Alles wat je in
een Ruby bestand kan stoppen kun je ook hier uitvoeren. Als je even snel wat Ruby code
wilt uitproberen kun je dit het beste hier doen.

3.1 Waarom Ruby?
Voordat we ons verder verdiepen in Ruby is het misschien handig om te weten waarom
Ruby gekozen is als de programmeertaal van Rails. Hoe kun je dit beter begrijpen dan het
verhaal te horen van de maker van Rails? David Heinemeier Hansson heeft op RubyConf
2010 een keynote gegeven over precies dit onderwerp: Why Ruby? Hierin vertelt hij dat
onder andere de syntax, de simpliciteit, de vrijheid en esthetiek ervoor hebben gezorgd
dat Ruby is gekozen voor het framework. Als je het verhaal van David wilt horen over
waarom hij voor Ruby heeft gekozen en sindsdien erbij is gebleven, dan kun je naar de
volgende url gaan:
Keynote David Heinemeier Hansson - Why Ruby?
http://tekpub.com/conferences/rubyconf2010/dhh
(TinyURL: http://tinyurl.com/385rqgu)
Ruby is een vrij simpele taal die een stuk logischer in elkaar lijkt te zitten dan andere
programmeertalen. Je hoeft vaak minder te doen om meer voor elkaar te krijgen. Ruby is
ook compleet open-source, waardoor je heel veel vrijheid kent als je Ruby gebruikt.
Hiernaast zien veel Ruby-programmeurs de taal als iets ‘moois’ wat bijna geen enkele
andere programmeertaal biedt. Ruby programmeren is leuk. Dit is natuurlijk puur
subjectief. Als je heel graag overal accolades neerzet, puntkomma’s toevoegt aan het einde
van elke regel én graag aangeeft per variabele of het een string is of een integer, dan kan
dat natuurlijk ook. Bij mij is Ruby echter een verademing geweest. Ik wil, net als David,
niet meer terug.

3.2 Strings
Het eerste waarmee we beginnen zijn Strings. Dit zijn zoals je gewend bent gewoon regels
tekst. Stop het volgende in het ‘ruby_leren.rb’ bestand.
	
puts "Ik ben een String"

Als je nu het bestand uitvoert krijg je de tekst ‘Ik ben een String’ te zien. Hier nog een keer
hoe je het bestand kunt uitvoeren:
	
ruby ruby_leren.rb

Een String zet je, zoals je ziet, tussen aanhalingstekens. Dit kunnen dubbele of enkele
quotes zijn. Het verschil is dat je met dubbele quotes gemakkelijker Ruby kunt uitvoeren
20 - Instappen in Ruby on Rails 3 - Robin Brouwer

in de String. Hiernaast is het iets sneller om met dubbele quotes te werken. Dit verschil is
echter verwaarloosbaar.
Je kunt ook twee Strings samenvoegen door het plusteken te gebruiken.

puts "Ik ben een String" + " (en ik ook!)"

Nu zijn de twee Strings samengevoegd. Let wel op dat de twee objecten die je samenvoegt
allebei Strings zijn, anders krijg je een foutmelding.
Je kunt nog veel meer met een String. Hieronder zie je een aantal voorbeelden. Het #-teken
wordt in Ruby gebruikt om commentaar toe te voegen. Ik gebruik in dit hoofdstuk ‘# =>’
om aan te geven wat het resultaat is van het stukje code.

puts
puts
puts
puts
puts
puts
puts

"HaLLo".downcase	
"hAllo".upcase 		
"RuBy".swapcase		
"
WIT
".strip	
"123456".length		
"123.45e1".to_f		
"99 blokken".to_i	

#
#
#
#
#
#
#

=>
=>
=>
=>
=>
=>
=>

"hallo"
"HALLO"
"rUbY"
"WIT"
6
1234.5
99

Dit zijn allemaal speciale ‘methods’ (ook wel functies genoemd) die je kunt aanroepen op
de String Class. Er zijn nog veel meer methods die je op een String kunt aanroepen. Zo zijn
er genoeg extra mogelijkheden om reguliere expressies uit te voeren op een String. Meer
hierover kun je vinden in de Ruby documentatie.

3.3 Numbers
Numbers zijn, zoals het woord al zegt, gewoon cijfers. In tegenstelling tot bepaalde andere
programmeertalen kun je hele cijfers (integers) en cijfers met decimalen (ﬂoats) met elkaar
samenvoegen.

puts 2 + 2.5	

# => 4.5

Hier wordt net als bij het String voorbeeld een plusteken gebruikt. Het grote verschil is
echter dat er geen aanhalingstekens zijn en alleen maar cijfers. Het is simpelweg een
rekensom die Ruby uitvoert. Bij decimalen werk je daarnaast met een punt in plaats van
een komma, zoals je bij zowat alle programmeertalen doet.

21 - Instappen in Ruby on Rails 3 - Robin Brouwer

Naast optellen kun je ook aftrekken (-), delen (/) en vermenigvuldigen (*). Hier drie
simpele sommen.

puts 5 - 3.5 	 	
puts 8 * 2	
	
puts 16 / 2	
	

# => 1.5
# => 16
# => 8

Rekenen in Ruby is erg makkelijk. Maar wat als je cijfers in een string hebt staan en
hiermee wilt rekenen?

puts "5" + 2.5		

# => can't convert Float into String

Dit werkt niet in Ruby en je krijgt de bovenstaande error. Hij snapt niet dat in de String
eigenlijk een cijfer zit waar je het bij wilt optellen. Wat je doet is het volgende:

puts "5".to_i + 2.5	 # => 7.5

Zoals je ziet heb ik na de String ‘to_i’ gezet. Dit staat voor ‘to integer’ en transformeert de
string in een heel cijfer. Maar wat als je het cijfer 2.5 hebt? Aangezien integers altijd hele
getallen zijn zou Ruby het automatisch transformeren naar een 2 en daarna optellen. Om
ervoor te zorgen dat de cijfers achter de punt worden meegerekend doe je het volgende:

puts "2.5".to_f + 2.1	
puts "3.2".to_d + 3.3	

# => 4.6
# => 6.5

Zoals je al waarschijnlijk kunt raden staat ‘to_f’ voor ‘to ﬂoat’ en ‘to_d’ voor ‘to decimal’.
Het zorgt ervoor dat de String wordt getransformeerd naar een decimaal getal.
Naast het omzetten van een String kun je ook cijfers omzetten naar een String.
	
puts "5+5=" + (5+5).to_s	

# => "5+5=10"

Zoals je ziet wordt hier 5+5 tussen haakjes uitgevoerd en wordt het resultaat van deze som
in een String geplaatst met to_s (to string). Je kunt dus bepaalde rekensommen eerst
uitvoeren voordat je er iets anders mee doet. Je kunt hiernaast ook Ruby code uitvoeren in
een String en deze gelijk in de String stoppen. Dit kan ook met een som zoals hierboven.

22 - Instappen in Ruby on Rails 3 - Robin Brouwer

	
puts "5+5=#{5+5}"	

# => "5+5=10"

Je gebruikt de hash (#) en de twee accolades om Ruby code in een String uit te voeren. Het
resultaat zal in de String worden gestopt. Je hoeft geen ‘to_s’ erop aan te roepen. Let op:
dit werkt alleen bij Strings met dubbele quotes.
Je kunt ook cijfers afronden. Het afronden kan op allerlei manieren. Zo kan je ervoor
kiezen dat er op een normale manier wordt afgerond, dat er altijd naar boven wordt
afgerond en dat er altijd naar onder wordt afgerond.

puts 2.5.round		
puts 2.4.ceil	 	
puts 2.6.floor		

# => 3
# => 3
# => 2

Naast integers en ﬂoats zijn er nog andere soorten numbers. Zo heb je ﬁxnum en bignum.
Ook zijn er genoeg andere functies die je op nummers kunt uitvoeren.

3.4 Variables
Erg leuk hoor dat rekenen en zinnetjes laten zien, maar wat als je bepaalde gegevens wilt
bewaren? Daar zijn natuurlijk de variabelen voor. Variabelen zijn kleine containers waarin
je informatie kunt stoppen. Zo kun je er een String instoppen, maar ook cijfers en andere
data. In Ruby heb je verschillende soorten variabelen. Ik zal ze allemaal behandelen.

3.4.1 Local variables
Lokale variabelen kunnen alleen worden aangeroepen binnen de functie waar ze zijn
aangemaakt. Je kunt geen lokale variabele maken in een Controller en deze aanspreken in
een View. Een lokale variabele ziet er zo uit:
title = "Hello World!"

Het is simpelweg een stukje tekst. Als je eenmaal de variabele hebt aangemaakt kan je
deze aanspreken door alleen de variabele naam op te geven.
puts title	

# => Hello World!

Een belangrijk deel binnen Ruby zijn de functies die je kunt aanroepen op een variabele.
Zit er bijvoorbeeld een String in, dan kun je alle functies erop gebruiken die je ook op een

23 - Instappen in Ruby on Rails 3 - Robin Brouwer

String kunt gebruiken. Je zou de tekst die we hierboven hebben geschreven kunnen
omzetten naar hoofdletters met upcase:

puts title.upcase 	

# => HELLO WORLD!

Het probleem is echter dat als je de variabele hierna aanroept hij dit is vergeten:

puts title	

# => Hello World!

In veel programmeertalen moet je het volgende doen om de variabele te veranderen:

title = title.upcase

In Ruby is er echter een hele simpele manier:

title.upcase!	 	
puts title	
	

# => HELLO WORLD!
# => HELLO WORLD!

Met een uitroepteken na upcase zorg je ervoor dat de variabele ook gelijk wordt
aangepast. Let wel op: dit kun je niet bij elke functie gebruiken! Later in dit hoofdstuk leg
ik uit wat dit uitroepteken precies doet.

3.4.2 Instance variables
Deze variabelen zijn iets anders dan de lokale variabelen. Je kunt ze namelijk op meerdere
plaatsen aanspreken en niet alleen in de functie waar de variabele wordt aangemaakt. Zo
kun je een instance variabele zowel binnen de Controller als de View gebruiken. Je stopt
het volgende in een actie van een Controller:
@instant = "Dit is een instance variabele."

Deze variabele heeft zoals je ziet een apenstaartje voor zijn naam. Dat is ook meteen het
kenmerk van een instance variabele.
puts @instant	 # => Dit is een instance variabele.

24 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je spreekt de variabele aan om hem te laten zien. Het belangrijkste aan een instance
variabele is dat je deze kunt gebruiken tussen verschillende functies. Als je een variabele
wilt doorsturen van een Controller naar de View moet je een instance variabele gebruiken.
Een lokale variabele werkt hiervoor niet. Dit zul je later in dit boek zien terugkomen.

3.4.3 Class variables
Maar wat als je een variabele binnen de hele Class wilt gebruiken? Dus wat als je in de
Model een bepaalde variabele overal wilt aanspreken? Je gebruikt hiervoor een
zogenaamde class variabele. Dit is een variabele die je niet al te vaak gebruikt. Het is
natuurlijk wel handig om te weten hoe het werkt. In de Model stop je het volgende:
@@classified = "Ik zie dit overal binnen de class."

Je geeft aan of iets een class variabele is door twee apenstaartjes ervoor te zetten. Je kunt
class variabelen alleen in de Class gebruiken. Als je er eentje in de Model aanmaakt, kun je
deze niet gelijk aanspreken in de View of Controller. Je kunt hem wel halen uit de Model
waarvan de variabele is, maar moet dan wel wat extra’s doen. Meer hierover in het Classes
en Modules gedeelte.

3.4.4 Global variables
Erg leuk zo’n class variabele, maar je wilt misschien ook een variabelen hebben die je echt
overal kunnen aanspreken. Dit zijn de zogenaamde global variabelen en zien er zo uit:

$omnipresence = "Ik zie dit overal!"

Zoals je ziet zet je er een dollarteken voor. Deze kun je nu overal aanspreken. Ook buiten
de Class waar je deze hebt gemaakt. Je zult deze, net als de class variabelen, niet echt vaak
gebruiken.

3.4.5 Constants
Een ander soort variabele wat eigenlijk geen variabele is (omdat het niet variabel is), is een
constant. Deze wordt aangegeven in volledige hoofdletters (er mogen geen cijfers gebruikt
worden). Een ander kenmerk van een constant is dat je het niet kunt aanpassen nadat het
eenmaal is gedeﬁnieerd.
NO_CHANGE = "Dit kan je niet aanpassen."

Als je het nu probeert aan te passen krijg je het volgende:

25 - Instappen in Ruby on Rails 3 - Robin Brouwer

NO_CHANGE = "Ik ga het toch proberen."
	 # => warning: already initialized constant NO_CHANGE

Een constant kan je net als een class variabele alleen binnen een Class gebruiken. Als je een
constant in een Model stopt kun je deze alleen vanuit een externe Class bereiken door de
Model aan te spreken. Hoe dit werkt laat ik in het Classes en Modules gedeelte zien.
Dit zijn de variabelen die je moet kennen in Ruby. Naast deze variabelen zijn er ook
pseudo variabelen en voor-gedeﬁnieerde variabelen. Ik heb deze variabelen nog nooit
gebruikt en het lijkt me dat jij die ook niet tot nauwelijks zult gebruiken. Als je echter wilt
weten hoe deze in elkaar steken kun je het natuurlijk opzoeken.

3.5 Arrays
We gaan nu iets dieper in op Ruby en met zogenaamde ‘Arrays’ werken. Een Array is
simpelweg een lijst met gegevens. Je stopt gegevens in deze lijst en kunt deze later weer
ophalen.
Om een Array te maken typ je het volgende:

my_array = []

Je maakt een lokale variabele aan genaamd ‘my_array’ en geeft aan dat het een Array is
met de twee rechthoekige haken [ ]. Je kunt op de volgende manier gegevens in een Array
stoppen:

my_array = []
my_array[0] =
my_array[1] =
my_array[2] =
my_array[3] =

"Dit"
" is"
" een"
" Array"

Zoals je ziet spreek je de variabele aan en stop je tussen de haakjes een cijfer. Je geeft aan
op welke plaats in de lijst de data moet worden opgeslagen. Je stopt het woord ‘Dit’ in de
eerste plaats van de Array. Let wel op dat het eerste gegeven in een Array met het cijfer 0
wordt aangegeven en niet met 1. Je telt altijd vanaf 0 als het om Arrays gaat. Je stopt ook
data in de tweede [1], derde [2] en vierde [3] plaats van de Array. Een Array is zoals je ziet
een simpele lijst waarin je gegevens stopt. Het uitlezen van deze gegevens is ook erg
makkelijk:

26 - Instappen in Ruby on Rails 3 - Robin Brouwer

puts my_array[0] + my_array[1] + my_array[2] + my_array[3]	
# => Dit is een Array

Je spreekt de rij aan waarin je het hebt opgeslagen en kan, net zoals bij een String, een
plusteken gebruiken om het aan elkaar te voegen. Het gegeven in de rij wordt namelijk
gezien als een String. Om de complete Array te tonen doe je het volgende:

puts my_array	 # => ["Dit", " is", " een", " Array"]

Je laat de volledige Array zien. Ruby zorgt ervoor dat dit op de juiste volgorde gebeurt. Je
kunt ook data in de Array stoppen zonder zoveel code te schrijven:

my_array2 = ["Dit", " is", " nog", " een", " Array"]

Je maakt nu een tweede Array aan en stopt gelijk alle gegevens erin. Je kunt ook de ‘push’
method gebruiken op een Array om aan het einde van de lijst iets toe te voegen.

my_array2.push(" en dit is een push.")
my_array2.join	# => Dit is nog een Array en dit is een push.

De join method zorgt ervoor dat er een String van de Array wordt gemaakt. Je kunt hier
ook iets aan meegeven, zodat tussen elke rij in de lijst iets wordt geplaatst.

my_array3 = ["appels", "peren", "bananen"]
my_array3.join(", ")	# => appels, peren, bananen

Hier wordt een komma en een spatie tussen elke rij geplaatst voordat er een String wordt
gemaakt.
Er zijn naast de push en join methods een aantal andere handige functies die je kunt
aanroepen om de Array aan te passen. Zo kan je het volgende doen om de Array te legen:

my_array2.clear	
my_array3.clear	

# => []
# => []

27 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je leegt de Array als je de clear method aanroept. Je kunt met de ‘concat’ method ook
Arrays samenvoegen.

my_array2 = ["Dit", "is", "nog", "een", "Array"]
my_array3 = ["en", "dit", "is", " oncatenate!"]
puts my_array2.concat(my_array3).join(" ")
# => Dit is nog een Array en dit is concetenate!

De twee Arrays worden nu aan elkaar samengevoegd en er word een String van gemaakt
doordat de join method erop wordt aangeroepen.
Naast deze methods zijn er nog veel meer dingen die je met een Array kunt doen. Meer
hierover kun je in de Ruby documentatie vinden.

3.6 Hashes
Een Hash lijkt ontzettend veel op een Array. Het grote verschil is dat je niet met cijfers
werkt om aan te geven waarin de data moet komen, maar met woorden. Je maakt een
Hash op een soortgelijke manier aan als een Array:

my_hash = {}

Je gebruikt in plaats van rechthoekige haken de gekrulde haken, ook wel accolades
genoemd. Om gegevens toe te voegen doe je ongeveer hetzelfde als bij een Array:

my_hash['id'] = 1
my_hash['naam'] = "Robin"

Je werkt nu echter niet met cijfers, maar met een String om aan te geven waar de gegevens
komen te staan. Je spreekt deze gegevens op ongeveer dezelfde manier aan:

puts "ID: " + my_hash['id'].to_s
puts "Naam: " + my_hash['naam']

Zoals je ziet spreek je de naam aan door my_hash[‘naam’] in te typen.
De String die je gebruikt in de Hash wordt de ‘key’ genoemd en de waarde die deze heeft
de ‘value’. Naast het gebruiken van een String als key voor de Hash kun je ook een
Symbol gebruiken.
28 - Instappen in Ruby on Rails 3 - Robin Brouwer

my_hash[:id] = 1
my_hash[:naam] = "Robin"

Dit werkt op precies dezelfde manier als met een String. In Ruby on Rails zie je echter
vaak een Symbol voorbij komen in plaats van een String. Daar zijn verschillende redenen
voor. De belangrijkste is dat een Symbol onveranderlijk en hierdoor sneller en efﬁciënter is
in Ruby. Wat de andere verschillen zijn tussen een Symbol en een String is voor nu niet
belangrijk. Dat kun je beter zelf onderzoeken mocht je dat willen weten.
Het snel invoeren van gegevens in een Hash werkt een stuk anders dan bij een Array,
omdat er nu niet automatisch bekend is waarin de gegevens moeten worden gestopt. Bij
een Array wordt er opgeteld vanaf het cijfer 0. Dit kan niet met willekeurige woorden. Je
moet altijd de key opgeven. Je doet daarom het volgende:

my_hash2 = { :id => 2, :naam => "Daniël" }

Je geeft de key op en verwijst met een pijltje (=>) naar de value. In Ruby 1.9 (nieuwe versie
van de programmeertaal Ruby) kun je echter nog iets doen om een Hash te maken. De
‘hash rockets’ (de pijltjes die je gebruikt) zijn niet meer nodig. Er is nu een soortgelijke
syntax zoals je bij JavaScript - en veel andere programmeertalen - hebt.

my_hash3 = {
id: 3,
naam: "Jeroen"
}

Hiernaast zorgt Ruby 1.9 ervoor dat een Hash zijn volgorde onthoudt, zodat je er
gemakkelijk doorheen kunt lopen. Je kunt nog steeds het pijltje gebruiken in een Hash.
Het is niet zo dat je dit nu per se moet gebruiken. Je kunt het zelfs door elkaar gebruiken.
Je gebruikt alleen de nieuwe manier als de keys in de Hash uit Symbols bestaan. De
nieuwe manier gaat er namelijk vanuit dat de keys Symbols zijn. Als je een Hash hebt met
ook andere type keys erin (zoals een String), gebruik het dan niet door elkaar, maar doe
het op de oude manier.
In dit boek zal ik alle Hashes die worden gebruikt op de nieuwe manier uitschrijven, tenzij
er iets anders dan een Symbol gebruikt moet worden als key in de Hash. Als je Ruby 1.8
gebruikt moet je dit even veranderen naar de oude syntax.

29 - Instappen in Ruby on Rails 3 - Robin Brouwer

Er zijn net als bij Arrays een aantal functies om Hashes mee te veranderen. Zo kun je ook
een Hash legen met clear, net als bij een Array. Ook dit kun je allemaal vinden in de Ruby
documentatie.

3.7 If/else statements
Een van de belangrijkste en veelgebruikte dingen bij het programmeren zijn if/else
statements. Dit zijn statements die een bepaalde check uitvoeren. Op basis hiervan wordt
een stuk code uitgevoerd. Dus als (if) dit klopt doe je het volgende en als dit niet klopt
(else) doe je het andere. In Ruby ziet dit er wat anders uit, omdat je geen accolades hoeft te
gebruiken.

if 1+1 == 2
puts "Ruby kan rekenen!"
end
# => Ruby kan rekenen!

Je geeft als eerste aan dat het een if-statement is met het woord ‘if’. Daarna komt de
vergelijking. Bij deze if-statement kijk je of 1+1 gelijk is aan (==) 2. Als dit zo is, dan krijg je
de String te zien. Je sluit het af met het woord ‘end’. Zo simpel is het!
De volgende stap is het gebruiken van ‘else’ in de if-statement.

if 1+2 == 4
puts "Ruby kan niet rekenen!"
else
puts "Ruby kan rekenen!"
end
# => Ruby kan rekenen!

Dit ziet er ongeveer hetzelfde uit als bij de vorige if-statement, maar nu klopt de
vergelijking niet en is er een ‘else’ toegevoegd. Dus als de som fout is, wordt de tekst
tussen ‘else’ en ‘end’ getoond. Gelukkig gebeurt dit ook.
Maar wat als je meerdere if-statements wilt gebruiken en deze afhankelijk van elkaar wilt
maken? Dan gebruiken we ‘elsif’. Dit is een gecombineerde ‘if’ en ‘else’:

30 - Instappen in Ruby on Rails 3 - Robin Brouwer

if 1+2 == 4
puts "Ruby kan niet rekenen!"
elsif 2+2 == 4
puts "Ruby kan rekenen!"
end
# => Ruby kan rekenen!

We hebben nu de ‘else’ vervangen voor ‘elsif’. Hierachter kunnen we een andere ifstatement neerzetten. Nu kijkt Ruby eerst of 1+2 gelijk is aan 4 en als dit niet klopt kijkt hij
of 2+2 gelijk is aan 4. Let er op dat je elsif goed spelt. In veel programmeertalen wordt elsif
anders gespeld en dat kan voor sommigen verwarrend zijn. Het is dus niet elseif, maar
elsif!

3.7.1 && en ||
Om meerdere checks te doen in een if-statement kun je && (dit staat voor EN) en || (dit
staat voor OF) gebruiken.
if 2+2 == 4 && 3+3 == 6
puts "Beide sommen kloppen."
end
# => Beide sommen kloppen.
if 1+2 == 4 || 2+2 == 4
puts "2+2=4 klopt, maar 1+2=4 klopt niet."
end
# => 2+2=4 klopt, maar 1+2=4 klopt niet.

Bij het eerste voorbeeld hierboven kijken we of 2+2 gelijk is aan 4 en 3+3 gelijk is aan 6. Als
beide sommen kloppen, dan pas krijg je de tekst te zien. Dit is een && operator en staat
voor EN.
Het tweede voorbeeld is iets complexer. Hier wordt gekeken of een van de twee sommen
klopt. Zo klopt hier de tweede som wel, maar de eerste som niet. Toch wordt de tekst
getoond. Ook als beide sommen zouden kloppen wordt de tekst getoond. Dit is een ||
operator en staat voor OF.

3.7.2 Unless
Naast het gebruiken van ‘if’ kun je ook ‘unless’ gebruiken. Dit zorgt ervoor dat er naar het
omgekeerde wordt gekeken. Dus ‘als dat niet zo is’, doe dan het volgende. Dit ziet er zo
uit:

31 - Instappen in Ruby on Rails 3 - Robin Brouwer

unless 2*3 == 4
puts "Unless werkt ook goed."
end
# => Unless werkt ook goed

Om dit met een if-statement voor elkaar te krijgen zou je het volgende moeten doen:

if 2*3 != 4
puts "If werkt ook goed."
end
# => If werkt ook goed

Ik raad je wel aan om gewoon if te blijven gebruiken. Als je met unless gaat werken
kunnen lastigere checks een stuk complexer eruitzien, omdat je omgekeerd moet denken.
Gebruik unless alleen bij kleine, simpele checks die je uitvoert.
Naast het checken van cijfers kun je natuurlijk ook kijken of een String, Array, Hash of
variabele overeenkomt met een opgegeven waarde. Dit werkt op precies dezelfde manier.

3.7.3 Operators
Naast de == operator zijn er een aantal andere operatoren die je kunt gebruiken. Hier zie je
ze op een rijtje:
> 	Groter dan
< 	Kleiner dan
>= 	 roter dan of gelijk aan
G
<= 	 leiner dan of gelijk aan
K
!= 	 iet gelijk aan
N
==	Gelijk aan

Zo kun je kijken of bepaalde gegevens kloppen en op basis hiervan bepaalde acties
uitvoeren. Naast de hierboven behandelde operatoren zijn er nog veel meer te vinden. De
Ruby documentatie is weer de locatie om dit allemaal te bekijken.

3.7.4 Andere if-statement syntax
Naast de syntax van de if-statements die ik hierboven heb getoond zijn er een paar andere
manieren om een if-statement uit te schrijven. Je kunt namelijk ook alles op 1 regel doen:

32 - Instappen in Ruby on Rails 3 - Robin Brouwer

puts "1+1=2" if 1+1 == 2	

# => 1+1=2

Ruby voert nu alleen de regel uit als de check klopt.
Naast deze vorm van if-statements heb je ook nog een andere die veel gebruikt wordt.
Deze ziet er als volgt uit:

title = "Korte titel"
puts title != "" ? title : "Geen titel"	

# => Korte titel

Als eerste zet je de check neer. Hierna stop je een vraagteken om aan te geven dat het
voorgaande de check was. Wat tussen de vraagteken en de dubbele punt (:) staat wordt
uitgevoerd als de check klopt. Als dit niet klopt wordt hetgeen na de dubbele punt
uitgevoerd. Je kunt deze if-statement weer nesten om meerdere checks uit te voeren op
één regel. Deze manier van if-statements uitschrijven wordt vaak gebruikt om langere ifstatements in te korten. Je moet dit echter niet overdrijven. Het is een stuk lastiger om een
ontzettend lange regel te lezen dan een nette if-statement over een aantal regels.

3.7.5 Verschil tussen empty en nil
Zoals je ziet checken we hierboven of een variabele niet een lege String is. Er is ook een
andere manier om dit te checken. Hiervoor moet je begrijpen wat het verschil is tussen
‘empty’ en ‘nil’.
Als iets ‘empty’ is betekent het dat het gewoon leeg is. Denk aan een lege String of een
lege Array. Je kunt kijken of iets leeg is door de ‘empty?’ method aan te spreken op een
object.
empty_string = ""
empty_array = []
empty_string.empty?	 # => true
empty_array.empty?	 # => true

Als iets ‘nil’ is betekent het dat het geen object is. Het is een leeg object. Het is dus geen
lege String of Array. In andere programmeertalen heet dit meestal ‘null’.
nil_object = nil
nil_object.nil?	
nil_object.empty?	

	
	

# => true
# => ERROR

33 - Instappen in Ruby on Rails 3 - Robin Brouwer

Zoals je ziet mag je hier ook geen ‘empty’ op aanspreken. Je krijgt dan een error terug.
Daarom is het ook belangrijk om op veel plaatsen in je applicatie te checken of iets nil is of
niet. Doe je dit niet, dan kan het zo zijn dat je errors krijgt. En dat wil je niet.

3.7.6 blank? en present?
Zo nu en dan wil je checken of een object zowel nil als leeg is. Rails heeft hiervoor twee
handige functies toegevoegd:
blank?	 # nil of leeg
present?	# niet nil en niet leeg

Met ‘blank?’ kun je kijken of iets nil of leeg is. De ‘present?’ method is het
tegenovergestelde en geeft ‘true’ terug als het object zowel niet nil en niet leeg is. Het
handige is dat je deze methods ook op nil objecten mag aanroepen.
title = nil
puts title.present? ? title : "Geen titel"	 # => Geen titel

Let dus op: deze twee methods werken alleen als je in Ruby on Rails werkt. Rails heeft
namelijk deze twee methods toegevoegd aan Ruby. Het maakt het schrijven van ifstatements een stuk gemakkelijker.

3.8 Booleans
Een Boolean gebruik je om aan te geven of iets klopt of niet. Je werkt enkel en alleen met
‘true’ of ‘false’ (1 of 0). Zo kun je het volgende doen om een Boolean in een variabele te
stoppen:
goed = true

Je kunt dan een if-statement gebruiken om te kijken wat de status van de variabele is.
if goed == true
puts "Het klopt helemaal!"
end
# => Het klopt helemaal!

Je hoeft niet per se ‘== true’ te gebruiken bij een Boolean. Het volgende doet precies
hetzelfde:
34 - Instappen in Ruby on Rails 3 - Robin Brouwer

if goed
puts "Het klopt helemaal!"
end
# => Het klopt helemaal!

Je kunt op deze manier gemakkelijk kijken of iets klopt of niet. En aangezien alles wat
digitaal is bestaat uit nullen en enen zul je het ook heel vaak nodig hebben.

3.9 Iterators
Met iterators wordt het doorlopen van gegevens bedoeld. Je kunt dit zien als een ‘loop’
waarmee je bijvoorbeeld door een Array heen kunt gaan. Er zijn verschillende soorten
loops. Zo heb je een ‘for loop’, ‘each loop’, ‘while loop’ en nog veel meer. Ik zal deze drie
hier behandelen. Wil je weten wat voor andere loops er in Ruby zitten? Dan kun je dit het
beste zelf onderzoeken.

3.9.1 FOR loop
Een ‘for loop’ gebruik je om door verschillende dingen heen te lopen, zoals een Array of
een lijst met nummers. In Ruby gaat dit erg gemakkelijk:
loop_array = [1, 2, 3]
for number in loop_array do
puts number
end
# => 1
# => 2
# => 3

We maken eerst een Array aan en stoppen hier gegevens in. Daarna beginnen we de for
loop. Deze ziet er als volgt uit:
for number in loop_array do

Voor elke loop is de variabele ‘number’ in de Array ‘loop_array’ aan te spreken. In de
eerste iteratie (één keer door de loop heengaan) wordt het nummer 1 in de variabele
‘number’ gestopt. Bij de tweede loop is dit 2 en bij de derde is het 3. Hij loopt door totdat
de hele Array is doorlopen.
De loop wordt altijd afgesloten met ‘end’ en tussen ‘for’ en ‘end’ wordt de code neergezet
die steeds moet worden uitgevoerd.
35 - Instappen in Ruby on Rails 3 - Robin Brouwer

3.9.2 EACH loop
Een ‘each loop’ doet precies hetzelfde als de ‘for loop’. Het verschil is hoe je het schrijft en
hoe er wordt omgegaan met de variabele die in de loop wordt gebruikt.
loop_array = [1, 2, 3]
loop_array.each do |number|
puts number
end
# => 1
# => 2
# => 3

Hier is de variabele die je kunt gebruiken binnen de loop tussen pijpjes gezet. Het grote
verschil is dat bij een each loop de variabele wordt vergeten nadat de loop is doorlopen.
Als je na de loop number probeert op te halen, kan dat simpelweg niet. Bij een for loop
wordt deze variabele wel onthouden, wat voor sommige gevallen niet zo handig is. Ik
raad daarom aan om een each loop te gebruiken. Ook omdat je hierdoor ‘each_with_index’
kunt gebruiken, waardoor je automatisch een index bewaart die je kunt aanspreken in de
loop.
loop_array = [1, 2, 3]
loop_array.each_with_index do |number, i|
puts i
end
# => 0
# => 1
# => 2

In Ruby 1.9 is er nog iets veranderd met de each loop. Hier een klein voorbeeld hoe de
each loop werkte in Ruby 1.8:
number = 2
(1..3).each do |number|
puts number
end
# => 1
# => 2
# => 3
puts number 	 # => 3

36 - Instappen in Ruby on Rails 3 - Robin Brouwer

Dat (1..3) wat je ziet is een Range. Je geeft een begin- en eindnummer aan en er wordt een
Array teruggegeven met alle nummers ertussen, inclusief de opgegeven nummers. Waar
het mij om gaat bij dit voorbeeld is dat we voor de loop een variabele ‘number’ hebben en
deze de waarde 2 geven. In de loop noemen we de variabele voor elke iteratie ook number.
Na de loop is echter onze oude variabele overschreven. Niet erg handig natuurlijk. In
Ruby 1.9 is dit opgelost. Je krijgt nu een 2 terug en de variabele wordt niet overschreven
door de variabele in de loop.
Dit is overigens niet wat ik bedoelde met het verschil tussen een for en each loop. Als je de
number variabele boven de loop niet zet en na de loop alsnog deze variabele wilt
gebruiken krijg je een error.

(1..3).each do |number|
puts number
end
# => 1
# => 2
# => 3
puts number 	 # => undefined local variable or method `number'

Als je dit bij een for loop doet krijg je wel gewoon 3 te zien. Zelfs bij Ruby 1.9. Daarom nog
een keer: gebruik de each loop!

3.9.3 WHILE loop
Een ‘while loop’ wordt gebruikt om een stuk code steeds uit te voeren als een bepaald
gegeven overeenkomt met het gewenste gegeven. Dit ziet er als volgt uit:
uren = 0
while uren <= 3
puts uren
uren += 1
end
puts "Je hebt nu meer dan 3 uur Ruby geleerd."
# => 0
# => 1
# => 2
# => 3
# => Je hebt nu meer dan 3 uur Ruby geleerd.

Hier geef je aan dat het aantal uur dat je Ruby hebt geleerd eerst 0 is. Je maakt daarna een
while loop aan die wordt uitgevoerd totdat het aantal uur hoger is dan 3. Je telt bij elke
interatie 1 uur bij het aantal uur op. Dit doe je met de += operator. Deze telt het volgende

37 - Instappen in Ruby on Rails 3 - Robin Brouwer

getal op bij het daarvoor genoemde getal. Dit werkt ook met andere Ruby classes, zoals de
String. Je hebt ook nog -=, *= en /=. Wat deze operatoren doen lijkt me wel duidelijk.
Zo werkt een while loop. Je kunt ook speciale functies aanroepen om iets te doen binnen
een loop. Zo kun je de loop onderbreken met ‘break’, naar de volgende iteratie gaan met
‘next’ en de huidige iteratie nog een keer doen met ‘redo’. Let wel goed op dat je niet een
oneindige loop maakt. Dit kan je applicatie of Ruby script laten vastlopen.
Er zijn nog een aantal andere iterators in Ruby. Deze zul je niet vaak gebruiken, maar als je
ze een keer nodig hebt kun je ze natuurlijk opzoeken.

3.10 Date, DateTime en Time
Je kunt in Ruby gemakkelijk de huidige tijd en datum ophalen. Je kunt ook rekenen met
tijden en datums. Er zijn drie soorten classes waarmee je de tijd en/of datum kan
weergeven. Dit zijn Date, DateTime en Time.

3.10.1 Date
Met Date krijg je alleen de datum te zien. Dit krijg je in het volgende formaat te zien:
YYYY-MM-DD. Je kunt heel gemakkelijk de huidige datum aanroepen in Ruby:
Date.today

Je krijgt dan de huidige datum te zien in het hierboven genoemde formaat. Je kunt ook
Date.new doen en zelf allemaal berekeningen erop uitvoeren.
Let erop dat Date niet een String is! Het is een Date object en heeft niet de functies die een
String heeft. Om een Date te vervormen naar een String gebruiken we de functie strftime
(staat voor ‘string format time’).
my_date = Date.today
my_date.strftime("%d/%m/%Y")

De functie strftime zorgt ervoor dat er een String gemaakt wordt van een Date, DateTime
of Time object. Je geeft een String mee aan de functie om aan te geven hoe je de datum wilt
weergeven.
%d is de dag in cijfers, %m de maand in cijfers en %Y het jaartal. Je hebt een heleboel
manieren om de datum te transformeren. Zo kan je ook de maand in letters krijgen en de
dagen van de week.

38 - Instappen in Ruby on Rails 3 - Robin Brouwer

Naast strftime kun je nog veel meer met de Date Class doen. Meer hierover in de Ruby
documentatie.

3.10.2 DateTime
De DateTime Class gebruik je om zowel een datum als tijd te krijgen. Je krijgt dit te zien in
het volgende formaat: YYYY-MM-DD HH:MM. Hier zitten nog wat extra dingen tussen
voor onder andere de tijdzone. Wat anders is in Ruby 1.9 is dat je niet direct DateTime
kunt aanroepen. Je moet eerst de Class toevoegen aan je script. Om de huidige tijd te
krijgen doe je het volgende:
require "date"
my_date = DateTime.now

Je kunt hier ook strftime gebruiken:
require "date"
my_date = DateTime.now
my_date.strftime("%d/%m/%Y %H:%M")

Zoals je ziet heb je %H om het aantal uur te laten zien en %M om het aantal minuten te
tonen. Je kunt ook hier veel meer doen dan alleen een String ervan maken. Ook dit kun je
vinden in de Ruby documentatie.

3.10.3 Time
De Time Class werkt ongeveer hetzelfde als de DateTime Class. Deze Class hoef je
overigens niet toe te voegen als je Ruby 1.9 gebruikt. Je kunt deze gelijk aanspreken. Je
krijgt dan een datum en een tijd terug en je kunt Time.now gebruiken om de huidige tijd te
krijgen. Het grote verschil is dat Time gebruikmaakt van de POSIX-standaard. Deze telt
alle seconden vanaf 1 januari 1970 en kan geen datum vinden vóór die dag. Time zul je
vooral gebruiken om de huidige tijd en datum te vinden. Dit doe je omdat het een heel
stuk sneller is dan DateTime. Time is namelijk in C geschreven en DateTime is Ruby. Als je
een geboortedatum nodig hebt of een andere datum voor 1970 moet je DateTime
gebruiken.

3.11 Classes en Modules
In Ruby kun je een Class of Module maken om functies in te stoppen. Een Class is een
object waarin je functies en dergelijke kunt aanmaken die alleen van toepassing zijn op dat
object. Een Module bestaat uit een collectie van functies en constanten en wordt vaak
gebruikt om functies en constanten in een Class te groeperen.

39 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je kunt een Module in een Class stoppen, zodat de functies en constanten van de Class
worden. Een Module is eigenlijk bedoeld om je functies en constanten te ordenen en een
duidelijke naam te geven. Als je bijvoorbeeld een Class genaamd ‘Vakanties’ hebt en je
hebt een aantal functies over bijvoorbeeld Spanje, Frankrijk en Italië, dan kan je al deze
functies groeperen in de Modules ‘Spanje’, ‘Frankrijk’ en ‘Italie’.
Je kunt Classes echter niet in elkaar stoppen. Je kunt wel Classes van elkaar laten
overerven. Dan worden de functies uit de Class waarvan wordt geërfd ook bereikbaar in
de Class die het overerft. Modules kunnen dit weer niet.

3.11.1 Class
Om een nieuwe Class te maken doe je het volgende:
class MyWorld
# Hier komen de functies voor de Class
end

De naam van een Class en Module is altijd in CamelCases geschreven. Om nu functies toe
te voegen aan een Class moet je eerst weten wat het verschil is tussen een ‘class method’
en een ‘instance method’.
Class en instance methods
Instance en class methods zijn acties of functies die binnen een Class zitten. In deze acties
zit code die kan worden uitgevoerd als de actie wordt aangeroepen. Je kunt ze op
verschillende manieren aanroepen. Dat is gelijk ook het verschil tussen instance en class.
Stop de volgende twee methods in de Class die we net hebben gemaakt:

class MyWorld
def self.hello_world
puts 'Dit is een Class Method'
end
def goodbye_world
puts 'Dit is een Instance Method'
end
end

Zoals je ziet zet je ‘def’ voor de naam van de method. Dit staat voor ‘deﬁne’ en is een
regeltje om aan te geven dat je een nieuwe method wilt aanmaken. De naam van de
method is altijd in kleine letters geschreven, mag cijfers bevatten en heeft een underscore
(_) in plaats van witruimte.

40 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je ziet bij de eerste method ‘self.hello_world’ staan. Als je ‘self’ gebruikt wordt het een
class method. Als je dit er niet voorzet is het een instance method. Dat is het grote verschil.
Er zit ook een verschil in hoe je de methods kan aanroepen.

class MyWorld
def self.hello
puts 'Class Method'
end
def goodbye
puts 'Instance Method'
end
end
MyWorld.hello	 	
# => Class Method
MyWorld.goodbye	
# => NoMethodError: undefined method
	 	
	
	
‘goodbye’ for MyWorld:Class
world = MyWorld.new
world.hello	
	
	 	
	
	
world.goodbye 		

# => NoMethodError: undefined method ‘hello’
for #<MyWorld:0x1e820>
# => Instance Method

Je spreekt een class method aan door eerst de naam van de Class op te geven en na de
punt de naam van de method te geven. ‘MyWorld.hello’ spreekt de eerste method aan die
je hebt aangemaakt en laat ‘Class Method’ zien. Je kan de instance method niet op deze
manier aanspreken. Zoals je ziet krijg je dan een error. Om een instance method aan te
spreken moet je een nieuwe ‘instance’ maken van de Class. Dat doe je met ‘MyWorld.new’.
Op deze instance kun je nu de instance method ‘goodbye’ aanroepen. Dit werkt dan weer
niet met een Class Method.
Argumenten meesturen
Je kunt ook argumenten (ook wel parameters genoemd) meesturen naar een method. Dit
werkt als volgt:
class MyWorld
def self.say(text)
puts text
end
end
MyWorld.say('Hello!') # => Hello!

Je geeft bij de naam van de method aan welke argumenten nodig zijn. Deze kun je dan
aanspreken in de method. Ruby staat het niet toe om geen argumenten mee te sturen als je

41 - Instappen in Ruby on Rails 3 - Robin Brouwer

een method aanroept die argumenten verwacht. Om dit te omzeilen kun je een
standaardwaarde zetten op de variabele.

class MyWorld
def self.say(text='Hello World!')
puts text
end
end
MyWorld.say # => Hello World!

Na de variabele geef je met een is-teken (=) aan wat de standaardwaarde is. Je hoeft in
Ruby overigens geen haakjes te gebruiken om iets te sturen naar een method. Het
volgende werkt ook:

class MyWorld
def self.say text
puts text
end
end
MyWorld.say 'Hello' # => Hello

Er is echter een Ruby conventie die zegt dat je dit niet moet doen. Hier later meer over.
*args en &block
Naast standaard variabelen als argumenten kun je ook ‘*args’ en ‘&block’ gebruiken in een
method. Het *args argument zorgt ervoor dat je zoveel argumenten kunt meesturen als je
wilt. De naam van deze argumenten staat dan ook niet vast.
class MyWorld
def self.say(*args)
puts args.map { |arg| arg }
end
end
MyWorld.say('Hello', 'Goodbye')
# => Hello
# => Goodbye

Naast meerdere Strings meesturen kun je ook een Hash of Array meesturen naar de
method. In het View gedeelte zal ik nog iets verder ingaan op het *args argument.
Het &block argument zorgt ervoor dat de method een ‘block method’ wordt. Dit houdt in
dat je iets kunt meegeven tussen ‘do’ en ‘end’.
42 - Instappen in Ruby on Rails 3 - Robin Brouwer

class MyWorld
def self.say(&block)
puts block.call
end
end
MyWorld.say do
"Hello and Welcome"
end
# => Hello and Welcome

Je roept de ‘call’ method aan om het block uit te voeren. Je kunt nog veel meer met een
block method doen. Dit is echter nog een beetje te geavanceerd voor nu.
Class constanten en variabelen
Ik had beloofd om te laten zien hoe je constanten en class variabelen kunt aanroepen die in
een Class zitten. Ik zal eerst laten zien hoe dit werkt met class variabelen.
Bij een class variabele moet je een class method maken om de variabele uit te kunnen
lezen. Dit noemt men een ‘getter’. Het zetten van de variabele wordt een ‘setter’ genoemd.
Je kunt ook een standaardwaarde aan de variabele geven.
class MyWorld
@@hello = "Hello World!"		
def self.hello	
@@hello
end

	

def self.hello=(value)	
@@hello = value
end
end

# => default

	

# => getter

	

# => setter

MyWorld.hello # => Hello World!
MyWorld.hello = "Hallo Wereld!"
Myworld.hello # => Hallo Wereld!

Je kunt een class variabele niet aanspreken buiten de Class. Je moet een getter toevoegen
aan de Class om dit voor elkaar te krijgen. Om de waarde aan te passen kun je een setter
method aanmaken. Dit is een speciale method waar ik later wat meer over vertel. Ook zal
ik dan laten zien hoe je een getter en setter maakt voor een instance van een Class.
Een constante werkt iets gemakkelijker.
43 - Instappen in Ruby on Rails 3 - Robin Brouwer

class MyWorld
HELLO = "Hello World!"
end
puts MyWorld::HELLO # => Hello World

Met twee dubbele punten kun je de constante aanroepen. Een heel stuk gemakkelijker.
Maar je kunt de constante natuurlijk niet aanpassen. Dit kan dan weer wel met een class
variabele.
public, private en protected
Wat je tot nu toe hebt gezien zijn public methods. Deze kun je buiten de Class aanroepen.
Je heb echter ook zogenaamde private en protected methods. Dit werkt in Ruby iets
anders dan je misschien gewend bent.
class MyWorld
def hello
say_hello
end
private
def say_hello
"Hello World!"
end
end
puts MyWorld.new.hello # => Hello World
puts MyWorld.new.say_hello # => NoMethodError: private method `say_hello`

Na het woord private wordt alles private. Je kunt dit dan niet ergens buiten de Class
aanroepen, maar wel daarbinnen. Als je dat wel doet krijg je een error dat je geen private
method mag aanroepen.
Je kunt naast private ook protected gebruiken. Dit doe je op dezelfde manier als bij
private. Het verschil tussen private en protected is dat protected methods vanuit dezelfde
Class aangeroepen mogen worden in een nieuwe instantie. Klinkt misschien ingewikkeld,
maar dat is het niet. Hier een voorbeeld om het te illustreren.

44 - Instappen in Ruby on Rails 3 - Robin Brouwer

class MyWorld
def hello
MyWorld.new.say_hello
end
protected
def say_hello
"Hello World!"
end
end
puts MyWorld.new.hello # => Hello World

We hebben private veranderd naar protected en de hello method is ook iets anders. Hierin
wordt een nieuwe instantie van dezelfde Class gemaakt en wordt say_hello aangeroepen.
Als dit een private method was zou je een error terug krijgen. Je moet dan namelijk in
dezelfde instantie blijven om er gebruik van te maken (zoals het voorbeeld hiervoor). Bij
een protected method is dit niet nodig en werkt het gewoon. Ruby weet dat je al in die
Class zit en dat het mag. Dat is het verschil tussen protected en private. Private is eigenlijk
iets strikter. De protected method mag je ook nog steeds niet uitvoeren vanuit een andere
Class.

3.11.2 Module
Een Module is een verzameling van functies en constanten. Je kunt er niet, zoals bij een
Class, een instantie van maken. Er zijn geen class methods of instance methods. Het is een
manier van methods ordenen. Een Module maak je als volgt aan:
module MyMethods
# Hier komen de Module methods
end

Hierin stop je de methods die je nodig hebt. Hier een voorbeeld:
module MyMethods
def hello_world
puts 'Hello World!'
end
end
include MyMethods
hello_world	
	

# => Hello World!

45 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je moet wel opletten dat je de Module ‘include’ op de plaats waar je het wilt gebruiken.
Alle methods worden dan op die plaats neergezet. Dit zou je op dezelfde manier doen als
je het in een Class stopt.

3.12 Procedures
In Ruby heb je de beschikking tot een zogenaamde Proc (afkorting voor Procedure) om
een blok code uit te voeren die gekoppeld is aan een variabele. Het is een object die je later
kunt uitvoeren en is te vergelijken met een method in een Class. Het werkt echter net iets
anders.

times3 = Proc.new { |n| n * 3

}

We hebben nu een Proc object in de variabele ‘times3’ gestopt. In dit Proc object kunnen
we iets meegeven. Hetgeen wat wordt meegegeven wordt met 3 vermenigvuldigd. Om de
Proc uit te voeren gebruik je de ‘call’ method, net zoals bij een block.

puts times3.call(2)	 	

# => 6

Nu wordt 2 vermenigvuldigd met 3 en krijg je 6 terug. Het is een gemakkelijke manier om
een method op één regel te stoppen en wordt vaak gebruikt in zowel Ruby als Rails.
Je kunt ook meerdere argumenten meesturen naar een Proc.

multiply = Proc.new { |x, y| x * y
puts multiply.call(3, 3) 	 # => 9

}

Met deze Proc kun je twee getallen vermenigvuldigen. Naast dit Proc object heb je iets
soortgelijks genaamd ‘lambda’.

multiply = lambda { |x, y| x * y }
puts multiply.call(3, 3) 	 # => 9

Dit werkt precies hetzelfde. Het grote verschil is dat bij lambda altijd alle argumenten
moeten worden meegestuurd. Als je bij Proc de y waarde niet meestuurt wordt dit een nil
object. Bij lambda krijg je een error dat je niet de juiste argumenten hebt meegestuurd. De
lambda functie is een stuk strenger.

46 - Instappen in Ruby on Rails 3 - Robin Brouwer

multiply = lambda { |x, y| x * y }
puts multiply.call(3)
# => ArgumentError: wrong number of arguments (1 for 2)
multiply = Proc.new { |x, y| x * y }
puts multiply.call(3)
# => TypeError: nil can't be coerced into Fixnum

Zoals je ziet staat lambda het niet toe om de procedure uit te voeren. De Proc doet dit wel,
waardoor er een error ontstaat bij het vermenigvuldigen. Het is daarom aan te raden om
lambda te gebruiken als alle argumenten moeten worden meegestuurd.

3.13 Ruby conventies
Nu je de basis van Ruby begrijpt is het tijd om wat conventies in je hoofd te stampen. Je
kunt het programmeren van Ruby op je eigen manier gaan doen, maar dat is eigenlijk niet
de bedoeling. De community van Ruby én Rails probeert zoveel mogelijk standaarden
neer te zetten. Waarom? Zodat iedereen op ongeveer dezelfde manier programmeert. Het
maakt samenwerken met andere Ruby programmeurs en het aanpassen van Ruby code
een heel stuk gemakkelijker. Code wordt ook gelijk een stuk sneller begrepen.
Als je tijdens het programmeren deze conventies in je achterhoofd houdt, wordt het
programmeren in Ruby een heel stuk plezieriger. Het is echter niet zo dat de lijst
conventies hieronder een soort van wetboek voor Ruby programmeurs is. Er zijn genoeg
programmeurs die het niet eens zijn met een aantal van de punten die ik hieronder zal
behandelen. Ik zal hier wat dieper op ingaan.
De conventies hieronder zijn niet de enige Ruby conventies. Uiteraard zijn er nog een
hoop andere kleine ‘regeltjes’, zoals hoe je comments in de code moet stoppen en
bestanden moet structureren. Als je hierin wilt duiken kun je de volgende handige links
bekijken:
Ruby Coding Conventions
http://rails.nuvvo.com/lesson/5017-ruby-coding-convention
(TinyURL: http://tinyurl.com/2fvafzp)
RubyCodingConventions
http://pub.cozmixng.org/~the-rwiki/rw-cgi.rb?
cmd=view;name=RubyCodingConvention
(TinyURL: http://tinyurl.com/y49ueu)
The Unofﬁcial Ruby Usage Guide
http://www.caliban.org/ruby/rubyguide.shtml
(TinyURL: http://tinyurl.com/yv3nfr)
47 - Instappen in Ruby on Rails 3 - Robin Brouwer

Ook heb ik een bericht over dit onderwerp geplaatst op Atoms, de weblog van 45north. De
reacties op dit bericht heb ik gebruikt om de lijst hieronder op te stellen. Ik wil graag mijn
collega’s Daniël Zwijnenburg en Joachim Nolten bedanken voor hun reacties. Ik heb er
ontzettend veel aan gehad.
Een mooie lijst Ruby conventies opstellen
http://45north.nl/atoms/posts/357-een-mooie-lijst-ruby-conventies-opstellen
(TinyURL: http://tinyurl.com/3mwt7w6)

3.13.1 Naamgeving
Dit is een Ruby conventie waar bijna geen discussie over is. Hoe worden classes,
bestanden, variabelen, methods en constants geschreven in Ruby? Hier zijn in Ruby een
aantal conventies voor waar je je gewoon aan moet gaan houden. Er zijn drie manieren
waarop je elementen in Ruby een naam geeft.
De drie manieren van naamgeving
Allereerst heb je ‘CamelCase’. Dit houdt in dat je alle woorden aan elkaar schrijft en steeds
elke eerste letter van het woord als hoofdletter opschrijft. De zin ‘Have you tried turning it
off and on again’ zou je als volgt schrijven in CamelCase:

HaveYouTriedTurningItOffAndOnAgain

De tweede manier van naamgeving is met alleen hoofdletters. Je gebruikt liggende
streepjes, ook wel ‘underscores’ genoemd, tussen de woorden. Het voorbeeld van
hierboven schrijf je dan als volgt uit:

HAVE_YOU_TRIED_TURNING_IT_OFF_AND_ON_AGAIN

De laatste manier van naamgeving is met alleen kleine letters en underscores tussen de
woorden. Om bij hetzelfde voorbeeld te blijven:

have_you_tried_turning_it_off_and_on_again

Maar wanneer gebruik je welke manier? Dat is vrij simpel:
1) CamelCase gebruik je bij Modules en Classes. Voor de rest gebruik je het niet in Ruby.
2) Hoofdletters en underscores gebruik je alleen bij Constants.
3) De derde manier gebruik je voor alle andere elementen die een naam moeten krijgen:
methods, variabelen en bestanden.
4) Globale variabelen zijn een uitzondering en gebruiken alle drie de manieren.
48 - Instappen in Ruby on Rails 3 - Robin Brouwer

Hier een voorbeeld van een Ruby bestand van hoe het niet moet.

# MyClass.rb
class my_class
MYCONSTANT = "Uppercase"
def MyMethod
myVariable = "camelCase"
end
end

En dan nu hoe het wel moet:

# my_class.rb
class MyClass
MY_CONSTANT = "Uppercase & underscores"
def my_method
my_variable = "Lowercase & underscores"
end
end

Method naamgeving
Wat nog leuk is om te weten is dat je bij methods ook vraagtekens en uitroeptekens mag
gebruiken. Deze stop je aan het einde van de method. Een vraagteken gebruik je bij een
method die ‘true’ of ‘false’ teruggeeft. Je stelt dus eigenlijk een vraag via de method: klopt
dit wel of niet? Deze methods zijn perfect voor if-statements.
def logged_in?
current_user.present?
end
if logged_in?
puts "Welkom!"
end

Methods met een uitroepteken erachter worden ‘bang methods’ genoemd. Een bang
method wordt vaak gezien als een ‘gevaarlijke’ variant op een gewone method. Het doet
iets wat gevaarlijk kan zijn en waar je voor moet opletten. Vandaar ook het uitroepteken.

49 - Instappen in Ruby on Rails 3 - Robin Brouwer

Vaak is een bang method een variant op een gewone method. Zo heb je ‘upcase’ en
‘upcase!’ in Ruby. De ‘upcase’ method zorgt ervoor dat je een String kan transformeren
naar hoofdletters. Als je de bang-versie ervan gebruikt zal de String gelijk worden
getransformeerd.

uitroep_teken = "even testen"
uitroep_teken.upcase
puts uitroep_teken	 	
# => even testen
uitroep_teken.upcase!
puts uitroep_teken	 	

# => EVEN TESTEN

Vaak wordt er gedacht dat een bang method alleen is bedoeld om een object direct aan te
passen. Dat is echter niet zo. Een bang method kan ook iets anders doen. Bang methods
zijn er om aan te geven dat er iets gevaarlijks kan gebeuren binnen de method en dat de
programmeur moet opletten. Ook zijn er genoeg methods die direct het object aanpassen,
maar toch geen uitroepteken erachter hebben staan. Denk aan de Array methods ‘pop’,
‘shift’ en ‘concat’.
Dan heb je ook nog methods met een is-teken erachter. Dit worden ‘setter’ methods
genoemd. Hiermee kun je de waarde van een attribuut veranderen. Ook kun je erg
gemakkelijk bepaalde Ruby code uitvoeren als een attribuut van waarde verandert.

class Lecture
def students		
@students
end

	

# => getter

def students=(total)	
# => setter
@students = total
puts "Total students: #{total}"
end
end
lecture = Lecture.new
lecture.students
lecture.students = 20

# => nil
# => 20
# Total students: 20

Hierboven zie je een getter en setter method voor ‘students’. We hebben er hier voor
gezorgd dat er iets wordt teruggegeven met puts als een nieuwe waarde wordt gezet voor
‘students’. Je kunt dus erg gemakkelijk iets extra’s laten gebeuren als een attribuut van
waarde verandert. Een leuke bijkomstigheid van de setter method.
50 - Instappen in Ruby on Rails 3 - Robin Brouwer

Zoals je ziet kun je op deze manier een getter en setter maken voor een instance van een
Class. Ik had al laten zien hoe je dit met class variabelen kon doen. Voor een instance is er
nog een makkelijkere manier om een getter en setter te maken: attr_accessor.

class Lecture
attr_accessor :students
end
lecture = Lecture.new
lecture.students = 20
puts lecture.students	

# => 20

Dit doet precies hetzelfde als wat we hiervoor deden. Je hoeft dus niet steeds een getter en
setter aan te maken voor een attribuut. Als je de setter zou willen overschrijven is dat wel
gewoon mogelijk.
Ook handig om te weten: bij een method mag je cijfers gebruiken, zolang het niet aan het
begin van het woord is. Behoorlijk lastig als je bedrijf ‘45north’ heet. Je kunt niet voor elke
Class ’45’ neerzetten.

class 45north
def 45deploy
puts "Dit gaat een syntax error opleveren..."
end
end

3.13.2 Twee spaties en geen tabs
Dit is typisch zo’n conventie waar een heleboel mensen het mee eens zijn, maar ook weer
een heleboel mensen niet. Dit is de conventie hoe je de inspringing - in het Engels
‘indentation‘ - van de regels regelt. Standaard staat dit op één tab. En meestal is één tab in
totaal vier spaties. Alleen wordt een tab niet écht gezien als vier spaties en wordt dit door
tekstverwerkers vaak op een andere manier geïnterpreteerd. Dit zorgt ervoor dat het wat
lastiger is om samen te werken met programmeurs die een andere tekstverwerker
gebruiken.
Daarom zie je vaak dat programmeurs hun tekstverwerker zo instellen dat een tab als
meerdere spaties wordt neergezet. Spaties worden altijd op dezelfde manier
geïnterpreteerd, waardoor er minder problemen ontstaan. Het enige waar je voor moet
zorgen is dat de andere programmeurs dit ook zo instellen. Deze manier van tabs wordt
‘soft tabs’ genoemd.

51 - Instappen in Ruby on Rails 3 - Robin Brouwer

Vaak zie je dat er vier spaties worden gebruikt voor een soft tab. In Ruby is echter de
conventie om met twee spaties te werken voor een soft tab. Vier spaties wordt als ‘te veel’
beschouwd en maakt de code ‘lelijker’. Tegenstanders zeggen dat code met twee spaties
juist slechter te lezen is. Conclusie? Beide kanten hebben een punt. Ik prefereer twee
spaties, omdat ik het er mooier uit vind zien en het door de meeste Ruby programmeurs
gebruikt wordt. Ik vind het niet lastiger om te lezen, maar dat is dus geheel persoonlijk. Ik
ben voor conventies en probeer mezelf er daarom ook zoveel mogelijk aan te houden.

if spaces == 4 || tabs == 1
puts "Fout"
elsif spaces == 2
puts "Goed"
end

3.13.3 Spaties, spaties en nog eens spaties
Ik heb hierboven uitgelegd waarom gewone tabs verboden zijn en waarom je spaties moet
gebruiken. Maar naast deze conventie is er nog een andere: waar moet je spaties stoppen
en waar niet? Deze conventie is bedoeld om de code netjes te houden en eenzelfde manier
van schrijven na te streven. Waar stop je de spaties in een Array, Hash of method? Geloof
het of niet: hier zijn regels voor.
# Arrays.
# Spaties na komma's. Geen spaties aan het begin en einde.
[ "Dit", "is", "fout" ]
["Dit","is","fout"]
["Dit", "is", "goed"]

Bij Arrays is het de bedoeling dat je geen spaties aan het begin en einde van de Array
stopt. Hiernaast is het belangrijk dat je spaties na elke komma plaatst. Het maakt je Arrays
net iets beter leesbaar.
# Hashes.
# Spaties aan het begin en einde. Ook na de dubbele punt en komma.
{correct:false}
{correct: false}
{ correct: true, with_comma: true }

Bij Hashes is het juist wel de bedoeling dat je een spatie aan het begin en einde stopt. Het
tegenovergestelde van de Array. Ook moet je na dubbele punten en komma’s een spatie
stoppen. Als je met de ‘Ruby 1.8 Hash rockets’ werkt, moet het als volgt:

52 - Instappen in Ruby on Rails 3 - Robin Brouwer

{ correct => true }

Een spatie voor én na het pijltje. Het maakt het lezen van de Hash een stuk gemakkelijker.

# Methods en method-calls.
# Spaties na komma's. Geen spaties aan het begin en einde.
def my_method(arg1, arg2, arg3)
end
my_method( "Dit", "is", "fout" )
my_method("Dit","is","fout")
my_method("Dit", "is", "goed")

Bij methods is het juist weer de bedoeling dat je geen spaties voor of na de haakjes stopt.
De haakjes moeten ook gelijk tegen de method-naam beginnen. Ook hier moet je spaties
na een komma stoppen. Dit is dus te vergelijken met hoe je een Array schrijft.

#bij comments is dit niet goed
# Bij comments is dit wel goed.

Ook is het belangrijk om op de juiste manier om te gaan met commentaar in je code. Na
elk hekje stop je altijd een spatie. Ook is het de bedoeling dat, als je een zin uitschrijft, deze
ook in correct Engels (of Nederlands in ons geval) uitschrijft. Dat betekent: hoofdletters
gebruiken, komma’s, punctuatie, grammatica, etc.
Deze conventie is vrij ‘mierenneukerig’, maar zorgt er wel voor dat de code er net iets
netter uitziet. Naast de voorbeelden hierboven zijn er genoeg andere regels wanneer je wel
en geen spaties moet gebruiken. Het is een kwestie van kijken wat er mooier uitziet. Zo
wil je bij een variabele declaratie een spatie voor én na het is-teken hebben. Ziet er gewoon
een stuk netter uit. Al is dat vaak behoorlijk subjectief.

3.13.4 Methods aanroepen
Dit is een vrij verwarrende conventie. Wanneer moet je haakjes gebruiken bij het
aanroepen van methods en wanneer niet? Helaas zijn er vrij tegenstrijdige conventies in de
Ruby en Rails communities. De Ruby community gebruikt zoveel mogelijk haakjes en de
Rails community juist zo min mogelijk. Maar wat moeten we dan doen? De Ruby of Rails
conventies naleven? Het antwoord is volgens mij: het hangt af van de situatie. Mijn collega
Joachim Nolten legt dit in een reactie op m’n Atom erg goed uit:

53 - Instappen in Ruby on Rails 3 - Robin Brouwer

Als de method geen parameters nodig heeft hoef je sowieso geen haakjes te gebruiken. Bij
een method met maar één parameter is het meestal ook niet nodig. Al vind ik het zelf
handig om dit wel te doen. Het maakt je code net iets netter. De methods waar ik sowieso
geen haakjes gebruik zijn ‘puts’ en ‘raise’. Dat zijn methods die je even snel voor een
variabele neerzet om het resultaat te bekijken. Als je daar ook haakjes neer gaat zetten, is
het alleen maar lastiger om het weer weg te halen.
En, zoals Joachim al liet zien, zijn er weer wat uitzonderingen in onder andere Rails,
waarbij method calls, met meerdere argumenten, geen haakjes nodig hebben. Ook zijn er
een aantal methods in Ruby die het niet nodig hebben. In dit boek zal ik in dat soort
gevallen daarom ook geen haakjes neerzetten.

# Rails methods
validates_confirmation_of :password, if: password?
has_many :products, through: :ordered_products
# Ruby methods
include MyModule
require "date"

Voor de rest stop ik bijna overal haakjes. Het zorgt ervoor dat je gemakkelijk methods
achter elkaar kunt aanroepen, zoals Joachim ook vertelde. Ook zorgt het ervoor dat je veel
makkelijker ‘methods in methods’ kunt aanroepen.

54 - Instappen in Ruby on Rails 3 - Robin Brouwer

# Niet goed en geeft een error. Ruby begrijpt het niet.
# Denk je dat een ander het dan wel zou begrijpen?
link_to image_tag "logo.png", root_url, class: active? root_url
# Zo hoort het.
link_to(image_tag("logo.png"), root_url, class: active?(root_url))

Ik vind het overigens heel belangrijk om bij een method declaratie (met parameters)
haakjes te gebruiken. Dit maakt het een stuk leesbaarder.

def my_method string
puts "Fout"
end
def my_method(string)
puts "Goed"
end

In dit boek zal ik me zoveel mogelijk aan deze conventie houden. Als je ergens methods
ziet met meerdere parameters waar geen haakjes worden gebruikt, is de kans groot dat het
een speciale Rails of Ruby method is. Probeer mijn haakjes-gedrag dus na te bootsen.
Zoals je ziet is deze conventie behoorlijk verwarrend. Wat je moet onthouden:
- Gebruik altijd haakjes als je een method declareert, tenzij het geen parameters krijgt.
- Gebruik geen haakjes als de method geen parameters nodig heeft.
- Gebruik voor de rest gewoon haakjes, tenzij het een speciale Rails of Ruby method is,
zoals hierboven aangegeven.
- Als je een method in een method nodig hebt óf je wilt methods ‘chainen’, dan moet je
sowieso haakjes gebruiken.

3.13.5 One-line en multi-line
Wanneer schrijf je iets op één regel en wanneer verspreid je het over meerdere regels? De
conventie is om maximaal 80 karakters per regel te hebben. Of je iets op één regel of
meerdere regels schrijft hangt dus af van hoeveel tekens het gaat worden.
Zoals je weet kun je if-statements en blocks op één regel uitschrijven. Hier een paar
voorbeelden:
style = index > 0 ? "display: none" : "display: block"
countries.map { |country| country.name }

55 - Instappen in Ruby on Rails 3 - Robin Brouwer

Zoals je ziet zijn deze twee voorbeelden vrij simpel en korter dan 80 karakters. Deze mag
je dus gerust op één regel stoppen. Als ze echter complexer worden is het tijd om het op te
splitsen. Liever vier regels met een klein aantal karakters per regel, dan één regel met
ontzettend veel karakters.

# Niet doen.
style = index > 0 ? (index > 2 ? "display: none" : "display: inline") :
"display: block"
# Beter.
style = "display: block"
if index > 0
style = index > 2 ? "display: none" : "display: inline"
end

Het is belangrijker dat het goed te lezen is, dan dat het op één regel past.
Een belangrijke conventie bij one-line en multi-line blocks is dat je one-line blocks met
accolades schrijft (zoals hierboven) en multi-line blocks met ‘do’ en ‘end’. Hier is echter
nog wel wat discussie over. Sommigen vinden namelijk dat ook multi-line blocks met
accolades geschreven moeten worden. Ik vind dat een beetje vreemd en totaal niet bij
Ruby horen, dus ik raad je aan om gewoon ‘do’ en ‘end’ te gebruiken.

# Blocks zoals het volgens mij niet hoort.
array.each { |row|
puts row
}
# Blocks zoals het volgens mij hoort.
array.each do |row|
puts row
end

3.13.6 De woorden ‘and’, ‘or’, ‘then’ en ‘for’
Er zijn een aantal woorden die je in Ruby eigenlijk moet vermijden of in een andere
situatie moet gebruiken. Ik heb je al uitgelegd dat je ‘each’ moet gebruiken in plaats van
‘for’ als je ergens doorheen loopt. Hiernaast zijn nog drie andere woorden die extra
aandacht verdienen.
‘and’ en ‘or’
Allereerst ‘and’ en ‘or’. Je zou denken: deze operators kunnen we mooi gebruiken in
plaats van && en || om de if-statements duidelijker te maken. Dit is echter niet waar ze
voor bedoeld zijn. Ze werken net iets anders, waardoor je behoorlijk in de war kan raken
56 - Instappen in Ruby on Rails 3 - Robin Brouwer

als je ze in if-statements stopt. De woorden ‘and’ en ‘or’ zijn zogenaamde ‘control ﬂow
operators’ en zijn niet bedoeld voor een if-statement. Gebruik ze dus nooit in die situatie.
Ze hebben een ander plekje in Ruby.

if (1+1 == 2 and 2+2 == 4) or 3*3 == 9
puts "Klopt niet."
end
if (1+1 == 2 && 2+2 == 4) || 3*3 == 9
puts "Klopt wel."
end

Maar wanneer kan je ‘and’ en ‘or’ dan wel gebruiken? Je gebruikt deze control ﬂow
operators meestal als je op één regel meerdere dingen voor elkaar wilt krijgen. De ‘and’
operator gebruik je meestal om Ruby code aan elkaar te koppelen als een soort ketting
(‘chaining’ in het Engels). Dit doe je totdat er ‘nil’ of ‘false’ wordt teruggeven.

post = Post.find_by_name(name) and post.publish!

Hier wordt een Post gezocht op naam en hierna gepubliceerd. Het wordt dus achter elkaar
uitgevoerd. Als er echter geen Post wordt gevonden (de method geeft nil of false terug) zal
de ‘chain’ worden onderbroken. Nog een voorbeeld:

students = 42 and students / 2

# => 21

Hier wordt de variabele ‘students’ eerst op 42 gezet en hierna gelijk door tweeën gedeeld.
Wat als we dit met && doen? Dan krijgen we een error. Als we namelijk ‘and’ met ‘&&’
vervangen gebeurt achter de schermen het volgende:

students = (42 && students) / 2

Dat gaat Ruby niet begrijpen. De ‘and’ operator is dus voor iets anders bedoeld dan de &&
operator. Onthoud dit goed en weet wanneer je ‘and’ of && moet gebruiken. De '&&'
operator wordt dus gebruikt in vergelijkingen, terwijl 'and' wordt gebruikt om code te
'chainen'.
De ‘or’ operator kun je op dezelfde manier gebruiken als de ‘and’ operator. Het verschil is
dat ‘or’ voor ‘of’ staat en dus net iets anders werkt.

57 - Instappen in Ruby on Rails 3 - Robin Brouwer

ready_to_rails? or raise "Almost ready!"

Als de ‘ready_to_rails?’ method ‘nil’ of ‘false’ teruggeeft zal hetgeen achter ‘or’ worden
uitgevoerd. De ‘or’ operator werkt dus als volgt: als dit niet lukt, probeer dan het
volgende. En dit kun je blijven doen, totdat er iets anders wordt teruggegeven dan nil of
false.
Nu je weet wat het verschil tussen ‘and’, ‘or’, && en || is zal je niet meer de fout maken
die zoveel andere beginnende Ruby programmeurs maken. Meer uitleg over ‘and’ en ‘or’
in Ruby kun je vinden op de link hieronder.
Using “and” and “or” in Ruby
http://avdi.org/devblog/2010/08/02/using-and-and-or-in-ruby/
(TinyURL: http://tinyurl.com/37q3s9u)
then
Je kunt bij een gewone if-statement het woord ‘then’ gebruiken om aan te geven dat er iets
moet gebeuren. Dit kun je zonder problemen weglaten, het gebruik hiervan is overbodig.
if 1+1 == 2 then
puts "Hoeft niet."
end
if 1+1 == 2
puts "Zonder then."
end

Meestal wordt ‘then’ gebruikt in one-line if-statements. Dit is echter erg onhandig, omdat
je alsnog ‘end’ erachter moet zetten. Er is hier een veel betere manier voor.
if 1+1 == 2 then puts "Niet doen." end
puts "Beter." if 1+1 == 2

Je geeft eerst op wat er moet gebeuren en daarna wanneer dit mag gebeuren. Probeer
‘then’ dus gewoon te vermijden.
for
En dan nogmaals: gebruik geen ‘for’, maar gebruik ‘each’.

58 - Instappen in Ruby on Rails 3 - Robin Brouwer

# Liever niet
for row in array { ... }
# Goed
array.each { |row| ... }

3.13.7 Zo min mogelijk herhaling
Ik heb je al het DRY principe van Rails uitgelegd: Don’t Repeat Yourself. Hetzelfde
principe geldt ook voor Ruby. Als je dubbele code typt, is het tijd om iets aan te passen.
Hier een voorbeeld:
# Twee keer hetzelfde.
x = ModuleA::ClassB::method_c(a)
y = ModuleA::ClassB::method_d(b)
# Een stuk beter.
ab = ModuleA::ClassB
x = ab::method_c(a)
y = ab::method_d(b)
# Ook mogelijk.
include ModuleA
x = ClassB::method_c(a)
y = ClassB::method_d(b)

Het voorbeeld hierboven kan je op nog een andere manier oplossen. Het is echter een
manier die door sommige Ruby-isten wordt gezien als ‘not done’. Het is toch handig om te
weten dat het kan.
include ModuleA
x, y = ClassB::method_c(a), ClassB::method_d(b)

Je kunt met een komma meerdere variabelen declareren op één regel. Volgens een aantal
van de Ruby conventie-lijsten moet je dit echter niet doen en maakt het je code alleen maar
minder leesbaar. Je moet volgens deze lijsten variabelen altijd op aparte regels declareren.
Ik zeg: gebruik het alleen als het aantal karakters op de regel erg weinig is, zoals
hierboven.

3.13.7 Dezelfde stijl in het document gebruiken
Een andere conventie is om dezelfde stijl te gebruiken als al in het document gebruikt
wordt. Als je samenwerkt met iemand is het handig om zoveel mogelijk dezelfde stijl te
gebruiken. Als iemand variabelen op een speciale manier declareert is het handig om dit
59 - Instappen in Ruby on Rails 3 - Robin Brouwer

ook te doen. Als iemand vier spaties heeft gebruikt voor een tab, moet je niet opeens twee
spaties gebruiken op een paar plekken. Zorg ervoor dat het niet een wirwar van stijlen van
programmeren wordt. Volg de conventies die al in het document gebruikt worden.
Er is echter een kanttekening te plaatsen. Als je met iemand samenwerkt die de Ruby
conventies gewoon niet naleeft is het tijd om de code op te schonen (‘refactoring’ in het
Engels). Dan moet diegene zich maar aanpassen aan jou.

3.13.8 Conclusie
Dat waren dan alle conventies die ik belangrijk vind. Bekijk de links die ik aan het begin
van dit gedeelte heb gegeven voor meer informatie. Probeer je zoveel mogelijk aan de
conventies te houden, zodat we met z’n allen ongeveer op dezelfde manier
programmeren. Het maakt het samenwerken des te beter.

3.14 Samenvatting
Dit was de basis van Ruby. Als het goed is kun je nu een simpele Class maken en
gebruikmaken van een aantal Classes die Ruby je biedt. Ga oefenen met wat je hebt
geleerd, spit de Ruby documentatie door en probeer eens een Class te maken met
meerdere methods die geordend zijn in verschillende Modules. Oefening baart kunst, dus
dat is precies wat je nu moet doen wil je goed worden in Ruby. Er is namelijk nog veel
meer te leren over Ruby. Als je meer wilt weten over Ruby kun je de documentatie
bekijken of het ‘Pickaxe’ boek lezen die over deze taal gaat. De taal is ook nog steeds in
ontwikkeling, dus er komen ook steeds nieuwe dingen bij die je kunt leren.
Hier nog een keer op een rijtje wat je allemaal hebt geleerd:
- Waarom Ruby wordt gebruikt voor Ruby on Rails;
- Wat je allemaal kunt doen met Strings, Numbers, Arrays en Hashes;
- Wat voor soorten variabelen er allemaal zijn;
- Hoe if/else statements werken in combinatie met Booleans;
- Wat voor soorten loops er zijn in Ruby;
- Wat je allemaal met tijd en datums kunt doen;
- Hoe je een Class en Module maakt;
- Wat Procedures zijn en hoe je deze kunt gebruiken;
- Wat de belangrijkste Ruby conventies zijn.

60 - Instappen in Ruby on Rails 3 - Robin Brouwer

4. Beginnen met Rails
Nu je de basis kent van Ruby is het tijd om te beginnen met Rails. In dit hoofdstuk ga je
een begin maken aan een simpele Rails applicatie. Je leert ook hoe je Controllers en
Models kunt maken en hoe je met de Ruby console kunt werken. Als je meteen in Rails
wilt stappen zonder iets te installeren raad ik je aan om een kijkje te nemen naar Rails for
Zombies: http://railsforzombies.org. Hierin leer je Ruby on Rails op een erg leuke
interactieve manier. Zeker een aanrader.

4.1 Installeren
Het eerste wat je moet doen is Rails installeren. Dit kan soms voor de nodige hoofdpijn
zorgen; vooral als je MySQL erbij wilt installeren. Maar wat installeer je dan precies? Het
eerste wat je moet zien te installeren is Ruby en RubyGems. Ruby is natuurlijk de
programmeertaal en spreekt voor zich. RubyGems is de standaard manier om Ruby
libraries te distribueren. Alle libraries die in Ruby zijn geschreven zijn te verkrijgen via dit
platform. Rails is ook een RubyGem (vaak afgekort als ‘gem’).
Omdat er zoveel verschillende manieren zijn om Rails te installeren en er zoveel
verschillende fouten kunnen voorkomen, zal ik niet een uitgebreide tutorial geven in dit
boek. Ik zal je wel een paar handige links geven om je verder op weg te helpen. Als je
bepaalde foutmeldingen tegen komt kun je het beste Google raadplegen. Er zijn vast
andere mensen die hetzelfde probleem hebben. Ik raad je wel aan om gelijk RVM (Ruby
Version Manager) te installeren. Dit maakt het gebruiken van meerdere Ruby versies erg
gemakkelijk.
RVM installeren op je Mac
http://45north.nl/atoms/posts/98-rvm-installeren-op-je-mac
(TinyURL: http://tinyurl.com/44tyjea)
How to install Ruby on a Mac
http://net.tutsplus.com/tutorials/ruby/how-to-install-ruby-on-a-mac/
(TinyURL: http://tinyurl.com/3f2tz9v)
Running Rails 3 on Windows
http://accidentaltechnologist.com/ruby-on-rails/running-rails-3-on-windows/
(TinyURL: http://tinyurl.com/3yq2zkj)

4.2 Nieuwe applicatie
Als alles is gelukt kun je verder gaan met het maken van een nieuwe Rails applicatie. Start
de terminal en ga naar de map waar je de applicatie wilt hebben. Op een Mac is dit
meestal de Sites map onder jouw gebruiker.

61 - Instappen in Ruby on Rails 3 - Robin Brouwer

cd ~/Sites

Voer dan het volgende uit:

rails new my_app

Nu zie je dat er een nieuwe map wordt aangemaakt en dat er een aantal bestanden in
worden gestopt. De database die wordt gebruikt voor jouw applicatie zal gebruikmaken
van SQLite3. Als je met bijvoorbeeld MySQL wilt werken moet je eerst de MySQL gem
installeren (de gem die gebruikt wordt voor Rails 3 is mysql2) en het volgende doen om de
standaard te overschrijven:

rails new my_app -d mysql

Nu zal MySQL gebruikt worden voor jouw applicatie. Het volgende wat je moet doen is
de gem installeren die je applicatie nodig heeft. Dit doe je door naar jouw applicatie te
gaan en een commando uit te voeren.

cd my_app
bundle install

Het installeren van alle gems kan een tijdje duren. Als je MySQL gebruikt zal de mysql2
gem nu ook worden geïnstalleerd.

In Rails 3.1 zal ‘bundle install’ automatisch worden uitgevoerd als je een nieuwe
applicatie aanmaakt. Je hoeft dus niet handmatig ‘bundle install’ uit te voeren.

Om dan de database aan te maken doe je het volgende:

rake db:create

Je moet er wel voor zorgen dat in /conﬁg/database.yml de juiste conﬁguratie voor je
database staat aangegeven. Als je een wachtwoord hebt ingesteld, dan moet je die hier
natuurlijk opgeven.
62 - Instappen in Ruby on Rails 3 - Robin Brouwer

Als je al een keer met Rails hebt gewerkt, dan valt je misschien op dat het aanmaken van
een Rails applicatie iets anders werkt. In plaats van alleen ‘rails’ doe je nu ‘rails new’. Niet
een grote verandering, maar als je het gewend bent om geen ‘new’ erna te zetten dan is het
natuurlijk handig om te weten dat dit nieuw is in Rails 3.

4.3 Mapstructuur
Als je al bekend bent met Rails dan zal het je opvallen dat de mapstructuur van een Rails 3
applicatie er net iets anders uitziet. Ik zal nu uitleggen wat voor bestanden en mappen er
allemaal zijn.
De eerste map die je ziet is de /app map. Dit is de map waar je het
meeste in zult werken. Hierin zitten namelijk alle Controllers, Models,
Views en Mailers. Als je de /app map opent zie je dat ook. In de /app/
controllers map zit een bestand genaamd application_controller.rb. Dit
is de Controller voor je gehele applicatie. Als je hier een method in
maakt kun je deze aanspreken in alle andere Controllers. Als je nu in
de /app/views map kijkt zie je al een ‘layouts’ map. Hierin komen alle
globale HTML templates voor je applicatie. Zoals je ziet is er al eentje
voor je hele applicatie aangemaakt: application.html.erb. Hierin zitten
de standaard <html>, <head> en <body> tags. Ook is er een speciale
tag met ‘yield’ erin. Hier in een later hoofdstuk meer over.
De volgende map in de Rails applicatie is de /conﬁg map. Zoals je
kunt verwachten wordt hier de conﬁguratie van je Rails applicatie
geregeld. Je hebt application.rb voor de globale conﬁguraties,
database.yml voor de conﬁguratie van je database, environment.rb voor het initialiseren
van je applicatie en routes.rb voor het regelen van de routing in je applicatie. Ook heb je
een environments map waarin je per environment (development, production en test)
dingen kunt instellen, een initializers map om scripts uit te voeren als je de applicatie start
en een locales map om alle statische teksten in kwijt te kunnen.
De volgende belangrijke map is de /db map. Hierin zit alles wat te maken heeft met je
database. Als je SQLite3 gebruikt komen hier de .sqlite3 bestanden te staan. In deze map
komt later ook een migrations map met alle migraties die je doet naar je database. Dit is
een soort versiebeheer voor je database. Hier later meer over. Ook is er een speciaal
seeds.rb bestand waarin je Ruby code kunt uitvoeren om bepaalde standaard-data in je
database te krijgen. Hier ook later meer over.
Het volgende bestand is de Gemﬁle. Hierin geef je aan welke gems je wilt gebruiken in je
applicatie. Als je een bepaalde gem wilt gebruiken in je applicatie, dan moet je deze hier
opgeven. Je kunt met de ‘bundle install’ command ervoor zorgen dat al deze gems worden
geïnstalleerd. In Gemﬁle.lock zie je alle gems staan die je applicatie gebruikt. Na een
bundle install wordt dit bestand vernieuwd.
63 - Instappen in Ruby on Rails 3 - Robin Brouwer

Na de Gemﬁle heb je de /lib map. Hierin kun je Ruby scripts, Classes of Modules stoppen
die je dan kunt gebruiken in de rest van je applicatie. Hierna komt de /log map met de
logbestanden voor de server.
De /public map is de map waar alle gebruikers toegang tot hebben. Er zit een standaard
index.html bestand in, een favicon.ico, robots.txt en een aantal error pagina’s. Ook heb je
een speciale map voor alle images, javascripts en stylesheets. Gelijk een gestructureerde
manier om te werken.

Sinds Rails 3.1 is de public map een stuk minder belangrijk geworden. Alle
stylesheets, javascripts en images zijn naar /app verplaatst. In /app zit nu namelijk
een ‘assets’ map. Deze bestanden worden automatisch naar de /public map
verplaatst. Dit is de ‘asset pipeline’ en behandel ik aan het einde van dit boek.
Het zorgt ervoor dat je nauwelijks uit /app hoeft te gaan.

Ook heb je nog een /script map met hierin een ‘rails’ bestand. Hiermee kun je gemakkelijk
Controllers, Models en Mailers aanmaken, de server starten en nog veel meer. Er is ook
nog een /test map voor het testen van je functionaliteiten en een /tmp map voor tijdelijke
bestanden. De laatste map is de /vendor map. Hierin komen alle plugins die je applicatie
gebruikt.

4.4 Scripts
Zoals ik al heb aangegeven is er een speciale /script map in je applicatie te vinden waarin
een bestand zit genaamd ‘rails’. Dit bestand gebruik je om allerlei dingen met je applicatie
te doen. Denk aan het genereren van bepaalde bestanden, het downloaden van plugins,
het starten van de server en nog veel meer. Dit doe je allemaal via de terminal.
Het eerste wat ik ga laten zien is de ‘generate’ functie. Hiermee kun je onder andere een
nieuwe Controller aanmaken. Ga in de terminal naar jouw Rails applicatie en voer het
volgende uit:

rails generate controller posts

Je spreekt het rails script aan met ‘rails’, geeft hierna aan dat je de generate functie wilt
gebruiken en dat je een Controller genaamd ‘posts’ wilt aanmaken. Denk erom dat een
Controller meestal (bijna altijd) in het meervoud moet worden geschreven. Dat is weer één
van die Rails conventies waar je je aan moet houden. Als je een Controller wilt maken
waarbij de naam uit meerdere woorden bestaat kun je liggende streepjes gebruiken om de
woorden te scheiden. Je kunt ook met CamelCases werken om dit voor elkaar te krijgen.
64 - Instappen in Ruby on Rails 3 - Robin Brouwer

rails generate controller PostComments

Je kunt dus ook ‘post_comments’ uitschrijven. Dit kun je geheel zelf bepalen. Ik vind het
prettiger om met liggende streepjes te werken.
Met de generate functie kun je nog een heleboel extra dingen doen. Hier een voorbeeld
hoe je een Model, Mailer en een migration kunt genereren:

rails generate model user
rails generate mailer user_mailer
rails generate migration add_type_to_users_table

Een Model moet je overigens altijd in het enkelvoud schrijven. Ik zal hier later wat dieper
op ingaan. Om bestanden te verwijderen kun je de ‘destroy’ functie gebruiken. Om de
hierboven gegenereerde bestanden te verwijderen, kun je het volgende uitvoeren:

rails
rails
rails
rails

destroy
destroy
destroy
destroy

controller posts
model user
mailer user_mailer
migration add_type_to_users_table

Je vervangt ‘generate’ met ‘destroy’.
Een andere functie die je kunt aanroepen is ‘plugin’. Je kunt hiermee bijvoorbeeld een
plugin installeren. Je doet dan het volgende:

rails plugin install git://github.com/RobinBrouwer/gritter.git

Je kunt dan de url naar bijvoorbeeld de git repository van een plugin opgeven. Dan wordt
de plugin automatisch gedownload en in de /vendor map gestopt. Een plugin is ongeveer
hetzelfde als een gem. Wat het verschil precies is zal ik in het laatste hoofdstuk uitleggen.
Als je hierna de server herstart kun je de plugin gebruiken in je applicatie. Maar hoe start
je dan eigenlijk de server? Daar heb je ook een functie voor genaamd ‘server’.
Deze functie werkt erg simpel. Je doet het volgende om de server te starten:

65 - Instappen in Ruby on Rails 3 - Robin Brouwer

rails server

De server wordt gestart en je kunt deze stoppen met ctrl+c (ook voor Mac). De standaard
poort voor een Rails applicatie is 3000. Als je naar http://localhost:3000 gaat kom je bij
jouw applicatie. Wil je bijvoorbeeld op poort 3001 je applicatie draaien, dan moet je de
poort meegeven aan de functie:

rails server -p 3001

Ook kun je de server in een daemon starten, zodat als je de terminal afsluit, je applicatie
nog steeds blijft draaien:

rails server -d

Je kunt er nog een heleboel extra dingen mee doen. Als je het volgende doet zie je wat je er
allemaal mee kunt doen:

rails server -h

Hetzelfde kun je ook doen met het rails script:

rails -h

De laatste functie die ik ga behandelen is de ‘console’. Je start hiermee een Ruby console
op voor jouw applicatie. Je kunt al jouw Models en methods benaderen in deze console,
waardoor je erg gemakkelijk bepaalde zaken kunt testen binnen de applicatie. Dit werkt
weer even simpel als het starten van de server:

rails console

De console wordt gestart en je kunt door ‘exit’ of ‘quit’ te typen weggaan. Zometeen ga ik
wat dieper in op de console.
In Rails 3 zitten overigens een aantal shortcuts voor een aantal functies die ik net heb
behandeld. Dit maakt het uitvoeren van de scripts iets sneller.
66 - Instappen in Ruby on Rails 3 - Robin Brouwer

rails s
rails c
rails g controller ...

De ‘s’ staat voor ‘server’, de ‘c’ voor ‘console’ en de ‘g’ voor ‘generate’. Scheelt weer een
paar letters. Let wel op dat dit niet bij elke functie kan. Zo zorgt de letter ‘d’ niet ervoor
dat de ‘destroy’ functie wordt uitgevoerd.

4.5 Environments
In Ruby on Rails zijn er drie verschillende soorten omgevingen: development, production
en test. De meeste tijd zul je doorbrengen in de development mode. Zoals het woord al
aangeeft is dit waarin je de applicatie daadwerkelijk bouwt. Caching wordt uitgezet, zodat
je dit niet steeds hoeft te legen in je browser of in je applicatie. De production omgeving
wordt gebruikt als de site live staat. Alles is iets sneller en het cachen staat standaard aan.
In de test omgeving kun je bepaalde automatische tests uitvoeren om te checken of je
applicatie nog wel werkt. Het testen van je applicatie is iets wat erg belangrijk is in Rails.
Je schrijft voordat je begint aan een bepaalde functionaliteit meestal een test uit waarin je
aangeeft wat er allemaal moet gebeuren. Hierna maak je deze functionaliteit en test je of
het allemaal goed werkt. Als alles goed is gegaan en je gaat naar de volgende
functionaliteit, dan moet je daar ook weer een test voor maken. Als je dan uiteindelijk een
stuk verder bent en je verandert per ongeluk iets waardoor een oude test niet meer werkt,
dan krijg je dat gelijk te zien als je de test draait. Zo kun je bepaalde bugs voor zijn.
Het testen in Ruby on Rails is eigenlijk al zo geavanceerd dat ik dit niet in het boek ga
uitleggen. Het is echt iets voor als je al een tijdje met Rails hebt gewerkt en weet hoe alles
in elkaar zit. Iets te geavanceerd voor nu. Als je echter geïnteresseerd bent raad ik je aan
om een kijkje te nemen naar de gems ‘cucumber’ en ‘rspec’. Dit zijn veelgebruikte gems
om geautomatiseerde tests uit te schrijven in Rails.

4.6 Console
Ik heb je net laten zien hoe je de console kunt starten. De console is een erg handige
manier om even snel iets te testen in je applicatie.

4.6.1 Werken in omgevingen
Je kunt de console starten in één van de verschillende omgevingen. Je zet na ‘console’ neer
welke omgeving je wilt gebruiken.

67 - Instappen in Ruby on Rails 3 - Robin Brouwer

rails c development
rails c production
rails c test

Als je de omgeving niet opgeeft, dan gebruikt hij de standaard omgeving van je applicatie.
Dit is de development omgeving. Deze standaard kun je overigens ook weer aanpassen.
Maar wat is dan het verschil als je een andere omgeving gebruikt voor de console? Het
grootste verschil is dat er een andere database wordt gebruikt. Per omgeving is er namelijk
een andere database die je kunt gebruiken. Zo hebben we my_app_development voor de
development omgeving en my_app_production voor de production omgeving. Wij
hebben alleen de development database gemaakt voor onze applicatie. Om alle databases
aan te maken doe je het volgende:

rake db:create:all

Nu worden alle databases voor je applicatie gemaakt. Als je ‘:all’ weglaat wordt alleen de
database voor de huidige omgeving aangemaakt.
Een ander extra ding wat je met de console kunt doen is het starten van de sandbox mode.
Als je dan iets in de database verandert gebeurt er in werkelijkheid niks. Je kunt doen wat
je wilt zonder enige consequenties. Je start het als volgt op:

rails c -s

4.6.2 Werken met de console
Ik zal nu laten zien wat je zoal met de console kunt doen. Ik zal wat dingen laten zien die
ik later pas ga behandelen, dus als je het niet begrijpt: raak niet in paniek. Je zult het na het
volgende hoofdstuk allemaal begrijpen. Je hoeft ook niet mee te typen bij dit gedeelte.
Bij mijn kleine voorbeeld maak ik gebruik van een Post model. Deze communiceert met
een tabel in de database genaamd ‘posts’. In deze tabel zitten drie kolommen: id, title en
body. Om een nieuwe Post te maken kan je dan het volgende doen:
p = Post.new
p.title = "Hello World!"
p.body = "Dit is mijn allereerste post!"
p.save

68 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je maakt als eerste een instantie van de Post model en stopt deze in de lokale variabele ‘p’.
Je kunt dan de titel van de post aanpassen door ‘p.title’ aan te spreken. Hetzelfde kun je
weer doen met de body. Hierna spreek je de ‘save’ method aan om de post op te slaan in
de database. Nu krijgt de post een id met de waarde 1. Als je dan in je database kijkt zie je
dat er een nieuwe rij in de posts tabel zit. Nergens is SQL te bekennen. Gemakkelijk toch?
Je kunt in de console ook gegevens opzoeken. Als we de post willen opzoeken die we
toenet hebben aangemaakt kun je het volgende doen:

p = Post.find(1)
p.title = "Hello World 2!"
p.save

Nu zoeken we eerst de post op, veranderen we de titel en slaan we de veranderingen op.
Rails maakt automatisch de SQL queries voor ons. Je hoeft niet SQL uit te schrijven.

In Rails 3.1 krijg je ook gelijk de genereerde SQL queries in de console te zien. Elke
keer als je iets opslaat of ophaalt in de console krijg je te zien wat er achter de
schermen gebeurt. Erg handig als je aan het debuggen bent.

Misschien lijkt het bovenstaande een beetje omslachtig. Je wilt immers slechts één kolom
aanpassen. Je hebt een speciale method om dit wat gemakkelijker te maken:
p.update_attribute(:title, "Hello World 3!")

Dit doet precies hetzelfde, maar is één regel in plaats van twee. Wil je het nu verwijderen
uit de database, dan kun je destroy aanroepen:
p.destroy

Nu wordt een DELETE query uitgevoerd en is de rij verwijderd uit de tabel. Lekker
simpel.
Als je meerdere gegevens uit een tabel wilt halen kan dat natuurlijk ook. Je hebt hier de
zogenaamde ‘all’ method voor:

69 - Instappen in Ruby on Rails 3 - Robin Brouwer

posts = Post.all

Je haalt nu alle posts uit de tabel op en stopt deze in de lokale variabele ‘posts’. Je zou hier
nu doorheen kunnen loopen (het is namelijk een Array) en per iteratie iets doen met de
data.
Je kunt de SQL query die wordt gemaakt ook een beetje beïnvloeden. Je gebruikt hiervoor
zogenaamde scopes. Hier een simpel voorbeeld:

hello_world = "Hello World!"
posts = Post.where("title = ?", hello_world).order("title ASC")

Je kunt heel gemakkelijk een WHERE en ORDER clausule toevoegen aan de query. Deze
query wordt overigens pas uitgevoerd als je de ‘all’ method aanroept of erdoorheen gaat
loopen met bijvoorbeeld ‘each’. Naast deze twee scopes zijn er een aantal andere scopes
waarmee je een complexere query kunt maken. Hier later meer over.
Dat was dan een kleine vooruitblik op wat je zoal kunt doen in de console. Ik zal in het
volgende hoofdstuk wat dieper ingaan op dingen als ﬁnd, save, update_attribute en
destroy. Dus als je het nog niet begrijpt: geen paniek, het komt allemaal goed.

4.7 Samenvatting
Je hebt in dit hoofdstuk een begin gemaakt aan Rails. Je hebt het geïnstalleerd, geleerd hoe
je scripts kunt uitvoeren en hebt een beetje zitten spelen met de console. Je bent nu klaar
voor het echte werk. We gaan namelijk beginnen met de MVC structuur en beginnen bij de
M: de Model.
Hier nog een keer op een rijtje wat je allemaal hebt geleerd:
- Je hebt een paar handige links gekregen om Rails te installeren;
- Je weet hoe je een nieuwe Rails applicatie kunt aanmaken;
- Je begrijpt de mapstructuur van een Rails applicatie;
- Je weet wat voor Rails scripts er allemaal zijn en hoe je deze kunt uitvoeren;
- Je begrijpt wat voor soort omgevingen er zijn voor een Rails applicatie;
- Je hebt geoefend met de Rails console.

70 - Instappen in Ruby on Rails 3 - Robin Brouwer

5. Model
Nu je Ruby kent en weet hoe je een Rails applicatie kunt aanmaken is het tijd voor het
echte werk. En dat echte werk begint met de M in MVC: de Model. De Model gebruik je
om data in de database te manipuleren. Je kunt data opslaan, ophalen, aanpassen en
verwijderen. Hoe dit ongeveer werkt heb ik aan het einde van het vorige hoofdstuk even
snel laten zien. In dit hoofdstuk ga ik wat dieper in op deze zaken en laat ik nog een
heleboel extra dingen zien. Denk aan migrations, seeds, validatie, callbacks en relaties. Na
dit hoofdstuk begrijp je de basis van de M in MVC en ben je een grote stap verder om
zelfstandig een Rails applicatie te maken.

5.1 Naamgeving conventies
Voordat we beginnen met het genereren van een Model moet je eerst weten wat de
naamgeving conventies zijn van een Model.
- Een Model is altijd in het enkelvoud geschreven.
- De naam van een Model is altijd met CamelCases geschreven.
- De corresponderende tabel van een Model is altijd het meervoud van de Model-naam.
- De tabel is altijd met kleine letters geschreven met liggende streepjes voor witruimte.
- De kolommen van een tabel zijn altijd met kleine letters geschreven met liggend streepjes
voor witruimte.
- De primary key is meestal het ID veld en is altijd geschreven als ‘id’.
- Een foreign key is altijd het enkelvoud van de gekoppelde tabel met hierna _id.
- Als je een datum gebruikt als datatype voor een kolom, is het vaak gebruikelijk om _on
of _at erna te zetten. Je doet _on als het alleen een datum is en _at als het ook een tijd
heeft.
- De methods in een Model zijn altijd met kleine letters en liggende streepjes geschreven.
Je kunt overigens wel een uitroep-, vraag- of is-teken aan het einde zetten.
Knoop deze conventies goed in je achterhoofd!

5.2 Genereren van een Model
In het vorige hoofdstuk heb je gezien hoe je een Model kunt genereren. Wat ik niet
helemaal heb uitgelegd is wat er nou precies gebeurt. Voer het volgende uit in de terminal
(in de root van de applicatie natuurlijk):
rails g model post

Je ziet het volgende verschijnen in de terminal:

71 - Instappen in Ruby on Rails 3 - Robin Brouwer

invoke	
create	
create	
invoke	
create	
create	

active_record
db/migrate/20101206141346_create_posts.rb
app/models/post.rb
test_unit
test/unit/post_test.rb
test/fixtures/posts.yml

Als eerste zie je ‘invoke active_record’ staan. ActiveRecord is de class die wordt gebruikt
voor een Model. Vandaar ook dat ‘active_record’ aangeroepen wordt. Er wordt ook een
bestand aangemaakt (met een heleboel cijfers erin) in /db/migrate. Dit is een migration
bestand en is een soort versie-beheer van de database van jouw applicatie. Hier zometeen
meer over. Het tweede bestand is de Model en deze wordt in /app/models gestopt. De
andere bestanden zijn testbestanden die je nodig hebt om bepaalde functionaliteiten te
testen. Hier ga ik niet verder op in.
Je kunt ook gelijk bij het generen van een Model een aantal kolommen in het migration
bestand stoppen. Dit werkt als volgt:

rails g model post title:string body:text

Je geeft na de naam van de Model de kolomnaam op, gevolgd door een dubbelpunt en het
datatype. Je kunt meerdere kolommen toevoegen door deze te scheiden met een spatie.

5.3 Migrations
Een migration bestand is een bestand wat uitgevoerd wordt om je database aan te passen.
Je maakt tabellen aan, maakt indien nodig extra kolommen voor deze tabellen, verwijdert
bepaalde dingen, voegt indexes toe en past misschien hier en daar iets aan. Elke keer als je
iets aan wilt passen aan de database moet je een nieuw migration bestand genereren en
uitvoeren. Uiteindelijk heb je meerdere migration bestanden die ieder je database een klein
beetje veranderen. Je krijgt een soort van versie-beheer van jouw database. Elk bestand is
een kleine bouwsteen.

5.3.1 Migration bestand
Elke keer als je een nieuwe Model aanmaakt wordt er een speciaal migration bestand
aangemaakt. De reeks met cijfers in de bestandsnaam is een timestamp. Het geeft aan
wanneer dit bestand is aangemaakt en wat de ‘versie’ van je database is als je dit bestand
hebt uitgevoerd. Na de timestamp zie je een omschrijving van wat het migration bestand
precies doet. Dit migration bestand is om de tabel posts aan te maken (create_posts). Als je
dit bestand opent zie je het volgende:

72 - Instappen in Ruby on Rails 3 - Robin Brouwer

class CreatePosts < ActiveRecord::Migration
def self.up
create_table :posts do |t|
t.timestamps
end
end
def self.down
drop_table :posts
end
end

Er is een speciale Class aangemaakt die alles erft van ActiveRecord::Migration. Er zitten
twee class methods in: up en down. In de ‘up’ method komt Ruby code om je database te
updaten en in de ‘down’ method om je database - je raad je het al - te downgraden. Er
wordt een functie genaamd ‘create_table’ aangeroepen in de ‘up’ method en een
‘drop_table’ functie in de ‘down’ method. Als je een versie omhoog gaat, dan wordt de
tabel ‘posts’ gemaakt en als je een versie omlaag gaat dan wordt deze tabel verwijderd.

In Rails 3.1 heb je geen ‘up’ en ‘down’ methods meer. Deze zijn vervangen voor
een ‘change’ method. Hierin schrijf je alleen hetgeen wat er moet gebeuren als de
database in versie omhoog gaat. De ‘down’ versie ervan wordt automatisch
gegenereerd. Je kunt nog wel gewoon de ‘down’ en ‘up’ syntax gebruiken. Het is
dus niet zo dat dit opeens niet meer werkt. Verschil is dat je geen ‘self’ hiervoor
hoeft te zetten. Het zijn instance methods geworden.

Zo zit de versie-beheer van de database in elkaar. Je gaat een versie omhoog of omlaag. In
de database zit een speciale tabel genaamd ‘schema_migrations’ waarin wordt onthouden
welke migrations van de database allemaal zijn uitgevoerd. Als er een aantal nieuwe
migration bestanden zijn, dan wordt de ‘up’ method van elke migration op chronologische
volgorde uitgevoerd en wordt dit opgeslagen in de schema_migrations tabel. Maar wat
kan je nou precies doen in zo’n migration bestand?
Laat ik daarom maar beginnen met de create_posts migration die we toenet hebben
aangemaakt. Eerst de ‘up’ method:

create_table :posts do |t|
t.timestamps
end

73 - Instappen in Ruby on Rails 3 - Robin Brouwer

De tabel ‘posts’ wordt gemaakt en er worden drie kolommen ingestopt.

posts:
id
created_at
updated_at

De id is de Primary Key van de tabel en telt automatisch op naarmate er meer in de tabel
komt (auto_increment). De ‘t.timestamps’ functie zorgt ervoor dat de twee andere
kolommen worden aangemaakt. Deze twee kolommen zijn een standaard binnen Rails en
worden automatisch gevuld met een timestamp als er een rij wordt opgeslagen in de tabel.
Dus als er een nieuwe post wordt aangemaakt zal de ‘created_at’ kolom worden gevuld
met de tijd waarop dit is gebeurd. Als deze post later wordt aangepast zal de ‘updated_at’
kolom de juiste timestamp meekrijgen. Deze timestamps hebben een datum en een tijd.
Als je alleen een datum wilt hebben kun je het volgende doen:

create_table :posts do |t|
t.date :created_on
t.date :updated_on
end

Je verandert ‘at’ in ‘on’ (denk aan de naamgeving conventie) en zorgt ervoor dat het als
datatype DATE moet hebben. Meestal is de standaard timestamps functie goed genoeg.
Het is natuurlijk handig om te weten wanneer iets precies is aangemaakt of aangepast.
Om een extra kolom toe te voegen aan de tabel moet je de lokale variabele ‘t’ aanspreken
en hierop aanroepen wat voor soort kolom het moet zijn. Hierna geef je op wat de naam
van deze kolom is en daarna kan je allerlei extra opties meesturen, zoals een
standaardwaarde en limiet.

create_table :posts do |t|
t.string 	
:title, limit: 100
t.text 	
:body
t.timestamps
end

Als je aangeeft dat het een string moet worden, dan zal het een VARCHAR worden in de
database. Bij text wordt dit TEXT. Hiernaast zijn er een aantal andere datatypes, zoals
boolean, integer, decimal, ﬂoat, date en datetime. Naast de :limit die hier is opgegeven kun
je ook :null en :default meegeven. Hier een klein voorbeeld:

74 - Instappen in Ruby on Rails 3 - Robin Brouwer

create_table :posts do |t|
t.string 	
:title, limit: 100, default: "Hello World!"
t.text 	
:body, null: false
t.timestamps
end

Je kunt aan het rails script om een Model te genereren extra opties meegeven. Je kunt op
deze manier het migration bestand meteen vullen:

rails g model post title:string body:text

Nu wordt het migration bestand gevuld met een ‘title’ en ‘body’ kolom.

5.3.2 Migration methods
Het is vrij simpel om een tabel in Rails aan te maken. Als je iets wilt doen met een
bestaande tabel kan dit ook erg gemakkelijk. Je hebt de volgende functies die je kunt
aanroepen in een migration bestand.
create_table
change_table
drop_table
add_column
change_column
rename_column
remove_column
add_index
remove_index

De benaming van deze functies spreekt voor zich. De create_table en drop_table functies
heb je al gezien. Laten we eerst de change_table functie behandelen:
change_table :posts do |t|
t.remove 	
:updated_at
t.boolean	
:published
t.rename 	
:created_at, :created_on
t.index 	
:title
end

De change_table functie werkt ongeveer hetzelfde als de create_table functie. Het grote
verschil is dat je de methods remove, rename, change en index hebt om de tabel aan te
75 - Instappen in Ruby on Rails 3 - Robin Brouwer

passen. Ook kun je gemakkelijk extra kolommen toevoegen aan de tabel. Dit werkt dan
hetzelfde als bij de create_table functie. Handig als je veel verschillende veranderingen
moet uitvoeren op een tabel.
Dan nu de overige functies:

add_column 	
:posts,
change_column 	:posts,
rename_column 	:posts,
remove_column 	:posts,
add_index 	
:posts,
remove_index 	 :posts,

:published, :boolean, default: false
:published, :boolean, default: true
:published, :publish
:publish
:title
:title

De add_column functie voegt een nieuwe kolom toe. Je geeft eerst de naam van de tabel,
hierna de naam van de kolom, gevolgd door het datatype. Hierna kun je
weer :default, :limit of :null meegeven. De change_column werkt hetzelfde, alleen heb je
nu een bestaande kolom nodig. De rename_column werkt ook ongeveer hetzelfde. In
plaats van het meegeven van een datatype moet je de nieuwe naam opgeven. In het
voorbeeld veranderen we de naam van ‘published’ naar ‘publish’.
De remove_column functie heeft alleen twee parameters nodig: de naam van de tabel en
de naam van de kolom. Hetzelfde geldt voor het aanmaken van een index (add_index) en
het verwijderen van een index (remove_index). Je kunt wel extra dingen meesturen naar
de add_index en remove_index functies. Zo kun je op de volgende manier een index
plaatsen op twee kolommen:

add_index :posts, [:user_id, :title]

Als je nu een heleboel posts hebt en een query uitvoert waarbij je zoekt op user_id en title,
dan zal deze index gebruikt worden. De resultaten zullen dan sneller worden gevonden.

5.3.3 Migration bestand aanmaken
Je kunt naast het migration bestand die wordt gegenereerd bij een Model ook een
individueel migration bestand aanmaken. Dit doe je weer met een rails script.
rails g migration add_publish_to_posts

Nu wordt er een nieuw bestand gemaakt met deze naam. Het is belangrijk dat je de naam
zo omschrijvend mogelijk maakt. Zo weet je hier meteen dat we een kolom toevoegen aan
de posts tabel. Wat we hier dan instoppen is het volgende:
76 - Instappen in Ruby on Rails 3 - Robin Brouwer

class AddPublishToPosts < ActiveRecord::Migration
def self.up
add_column :posts, :publish, :boolean, default: false
end
def self.down
remove_column :posts, :publish
end
end

In de ‘up’ method gebruiken we add_column om een nieuwe kolom toe te voegen. In de
‘down’ method moeten we altijd precies het omgekeerde doen en dat doen we hier ook
met remove_column. Denk daar aan als je een migration bestand aanmaakt. Hier een
aantal simpele vuistregels voor het gebruiken van migrations:
1) Als je iets aan de database wilt veranderen moet je een nieuw migration bestand
aanmaken;
2) Geef het migration bestand altijd een omschrijvende naam;
3) Stop in de ‘down’ method altijd het omgekeerde van wat er in de ‘up’ method gebeurt.

5.3.4 Migration uitvoeren
Nu je weet hoe je migration bestanden kunt aanmaken is het misschien handig om te
weten hoe je deze kunt uitvoeren. Dit is gelukkig ook niet zo lastig. Voer het volgende uit
in de terminal:
rake db:create
rake db:migrate

Je moet er eerst voor zorgen dat de database bestaat (create) en hierna kun je alle
migration bestanden uitvoeren (migrate). Alle bestanden worden in chronologische
volgorde uitgevoerd en de huidige versie wordt in de ‘schema_migrations’ tabel
onthouden. Ook komt er een ‘schema.rb’ bestand in /db met alle tabellen en kolommen
die in de database zitten.
Om een versie terug te gaan in de database kun je twee dingen doen. Je kunt het
versienummer opgeven of aangeven hoeveel stappen je terug wilt. Het versienummer is
de timestamp die bij het migration bestand zit. Als je dit opgeeft ga je automatisch naar
deze versie van de database.

77 - Instappen in Ruby on Rails 3 - Robin Brouwer

rake db:migrate VERSION=20101206141346

Nu gaat hij terug naar deze versie en worden alle ‘down’ methods uitgevoerd van alle
bestanden die na deze datum zijn aangemaakt. Daarom is het belangrijk om de ‘down’
method in te vullen als je een migration bestand aanmaakt.
Om helemaal terug te gaan naar een lege database kun je het volgende doen:

rake db:migrate VERSION=0

Dan worden alle ‘down’ methods uitgevoerd.
Je kunt ook in stappen teruggaan. Dit doe je met ‘rollback’:

rake db:rollback

Nu ga je één stap terug in de database. Als je per ongeluk een migratie hebt gedaan kun je
dit weer snel terugdraaien met deze functie. Om meerdere stappen terug te gaan kun je
het aantal stappen meegeven:

rake db:rollback STEP=2

Nu gaat hij twee stappen achteruit. Als je meer over migrations wilt lezen kun je de Rails
guide bekijken.
Rails Database Migrations
http://guides.rubyonrails.org/migrations.html
(TinyURL: http://tinyurl.com/5dkoq3)

5.4 Seeds
Naast het aanpassen van de tabellen en de kolommen wil je ook af en toe standaarddata in
je database stoppen. Dit kun je doen met zogenaamde ‘seeds’. Je hebt in de /db map een
bestand genaamd ‘seeds.rb’. Hierin kun je Ruby code stoppen om data in je database te
stoppen. We zouden bijvoorbeeld een standaard post in de database kunnen stoppen:

78 - Instappen in Ruby on Rails 3 - Robin Brouwer

Post.create(title: "Hello World")

We maken gelijk een post aan door in plaats van de ‘new’ method de ‘create’ method aan
te roepen. Hier kunnen we dan meegeven wat we in de rij willen stoppen. Dit is precies
hetzelfde als het volgende:

p = Post.new
p.title = "Hello World"
p.save

Dit kun je overigens weer afkorten naar het volgende:

p = Post.new(title: "Hello World")
p.save

Je kunt net als bij create ook hier gelijk opgeven wat in de rij moet komen. Je hoeft niet per
se ‘p.title’ aan te spreken.
Om dit dan in de database te stoppen moet je het seeds bestand uitvoeren:

rake db:seed

De data wordt nu in de database gestopt. Er gebeurt niks speciaals. Er wordt niet gekeken
of de data er al inzit of iets dergelijks. Elke keer als je de seed uitvoert wordt de data er
nog een keer ingestopt. Als je dus een foutje had gemaakt bij de seed data, moet je dat op
een omslachtige manier oplossen. Dat is ook gelijk een punt van kritiek die ik heb op de
seeds implementatie van Rails. Ze hadden hier beter een soort versiebeheer zoals bij de
migrations moeten doen. Nu moet je namelijk eerst checken of iets al in de database zit.
Niet erg handig. Gelukkig zijn er genoeg anderen die hetzelfde probleem hadden en gems
en plugins hiervoor hebben gemaakt. Kijk vooral even naar seed_fu. Dit is een handige
gem die het seeden behoorlijk goed heeft geregeld.

5.5 Data manipuleren
In het vorige hoofdstuk heb ik even snel laten zien wat je kunt doen met de console. Nu je
weer een stuk meer weet over migrations is het tijd om wat dieper in te gaan op hoe je
data manipuleert met een Model.

79 - Instappen in Ruby on Rails 3 - Robin Brouwer

5.5.1 Nieuwe instantie aanmaken
Elke instantie die je van een Model maakt staat voor één rij in de corresponderende tabel.
Als je een Post model hebt wordt automatisch gezocht naar de tabel ‘posts’. Dat is weer
zo’n Rails conventie waar je je aan moet houden. De naam van de Model is altijd in het
enkelvoud en de tabel is altijd het meervoud hiervan. Rails doet dit overigens automatisch
als je een Model genereert. Je zag dit al gebeuren bij het Post model voorbeeld. Er wordt
een migration bestand aangemaakt genaamd ‘create_posts’. En ‘posts’ is natuurlijk het
meervoud van ‘post’.
Als je de Post model aanspreekt weet Rails automatisch dat hij naar de posts tabel moet
gaan. Je kunt een nieuwe rij aanmaken of één of meerdere rijen zoeken in de tabel. Het
zoeken van rijen kan op verschillende manieren. Nadat je een rij hebt gezocht kan je de
gegevens veranderen, verwijderen of gewoon zo laten. Het aanmaken van een nieuwe rij
werkt als volgt.
post = Post.new

Je maakt als eerste een nieuwe instantie van de Post model door de ‘new’ method aan te
roepen. Deze stop je dan in een variabele (in dit geval een lokale variabele). Je kunt hierna
de kolommen invullen. Elke kolom kun je heel simpel aanspreken:
post.title = "Hello World"

Je roept de ‘title’ aan en geeft aan welke String erin moet komen. Dit moet dezelfde naam
zijn als de kolom die je hebt gemaakt voor de tabel en je moet hetzelfde datatype erin
stoppen. De titel is een VARCHAR en dus kun je een String meegeven. Bij de timestamps
(created_at en updated_at) moet je ook echt een Time of DateTime object meegeven.

5.5.2 Opslaan
Om dan de nieuwe post in de tabel te stoppen roep je de ‘save’ method aan.

post.save

Er wordt een INSERT INTO query uitgevoerd met alle data die je in de Model hebt
gestopt. Zoals ik al eerder heb aangegeven kan je aan de ‘new’ method gelijk parameters
meegeven en is er een ‘create’ method die ook gelijk de save method uitvoert.
Als je de save method uitvoert krijg je overigens een Boolean terug. Als het is gelukt, dan
krijg je true terug en als het is mislukt krijg je false. Je kunt hierdoor een mooie ifstatement eromheen hangen om fouten op te vangen:
80 - Instappen in Ruby on Rails 3 - Robin Brouwer

if post.save
# Code voor als het is gelukt
else
# Code voor als het is mislukt
end

Hier ga ik in het Controller gedeelte dieper op in. Voor nu weet je hoe je gemakkelijk iets
via de Model in de database kunt stoppen. De volgende stap is hoe je het eruit kunt halen.

5.5.3 Opzoeken
De eerste manier om iets uit de database te halen is de ‘ﬁnd’ method. Hiermee kun je één
rij uit de database halen. Je kunt alleen op een id zoeken. In Rails 2.3 werd de ﬁnd method
overal voor gebruikt. Je kon ermee zoeken naar meerdere rijen en allerlei condities
meegeven. In Rails 3 is de ﬁnd method alleen voor het zoeken naar één rij en kun je alleen
een id meegeven als parameter.
post = Post.find(2)

Nu zoek je naar de post met als id het getal 2. Je krijgt één rij terug en deze wordt in de
lokale variabele ‘post’ gestopt. Om dan de titel eruit te halen doe je hetzelfde als wat we
hierboven hebben gedaan.
post.title 	
post.body	

# => Geeft de titel
# => Geeft de body

Op deze manier kun je uiteindelijk aan de gebruiker laten zien wat er in de database staat.
Hier ga ik dieper op in in het View gedeelte. Eerst is het misschien handig om te weten
wat je allemaal kunt doen met één rij. In eerste instantie kun je er niks mee doen. Je haalt
alleen de data op en doet er voor de rest niks mee. Denk bijvoorbeeld aan een pagina waar
je een bericht op een blog krijgt te zien. Dit is in feite één post die je ophaalt uit de
database en waar je voor de rest niks mee doet. Je laat alleen de opgehaalde data aan de
gebruiker zien.

5.5.4 Aanpassen
Maar wat kun je er dan wél mee doen? Je kunt een rij verwijderen of aanpassen. Je
gebruikt dan een UPDATE of DELETE query. In Rails werkt dit vrij simpel. Als eerste het
updaten:

81 - Instappen in Ruby on Rails 3 - Robin Brouwer

post.update_attribute(:publish, true)

Nu updaten we de publish kolom en zetten we de waarde op true. Wat hier gebeurt is het
volgende:

post.publish = true
post.save

De update_attribute method is om één kolom aan te passen en een afkorting voor wat
hierboven gebeurt. Maar wat als je meerdere kolommen wilt aanpassen? Dan heb je
update_attributes; het meervoud.

post.update_attributes(publish: true, title: "Gepubliceerd!")

Je geeft eigenlijk een Hash mee aan deze method. Net zoals je kunt doen met de new en
create methods. Hier gebeurt dan weer het volgende:

post.publish = true
post.title = "Gepubliceerd!"
post.save

De update_attributes method gebruik je om meerdere kolommen in één keer aan te
passen.

5.5.5 Verwijderen
Naast het aanpassen van de rij kun je ook de rij uit de tabel verwijderen. Hiervoor heb je
de ‘destroy’ method.
post.destroy

Je hoeft niks mee te geven aan deze method. De rij wordt verwijderd. Naast de destroy
method heb je ook een delete method.
post.delete

82 - Instappen in Ruby on Rails 3 - Robin Brouwer

Het verschil tussen destroy en delete is dat bij delete gelijk een SQL query wordt
uitgevoerd om de rij te verwijderen. De destroy method voert eerst nog wat extra dingen
in Rails uit voordat de query wordt uitgevoerd. Zo kun je bijvoorbeeld in de Model
opgeven dat er iets moet gebeuren voordat iets wordt verwijderd. Dit is een zogenaamde
callback en ga ik verderop in dit hoofdstuk behandelen. Het is daarom ook aan te raden
om de destroy method te gebruiken. Je wilt namelijk dat die callback gewoon wordt
uitgevoerd.

5.5.6 Scopes
In Rails 3 is de ﬁnd method alleen te gebruiken om één rij te zoeken. Maar hoe krijg je dan
meerdere rijen? In Rails 3 moet je zogenaamde scopes gebruiken om meerdere rijen te
zoeken. Ook als je slechts één rij wilt hebben, maar bijvoorbeeld een WHERE clausule wilt
toevoegen, dan moet je scopes gebruiken. Dit werk behoorlijk simpel en is eigenlijk een
stuk logischer dan de oude methode. Voor degenen die nooit met Rails 2.3 hebben gewerkt
is het misschien handig om te zien hoe het vroeger ging. Hier een klein voorbeeld met
Ruby 1.8 code:
posts = Post.find(:all, :conditions => "publish = true",
	 	
	
:order => "id DESC")

Je geeft :all mee als parameter aan de ﬁnd method. Hierna kun je bijvoorbeeld :conditions
en :order meegeven om de SQL verder te deﬁniëren. Ook zie je dat de oude Hash syntax
wordt gebruikt. Nu de nieuwe manier:
posts = Post.where("publish = true").order("id DESC")

Je gebruikt scopes om een query op te bouwen. Het handige hieraan is dat de query nog
niet wordt uitgevoerd. Deze wordt pas uitgevoerd als je de ‘all’ method uitvoert of
erdoorheen gaat loopen. Hierdoor kan je meerdere queries maken en deze pas uitvoeren
wanneer ze echt nodig zijn.
posts = Post.order("id DESC")
published = posts.where("publish = true")
drafts = posts.where("publish = false")

Nu wordt er geen query uitgevoerd, maar hebben we drie variabelen met een speciaal
object waarin de query is opgeslagen. Als we nu de all method aanroepen op één van deze
variabelen, of erdoorheen loopen, wordt de query uitgevoerd. Dit wordt ‘lazy loading’
genoemd en zorgt voor een stuk minder queries. In Rails 2.3 werd elke keer als de ﬁnd
method werd aangeroepen een query uitgevoerd. Niet echt handig.
83 - Instappen in Ruby on Rails 3 - Robin Brouwer

Naast de all method kun je er ook voor zorgen dat slechts één rij wordt gevonden. Je moet
dan de ‘ﬁrst’ of ‘last’ method aanroepen na de scopes. De ﬁrst method geeft de eerste rij
uit alle resultaten en de last method geeft de laatste rij. Hij voegt dan eigenlijk een LIMIT
toe aan de SQL query en voert deze gelijk uit.

posts = Post.order("id DESC").first
posts = Post.order("id ASC").last

De twee regels hierboven doen precies hetzelfde. Het geeft de allerlaatste post terug. Als je
één rij nodig hebt, maar niet wilt zoeken op id, dan moet je ﬁrst of last gebruiken in
combinatie met de scopes.
Als je overigens alleen wilt kijken of een bepaalde rij bestaat kun je de ‘exists?’ method
gebruiken.

Post.where(publish: true).exists?

Als er dan één of meerdere rijen bestaan wordt er true teruggegeven. Als dit niet zo is
wordt er false teruggegeven. Er wordt wel steeds een query uitgevoerd.
Wat ook nog handig is om te weten is dat je meerdere id’s kunt meegeven aan de ﬁnd
method. Er wordt een Array teruggegeven met deze rijen.
Post.find(1,2,3)

Naast de where en order scopes zijn er een aantal andere scopes. Meer hierover in het
volgende gedeelte van dit hoofdstuk.

5.6 Rails Scopes
Als je data uit de database wilt halen moet je gebruikmaken van de zogenaamde scopes.
Dit zijn een soort methods in de Model die je achter elkaar kunt aanroepen om zo een
bepaalde query op te bouwen. Ik heb de where en order scope al laten zien. Er zijn
natuurlijk een aantal extra scopes die je kunt gebruiken. Hiernaast kun je ook je eigen
scopes maken. In dit gedeelte zal ik dit allemaal behandelen.
In Rails 3 zijn er een aantal scope methods die je kunt gebruiken om een query op te
bouwen. Hier zijn ze allemaal op een rijtje:

84 - Instappen in Ruby on Rails 3 - Robin Brouwer

where
select
group
having
order
limit
offset
joins
includes
readonly
from

Zoals ik al heb uitgelegd wordt er niet gelijk een query uitgevoerd. Je krijgt een
ActiveRecord::Relation object terug. Dit is de query die je aan het opbouwen bent. Ik zal
nu elke method behandelen.

5.6.1 where
De where method gebruik je om een WHERE clausule toe te voegen aan je query. De
syntax van de where method is vrij simpel en kan op twee verschillende manieren. De
eerste manier is door een String mee te geven. Deze heb ik in het ‘Data manipuleren’
gedeelte behandeld. Hiernaast kun je ook een Hash meegeven. Dit ziet er als volgt uit:
posts = Post.where(publish: true)

Je kunt dan ook gemakkelijk meerdere condities meegeven.
posts = Post.where(publish: true, title: "Hello World")

Het is echter niet aan te raden om deze methode te gebruiken. Je kunt namelijk niet alles
doen wat je normaal gesproken met SQL kunt doen. Zo kun je met deze Hash methode
niet kijken of iets NULL is of juist niet gelijk is aan een bepaalde waarde. Ook kan je alleen
AND gebruiken en dus geen OR. Daarom kun je het beste de andere methode gebruiken.
Het is een stuk dynamischer.
De andere manier werkt met een simpele String. Dit ziet er als volgt uit:
posts = Post.where("publish = true AND title = 'Hello World'")

85 - Instappen in Ruby on Rails 3 - Robin Brouwer

Het is simpelweg SQL wat je hier schrijft. Je kunt hier alles doen wat je ook met SQL kunt
doen. Om een variabele in deze String te stoppen kun je het volgende doen:

title = "Hello World"
posts = Post.where("publish = true AND title = ?", title)

Je stopt op de plaats waar de variabele moet komen een vraagteken. Vergeet niet om de
apostrofs weg te halen om het woord. Rails voegt deze namelijk automatisch voor je toe.
Na de eerste parameter geef je dan de variabele mee als parameter. Je kunt meerdere
vraagtekens in de String stoppen. Rails kijkt dan van links naar rechts naar deze String en
haalt alle vraagtekens eruit. Als er één vraagteken inzit, wordt er naar de tweede
parameter gekeken (in het voorbeeld hierboven is dit ‘title’). Maar zitten er meerdere in?
Dan kijkt hij naar de parameters die erna worden gegeven. Dit ziet er dan zo uit:

title = "Hello World"
publish = true
posts = Post.where("publish = ? AND title = ?", publish, title)

Rails zorgt er ook automatisch voor dat er geen SQL injectie kan plaatsvinden als je het op
deze manier oplost. Zorg er sowieso voor dat je nooit, maar dan ook echt nooit, de
variabelen gelijk in de String stopt. Gemene hackers zouden dan SQL injecties in je
applicatie kunnen doen. Dat wil je natuurlijk niet.

5.6.2 select
Met de select method kun je de SELECT clausule vullen. Standaard is dit in Rails de
tabelnaam plus een sterretje (tabel_naam.*). Als je dit niet wilt kan dat natuurlijk.
posts = Post.select("id, title")

Nu krijgen we alleen de id en de titel terug en kunnen deze ook gewoon aanspreken. We
kunnen echter niet de body aanspreken. Deze wordt immers niet teruggegeven door de
SQL query.
Je kunt met de select method ook DISTINCT gebruiken om alleen unieke gegevens te
krijgen.
posts = Post.select("DISTINCT(title)")

86 - Instappen in Ruby on Rails 3 - Robin Brouwer

En als je JOIN gebruikt in de query kun je er hier ook voor zorgen dat alleen een paar
tabellen worden geselecteerd. Je kunt er echt alles mee wat je ook in SQL kunt doen.

5.6.3 order
Vaak wil je de resultaten in de query sorteren. Hiervoor heb je in SQL de ORDER BY
clausule. Hier heb je natuurlijk ook een Rails method voor. Dit is de order method.
posts = Post.order(:title)

Nu wordt in oplopende volgorde gesorteerd op de title kolom. Als je in aﬂopende
volgorde wilt sorteren moet je een String meegeven.
posts = Post.order("id DESC")

Je kunt hier weer SQL meegeven om de ORDER BY clausule te vullen. Je gebruikt ASC of
DESC (ascending en descending) en geeft aan op welke kolom dit moet gebeuren. Als je
op meerdere kolommen wilt sorteren kan dat ook.
posts = Post.order("id DESC, title ASC")

5.6.4 limit
Als je maar een bepaald aantal resultaten wilt terugkrijgen kun je de limit method
gebruiken. Er wordt dan een LIMIT clausule toegevoegd aan de query. Als je de ﬁrst of last
method aanroept wordt automatisch de LIMIT op 1 gezet. Hetzelfde wordt overigens ook
gedaan als je destroy aanroept op een rij.

posts = Post.limit(5).order("id DESC")

Met deze query krijg je de laatste vijf posts terug.

5.6.5 oﬀset
Je kunt in combinatie met de limit method ook de offset method aanroepen. Hierdoor
wordt een OFFSET clausule toegevoegd aan de query.
posts = Post.limit(5).offset(30)

87 - Instappen in Ruby on Rails 3 - Robin Brouwer

Nu worden vijf posts geselecteerd vanaf de eenendertigste rij.

5.6.6 group
Om een GROUP BY clausule toe te voegen aan de query kun je de group method
gebruiken.
post = Post.select("SUM(price)").group("id")

Je gebruikt de group method meestal als je iets als COUNT of SUM gebruikt. Als je geen
GROUP BY gebruikt komt er maar één rij als resultaat. De GROUP BY clausule zorgt er
dan voor dat er meerdere rijen worden geselecteerd.

5.6.7 having
Op de resultaten van een GROUP BY clausule kun je natuurlijk geen WHERE gebruiken.
Hiervoor heb je HAVING. Deze kun je ook gebruiken in Rails door de having method aan
te roepen.

post = Post.group("DATE(created_at)").having("created_at > ?", 1.month.ago)

Dit werkt hetzelfde als de where method. In dit voorbeeld worden alleen de resultaten
weergegeven die later zijn dan een maand geleden.

5.6.8 joins
Een van de meest gebruikte SQL clausules is de JOIN clausule. Natuurlijk kun je deze ook
gebruiken in Rails. Je kunt deze op twee manieren gebruiken. Deze keer is de pure SQL
versie, in tegenstelling tot de voorgaande scopes, niet de beste en vooral snelste manier.
Als er een koppeling is tussen posts en comments kun je gemakkelijk een join uitvoeren op
de comments tabel door het volgende te doen:
post = Post.joins(:comments)

Er wordt nu een INNER JOIN toegevoegd aan de query. Hoe je de koppeling kunt maken
tussen de comments en de posts zal ik later in dit hoofdstuk behandelen. Ik zal dan ook
weer dit voorbeeld erbij halen. Als je echter geen INNER JOIN wilt uitvoeren kun je de
hele join uitschrijven.
post = Post.joins("LEFT JOIN comments ON comments.post_id = posts.id")

88 - Instappen in Ruby on Rails 3 - Robin Brouwer

Ik heb geen joins method kunnen vinden waar je ook op een simpele manier een LEFT
JOIN kunt uitvoeren.

5.6.9 includes
Een heel handige method in Rails is de includes method. Hier geef je geen SQL op, maar
welke associaties moeten worden meegeladen. Rails kampte vroeger met het zogenaamde
N+1 probleem. Als je door een heleboel gegevens loopt en in deze loop een associatie
aanroept, dan wordt er bij elke iteratie een extra query uitgevoerd. Dit zag er ongeveer als
volgt uit:
comments = Comment.all
comments.each do |comment|
comment.post.title
end

De ‘post’ method die ik hier aanroep is de post die bij de comment hoort. Hoe je dit precies
voor elkaar krijgt leg ik later in dit hoofdstuk uit. Het probleem is echter dat er nu bij elke
iteratie een SQL query wordt uitgevoerd om de desbetreffende post bij de comment te
zoeken. Je zoekt één keer naar de comments, maar N keer naar de post die erbij hoort.
De oplossing hiervoor is de includes method.
comments = Comment.includes(:post)

Nu worden er twee queries uitgevoerd. Er is een query om de comments op te halen en
eentje om alle posts op te halen. Al deze posts worden automatisch gekoppeld aan de
comments. Er wordt niet steeds een extra query uitgevoerd bij elke iteratie. Scheelt een
heleboel queries.

5.6.10 readonly
Je kunt gevonden resultaten ook ‘readonly’ maken. Dit zorgt ervoor dat het niet aangepast
kan worden.

post = Post.readonly.first
post.title = "Read me!"
post.save

Je krijgt nu een error. Het object is namelijk readonly.

89 - Instappen in Ruby on Rails 3 - Robin Brouwer

Er zijn naast deze methods een aantal extra methods die je kunt gebruiken. Voor een
compleet overzicht kun je in de Ruby on Rails guide kijken.
Active Record Query Interface
http://guides.rubyonrails.org/active_record_querying.html
(TinyURL: http://tinyurl.com/2blnsf7)
Het is je vast opgevallen dat bijna alle methods gewone SQL accepteren en soms zelfs
moeten hebben. Als je al SQL kent is het vrij gemakkelijk om in Rails een query te maken.
Het is ook iets gemakkelijker om een dynamische query in Rails te maken. De nieuwe
manier van queries opbouwen in Rails 3 is een welkome toevoeging aan het framework.

5.7 Named Scopes
Je kunt ook je eigen scopes maken in Rails 3. In Rails 2.3 kon je dit doen met
‘named_scope’. In Rails 3 is dit afgekort naar ‘scope’. Het aanmaken van een scope doe je
in de Model. Je geeft aan hoe de scope heet en hierna kun je bepaalde Rails scopes
gebruiken om een scope op te bouwen. Hier een klein voorbeeld:

class Post < ActiveRecord::Base
scope :published, where("publish = true")
scope :recent, lambda do
where("created_at >= ?", 3.days.ago).order("created_at DESC")
end
end

Je geeft eerst de naam van de scope op en hierna wat erin moet komen. We hebben nu
twee scopes aangemaakt: published en recent. De published scope voegt alleen een
WHERE clausule toe aan de query. De recent scope is al iets lastiger te begrijpen. We
gebruiken hier de ‘lambda’ functie. Deze gebruik je onder andere als je met tijd gaat
werken. Als je namelijk lambda niet zou gebruiken wordt de tijd gebruikt van wanneer de
server werd opgestart. Dit is niet het moment waarop de scope wordt aangeroepen,
waardoor het resultaat niet zal kloppen. De lambda functie is een Proc die in runtime zal
worden uitgevoerd. Hierdoor zal de tijd kloppen.
Om de scopes aan te roepen kun je het volgende doen:

posts = Post.published.recent

Nu worden beide scopes samengevoegd in dezelfde query. We krijgen alle posts die
gepubliceerd zijn in de afgelopen drie dagen en krijgen deze in aﬂopende volgorde. De
query wordt hier ook nog niet uitgevoerd. Je moet nog steeds ‘all’ aanroepen of
erdoorheen loopen.
90 - Instappen in Ruby on Rails 3 - Robin Brouwer

Nog iets handigs aan lambda binnen scopes is dat je hiermee argumenten kunt meegeven
aan de scope. Zo kun je de scopes dynamisch maken:

class Post < ActiveRecord::Base
scope :since, lambda do |time|
where("created_at >= ?", time)
end
end

Dan kun je nu het volgende doen om de scope aan te spreken:

posts = Post.since(5.days.ago)

Je geeft een parameter mee aan de scope. Hier geven we een Time object mee.
Met scopes kun je heel gemakkelijk bepaalde queries in één woord stoppen. Dit is ook een
van de manieren om je aan de ‘Fat Model, Skinny Controller’ conventie te houden. Je
maakt de query in de Model en stopt deze in een scope. In de Controller hoef je alleen de
scope aan te roepen om de query uit te voeren.
Naast de scope method is er ook nog een andere manier om een named_scope te maken. Je
maakt dan een class_method.

class Post < ActiveRecord::Base
def self.since(time)
if time.present?
where("created_at >= ?", time)
else
scoped
end
end
end

Je geeft een Rails scope terug en als er niks wordt meegeven geef je het ‘scoped’ object
terug. Dit is de huidige scope waar deze method op wordt uitgevoerd. Als je dit niet zou
doen zou hij nil teruggeven en de huidige scope zou verloren gaan. Het doet voor de rest
precies hetzelfde als de scope die we eerder hebben aangemaakt. Het is een kwestie van
smaak welke je wilt gebruiken.

91 - Instappen in Ruby on Rails 3 - Robin Brouwer

Er is nog een extra scope die je kunt gebruiken. Dit is de ‘default_scope’. Hier kun je
aangeven welke scopes moeten worden uitgevoerd bij elke SELECT query. Zo wil je
misschien dat alle resultaten altijd zijn gesorteerd in aﬂopende volgorde. Dit doe je op de
volgende manier:

class Post < ActiveRecord::Base
default_scope order("id DESC")
end

Nu hoef je niet steeds het volgende te doen:

posts = Post.order("id DESC")

Deze wordt bij elke query automatisch toegevoegd. Als je de default_scope wilt negeren
kun je de ‘unscoped’ method gebruiken.

posts = Post.unscoped

De scopes in Rails zijn een van de handigste functionaliteiten die je in Rails zult vinden en
zul je ook erg vaak gebruiken. Als je benieuwd bent naar de SQL query die je hebt
gemaakt kun je altijd de to_sql method aanroepen aan het einde. Zo zie je precies wat voor
query je hebt opgebouwd.

5.8 Validatie
Validatie van verstuurde formulieren werkt iets anders in Rails dan je misschien gewend
bent. Er zijn een aantal soorten validatie die je kunt gebruiken en iedere soort heeft zijn
voor- en nadelen.
- De eerste soort validatie is in de database door middel van constraints en stored
procedures. Hiermee kan je er voor zorgen dat je database niet corrupt raakt en dat
bepaalde data altijd ingevuld moet worden. Het kan wel lastiger worden om de
applicatie te testen en de applicatie te onderhouden. Je moet namelijk steeds nieuwe
constraints en stored procedures maken als je applicatie verandert. Er zitten wel genoeg
voordelen aan. Het is heel veilig en kan het ook gemakkelijker maken om meerdere
applicaties aan dezelfde database te hangen. De validatie gebeurt namelijk in de database
en dus raakt je database niet corrupt.
- Validatie aan de kant van de gebruiker door middel van JavaScript is ook een
mogelijkheid om bepaalde velden te valideren. Het probleem hiermee is dat JavaScript
gemakkelijk uitgezet kan worden, waardoor er allemaal data in de database kan komen
die je eigenlijk niet wilt hebben. Dit soort client-side validatie kan wel erg handig zijn als
92 - Instappen in Ruby on Rails 3 - Robin Brouwer

je het combineert met andere technieken. Het kan de ervaring van de gebruiker ﬂink
bevorderen.
- Controller-level validatie is ook een van de mogelijkheden. Je kunt in de Controller
namelijk checken of bepaalde data juist is en hierop gemakkelijk reageren. Deze manier
gaat wel tegen de conventie ‘Fat Model, Skinny Controller’ in. Als je alle validatie in de
Controller doet ben je vaak ook niet DRY bezig. Als je namelijk meerdere Controllers hebt
waar dezelfde validatie moet komen zou dit vaak dubbel moeten worden gedaan. Je
applicatie is ook nog een heel stuk minder ﬂexibel. Het is aan te raden om dit niet te
doen.
- De manier waarop Rails het doet is op Model-level. Voordat de data in de database
wordt gestopt checkt de Model of de data klopt. Dit is geheel in stijl van de ‘Fat Model,
Skinny Controller’ conventie. Rails heeft hier ook handige methods voor waardoor dit
heel gemakkelijk kan. Het is ook gemakkelijk om je applicatie hiermee te onderhouden
en te testen. Het is ook veilig, omdat alle data langs de Model moet voordat het in de
database komt. Hoe deze manier van valideren werkt zal ik in dit gedeelte uitleggen.

5.8.1 Validatie methods
Op elke kolom in de tabel kun je meerdere soorten validatie hangen. Rails kent de
volgende methods om kolommen te valideren:
validates_presence_of
validates_length_of
validates_numericality_of
validates_uniqueness_of
validates_acceptance_of
validates_confirmation_of
validates_exclusion_of
validates_format_of
validates_inclusion_of
validates_associated

Deze methods kun je gebruiken in de Model en zorgen ervoor dat als je de save method
aanroept er eerst wordt gekeken of de data klopt. Als dit niet klopt wordt er false
teruggegeven en krijg je een errors object met wat er allemaal fout is.
De methods hierboven waren ook al beschikbaar in Rails 2.3. Rails 3 ondersteunt een
nieuwe manier van valideren. Dit is de ‘validates’ method. Hier ga ik zometeen wat dieper
op in. Eerst zal ik een aantal van de oudere methods behandelen (die dus nog steeds
kunnen worden gebruikt!).
validates_presence_of
De eerste method is ook meteen de method die je het meest zult gebruiken. Dit is een
check om te kijken of een bepaald veld is ingevuld. Als een veld verplicht is gebruik je
deze method om dit te checken.
93 - Instappen in Ruby on Rails 3 - Robin Brouwer

class Post < ActiveRecord::Base
  validates_presence_of :title
end

Nu moet er altijd een titel aanwezig zijn als je een post aanmaakt.
validates_length_of
Met deze method kun je valideren of de lengte van een bepaald veld klopt. Je kunt dit op
verschillende manieren doen. Hier zijn ze allemaal op een rijtje:
class Person < ActiveRecord::Base
  validates_length_of :name, minimum: 2
  validates_length_of :bio, maximum: 500
  validates_length_of :password, in: 6..20
  validates_length_of :registration_number, is: 6
end

Je kunt een minimum aantal tekens vragen en een maximum. Hiernaast kun je met de :in
optie een Range meegeven. Je kunt ook aangeven dat het altijd een bepaald aantal tekens
moet hebben. Dit doe je met de :is optie.
validates_numericality_of
Soms wil je dat er alleen een getal ingevoerd kan worden in een bepaald veld. Hierop kan
je checken door deze method te gebruiken. Rails checkt voor je of het een getal is. Je kunt
hier ook een aantal extra opties aan meegeven. Zo heb je de :only_integer optie om alleen
integers toe te staan.

class Player < ActiveRecord::Base
  validates_numericality_of :points
  validates_numericality_of :games_played, only_integer: true
end

Hiernaast heb je een aantal extra opties, zoals :greater_than, :equal_to, :less_than, :odd
en :even. Wat deze doen spreekt voor zich.
validates_uniqueness_of
Soms wil je dat een bepaalde kolom altijd uniek is. Zo wil je in een gebruikerstabel dat een
e-mailadres altijd maar één keer voorkomt. Hiervoor gebruik je deze method.

94 - Instappen in Ruby on Rails 3 - Robin Brouwer

class User < ActiveRecord::Base
  validates_uniqueness_of :email
end

Rails voert eerst een query uit om te kijken of het e-mailadres al bestaat. Als dit zo is dan
wordt de gebruiker niet opgeslagen.
validates_conﬁrmation_of
Deze method kun je gebruiken om te checken of een tweede veld precies overeenkomt met
het originele veld. Denk aan het twee keer invullen van een wachtwoord. Je doet dan het
volgende:
class Person < ActiveRecord::Base
  validates_confirmation_of :password
end

Er wordt één virtuele attribuut aangemaakt genaamd ‘password_conﬁrmation’. Bij het
valideren wordt dan gecheckt of de waarde in deze attribuut gelijk is aan het originele
attribuut. Vergeet overigens niet om een extra validates_presence_of toe te voegen voor de
virtuele attribuut.

class Person < ActiveRecord::Base
  validates_confirmation_of :password
validates_presence_of :password_confirmation
end

Hier een voorbeeld in de console:

person = Person.new
person.password = "123456"
person.save # => false
person.password_confirmation = "123456"
person.save # => true

Het opslaan werkt pas als het virtuele attribuut precies hetzelfde is.

95 - Instappen in Ruby on Rails 3 - Robin Brouwer

validates_format_of
Dit is een erg handige manier om je velden te valideren. Je kunt namelijk een reguliere
expressie meegeven. Je kunt bijvoorbeeld checken of iets een geldig e-mailadres is. Hier
een voorbeeld om te kijken of er alleen letters in het veld zitten:
class User < ActiveRecord::Base
  validates_format_of :username, with: /\A[a-zA-Z]+\z/,
    message: "Only letters allowed"
end

Je geeft aan de :with optie mee wat de reguliere expressie is. Aan de :message optie kun je
een bericht meegeven waarin wordt omschreven wat er fout is. Dit is overigens een
verkeerde manier om je bericht te tonen. Dit moet je eigenlijk in een zogenaamde locale
bestand stoppen. Meer hierover in het Locales hoofdstuk.

5.8.2 Validatie opties
Je kunt ook extra opties meegeven aan de methods die ik hierboven heb genoemd. Een
aantal hiervan heb ik al behandeld. Een aantal belangrijke opties zijn:

:allow_nil
:allow_blank
:message
:on
:if
:unless

De :allow_nil en :allow_blank opties staan standaard uit. Als je de :allow_nil optie aanzet
dan wordt de validatie niet uitgevoerd als het attribuut nil is en dus geen waarde heeft.
Bij :allow_blank kun je ervoor zorgen dat de validatie niet wordt uitgevoerd als het
attribuut leeg is. Leeg staat voor een lege String. Hier een voorbeeld:

class Post < ActiveRecord::Base
  validates_length_of :title, minimum: 5, allow_blank: true
end
 
Post.new(title: "").valid? 	
# => true (title is blank)
Post.new.valid? 	
	
	
# => false (title is nil)

De :message optie heb ik al behandeld en is eigenlijk niet aan te raden. Dit kun je namelijk
beter regelen in een locale bestand. De :on optie is om aan te geven wanneer je wilt

96 - Instappen in Ruby on Rails 3 - Robin Brouwer

valideren. Soms wil je namelijk alleen bij het aanmaken van een rij valideren en niet bij het
aanpassen. Je geeft hier altijd een Symbol aan mee.

class Person < ActiveRecord::Base
  # Het valideren gebeurt alleen bij het aanmaken.
  validates_confirmation_of :password, on: :create
 
  # Het valideren gebeurt alleen bij het aanpassen.
  validates_numericality_of :age, on: :update
 
  # De standaardwaarde. Gebeurt bij aanmaken en aanpassen.
  validates_presence_of :name, on: :save
end

De :if en :unless opties kun je gebruiken om alleen op bepaalde momenten te valideren.
Dit is een zogenaamde conditionele validatie en werkt als volgt:

class Order < ActiveRecord::Base
  validates_presence_of :card_number, if: :paid_with_card?
 
  def paid_with_card?
    payment_type == "card"
  end
end

Nu wordt er alleen op het kaartnummer gecheckt als er ook daadwerkelijk is gekozen
voor de kaart. Je maakt een method aan genaamd ‘paid_with_card?’ die een Boolean
teruggeeft. De :unless optie werkt precies hetzelfde als de :if optie, maar dan andersom.
Bij :if is het ‘als dit klopt’ en bij :unless is het ‘als dit niet klopt’. Naast een method
aanspreken kun je ook een Proc meesturen.

class Order < ActiveRecord::Base
  validates_presence_of :card_number,
if: Proc.new { |order| order.payment_type == "card" }
end

Scheelt weer een paar regels. Procedures worden wel vaker gebruikt om een validatie
conditioneel te maken. Je kunt hier overigens ook lambda gebruiken als je wilt.

5.8.3 Validatie omzeilen
Al deze methods zorgen er voor dat je gemakkelijk je kolommen kunt valideren. Deze
validatie wordt uitgevoerd bij de volgende methods:
97 - Instappen in Ruby on Rails 3 - Robin Brouwer

create
create!
save
save!
update
update_attributes
update_attributes!

Zoals je ziet staat ‘update_attribute’ er niet tussen. Dit is dan ook één van de manieren om
iets te updaten zonder te kijken naar de validatie. Kijk dus uit wanneer je update_attribute
gebruikt! Als je bij de ‘save’ method geen validatie wilt uitvoeren kun je het volgende
doen:

post.save(validate: false)

Gebruik dit alleen als je zeker weet dat je niet wilt valideren.

5.8.4 Validatie uitlezen
Wat als je wilt checken of alles gevalideerd is, maar het nog niet wilt opslaan? Daar heb je
de ‘valid?’ en ‘invalid?’ methods voor. Deze geven een Boolean terug en werken als volgt:
post = Post.new
post.valid?	
	
	
post.invalid? 		
	
post.title = "Validatie"
post.valid?	
	
	
post.invalid?	 	
	

# => false
# => true
# => true
# => false

Er wordt nog niks opgeslagen. Het is een erg handige manier om te bekijken of er errors
zijn in bijvoorbeeld een formulier. Maar je wilt natuurlijk ook weten wat er niet valide is.
Hiervoor heb je de ‘errors’ Hash. Deze wordt gevuld nadat de ‘valid?’ of ‘invalid?’
methods worden aangeroepen. Deze methods worden overigens ook aangeroepen als je
een rij wilt opslaan. Dus dan wordt de errors method ook gevuld.
post = Post.new
post.valid?	
	
post.errors	
	
post.errors[:name]	

	
	
	

# => false
# => { name: ["can't be blank"] }
# => ["can't be blank"]

98 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je zou nu door alle kolommen kunnen heengaan en per kolom alle errors laten zien aan de
gebruiker. Gelukkig doet Rails dit voor een groot gedeelte al automatisch voor je. Hier
later meer over.
Je kunt nog heel veel meer met de errors method. Als je hier meer over wilt weten kun je
het beste in de Rails guide kijken. Aan het einde van het validatie gedeelte heb ik een link
hiernaartoe gegeven.

5.8.5 Validates method
Dan nu de nieuwe validates method die in Rails 3 is geïntroduceerd. Deze method gebruik
je om alle validatie voor één kolom op één regel te stoppen. Het werkt als volgt:
class Post < ActiveRecord::Base
validates :title, presence: true, length: { within: 2..60 }
end

Het is een extra manier van validatie in Rails en kan in sommige gevallen net iets handiger
werken dan de oude manier. De oude manier is echter niet weg, dus die kun je nog steeds
gebruiken en kan in sommige gevallen ook handiger werken dan de nieuwe manier. Je
zult het vaak afwisselen.
Je kunt een aantal opties meegeven aan de validates method. Deze werken hetzelfde als de
oudere methods, dus ik ga er niet diep op in.
acceptance: Boolean
confirmation: Boolean
exclusion: { in: Enumerable }
inclusion: { in: Enumerable }
format: { with: Regexp, on: :create }
length: { maximum: Fixnum }
numericality: Boolean
presence: Boolean
uniqueness: Boolean

Je kunt naast de validatie methods die ik heb genoemd nog veel meer valideren in Rails.
Hoe dit precies werkt kun je het beste bekijken in de ofﬁciële Rails guide.
Active Record Validations and Callbacks
http://guides.rubyonrails.org/active_record_validations_callbacks.html
(TinyURL: http://tinyurl.com/38tjwxr)

99 - Instappen in Ruby on Rails 3 - Robin Brouwer

5.9 Callbacks
Een callback in Rails is een method die je op een bepaald moment in de levensduur van
een object kunt aanspreken. Zo kun je bepaalde code uitvoeren voor of na het creëren van
een nieuwe rij in de tabel of wat code uitvoeren nadat een rij is verwijderd. Een Model
kent de volgende momenten waarop een callback kan worden aangeroepen:

# Een object aanmaken
before_validation
after_validation
before_save
after_save
around_save
before_create
around_create
after_create
# Een object aanpassen
before_validation
after_validation
before_save
after_save
around_save
before_update
around_update
after_update
# Een object verwijderen
before_destroy
after_destroy
around_destroy

Dat zijn er behoorlijk veel. Tussen de ‘before_save’ en ‘after_save’ methods wordt het
object opgeslagen in de database. Tussen de ‘before_destroy’ en ‘after_destroy’ methods
wordt het object verwijderd. De benaming van al deze methods spreekt voor zich. Het
enige wat misschien wat vraagtekens oproept zijn de ‘around’ methods. Ik leg later uit hoe
dit elkaar zit.
Eerst zal ik uitleggen hoe je een callback method kunt maken. Je geeft eerst het moment op
waarop je een method wilt uitvoeren en hierna de naam van jouw callback method.

100 - Instappen in Ruby on Rails 3 - Robin Brouwer

class Post < ActiveRecord::Base
before_create :set_published
private
def set_published
self.publish = false
true
end
end

Je maakt een method aan waarin je Ruby code uitvoert. In dit voorbeeld zetten we de
publish kolom automatisch op false voordat het bericht wordt aangemaakt. Je ziet ook dat
we aan het einde van de ‘set_published’ method ‘true’ teruggeven. Als een callback
namelijk false of nil teruggeeft, zal het proces worden gestopt. In ons geval zou het bericht
niet worden opgeslagen. Door aan het einde true neer te zetten gebeurt dit wel. Dit moet je
dus alleen doen als de laatste regel false of nil teruggeeft.
Meestal zijn callback methods private methods. Je hoeft ze namelijk niet vanuit een andere
Class te kunnen aanspreken. In het voorbeeld hierboven geven we aan dat deze method
moet worden uitgevoerd net voordat het object wordt aangemaakt. Alle callback methods
die ik hierboven heb genoemd kun je op dezelfde manier aanspreken als in het vorige
voorbeeld. Eerst de soort callback opgeven en hierna de naam van de method die moet
worden uitgevoerd. Je moet wel opletten dat je niet in zo’n method opnieuw het object
gaat opslaan, want dan kan je een oneindige loop krijgen waarin het object steeds
opnieuw wordt opgeslagen.
Merk ook vooral het verschil tussen create, update en save op. Je kunt de callbacks
speciﬁceren en bijvoorbeeld alleen uitvoeren als een nieuw object wordt aangemaakt (met
de create callbacks). De save methods worden bij zowel het aanmaken als het aanpassen
uitgevoerd.
Maar dan zijn er nog de ‘around’ methods. Deze methods zijn er om de before en after
samen te voegen in één method. Je moet dan wel in deze method aangeven wanneer het
opslaan moet gebeuren. Dit ziet er als volgt uit:

101 - Instappen in Ruby on Rails 3 - Robin Brouwer

class Post < ActiveRecord::Base
around_create :set_published
private
def set_published
self.publish = false
yield
puts "Saved draft ##{id}"
end
end

Met ‘yield’ geef je aan wanneer de create moet worden uitgevoerd. Voor de yield is de
before_create en na de yield is de after_create. Deze callback kan handig zijn om alles
samen te voegen in één method.
Naast de hierboven genoemde methods zijn er ook twee andere methods: after_initialize
en after_ﬁnd. De after_initialize method wordt uitgevoerd nadat de Class is
geïnitialiseerd. Dit werkt als volgt:

class Post < ActiveRecord::Base
after_initialize :init
private
def init
puts "Initialized!"
end
end
post = Post.new 	

# => Initialized!

De after_ﬁnd method wordt uitgevoerd nadat een SELECT query is uitgevoerd. Dit
gebeurt onder andere bij de all, ﬁrst en last methods.

102 - Instappen in Ruby on Rails 3 - Robin Brouwer

class Post < ActiveRecord::Base
after_find :found
private
def found
puts "Found it!"
end
end
post = Post.find(1) 	# => Found it!

Je kunt erg veel met de callback methods in Rails. Er zijn genoeg extra dingen die je met
callbacks kunt doen die ik niet heb behandeld. Je kunt bijvoorbeeld een Proc gebruiken bij
een callback. Ook kun je :if en :unless opties meegeven om conditionele callbacks te
krijgen en kan je zelfs een speciale callback Class maken. Hoe dit allemaal werkt kun je
vinden in de Rails guide.
Active Record Validations and Callbacks
http://guides.rubyonrails.org/active_record_validations_callbacks.html
(TinyURL: http://tinyurl.com/38tjwxr)

5.10 Relaties
Een van mijn favoriete onderdelen van Ruby on Rails is hoe de relaties tussen tabellen is
geregeld. Deze relaties zorgen ervoor dat tabellen op een vrij simpele manier met elkaar
zijn verbonden. In SQL gebruik je lange JOIN statements om aan te geven dat je een relatie
wilt leggen. Hier hoef je in Rails helemaal niet over na te denken.
Zoals ik al heb aangegeven moet achter de naam van een foreign key altijd _id staan en is
het altijd het enkelvoud van de gekoppelde tabel. Als we een posts en comments tabel
hebben en een comment hoort bij een post, dan is de foreign key in de comments tabel als
volgt:

post_id

Rails zoekt automatisch naar deze kolom als je in de Model aangeeft dat je een relatie wilt
hebben. Je kunt de naamgeving ook op een andere manier doen en in je model
conﬁgureren wat deze benaming is. Dit gaat echter tegen de ‘Convention over
Conﬁguration’ conventie in en moet je niet doen.
Maar hoe maak je zo’n relatie? Hier kent Rails een aantal handige methods voor:

103 - Instappen in Ruby on Rails 3 - Robin Brouwer

belongs_to
has_many
has_one
has_and_belongs_to_many
has_many :through

Hiermee kun je alle relaties leggen die je wilt.

5.10.1 belongs_to
De eerste relatie die ik ga behandelen is de belongs_to method. Dit is de ‘many-to-one’
relatie. Zoals het woord al zegt geef je hiermee aan waarbij een bepaalde Model hoort. Zo
hoort een comment bij een post. Een comment ‘belongs_to’ een post.
class Comment < ActiveRecord::Base
belongs_to :post
end

En dat is het! De comment is nu gekoppeld aan de post. Je moet natuurlijk wel eerst een
Comment model maken, een post_id kolom eraan toevoegen en de database migraten.
Als je een comment hebt gemaakt kun je gemakkelijk de gekoppelde post erbij vinden.
comment = Comment.find(1)
comment.post

Je roept de ‘post’ method aan om het Post object terug te krijgen. Deze method heb je
gemaakt door de belongs_to method aan te roepen. Als er geen post aan gekoppeld is zal
je een nil object terugkrijgen. Om de titel van de post op te halen doe je het volgende:
comment.post.title

Bij een belongs_to method wordt altijd één object teruggegeven. Je hoeft hier niet
doorheen te loopen. Je kunt gelijk de kolommen erop aanspreken.
Maar hoe zorg je er dan voor dat een post ook echt wordt gekoppeld aan een comment?

104 - Instappen in Ruby on Rails 3 - Robin Brouwer

post = Post.first
comment = Comment.new
comment.post = post
comment.save

Nu wordt de post die je hebt opgezocht in de belongs_to relatie gestopt. Als je het dan
opslaat wordt automatisch de post_id kolom gevuld met het juiste id.
Zo simpel is een belongs_to relatie. Een handige vuistregel: de belongs_to relatie zit altijd
in de Model waar de foreign key zit. Ook is de relatie altijd in het enkelvoud geschreven.
Je krijgt immers maar één object terug!

5.10.2 has_many
Het kan natuurlijk ook voorkomen dat een rij in de tabel één of meerdere rijen uit een
andere tabel aan zich gekoppeld heeft. Dit is een ‘one-to-many’ relatie en kun je in Rails
maken met de has_many method. Bij ons voorbeeld heeft een post meerdere comments.
Een post ‘has_many’ comments.
class Post < ActiveRecord::Base
has_many :comments
end

Dit is in het meervoud geschreven omdat je meerdere rijen terug kan krijgen. Je krijgt altijd
een Array terug met objecten erin. In ons geval krijgen we een Array aan comments.
post = Post.first
comments = post.comments
comments.each do |comment|
puts comment.title
end

Je kunt door deze Array loopen. De relatie aanmaken werkt als volgt:
post = Post.first
comment = Comment.new
post.comments << comment

105 - Instappen in Ruby on Rails 3 - Robin Brouwer

De ‘<<‘ functie kun je op elke Array gebruiken en zorgt ervoor dat de comment wordt
toegevoegd aan de Array. Het handige is dat de comment gelijk wordt gekoppeld aan de
post. De post_id kolom wordt gevuld en de comment wordt opgeslagen.
Bij een has_many relatie is het altijd handig om er ook voor te zorgen dat de belongs_to
relatie wordt gelegd, zodat de relatie beide kanten opgaat. Dit hadden we al in het
belongs_to gedeelte gedaan. Vergeet dit niet te doen.
Eerder in dit hoofdstuk heb ik de joins en includes scope methods laten zien. Ik gaf aan
dat je bij de joins method ook een naam kon opgeven in plaats van SQL. Deze naam die je
meegeeft is de relatie die je aanlegt tussen de Models.

posts = Post.joins(:comments)
comments = Comment.joins(:post)

Let hier ook weer op het enkelvoud en meervoud! Nu wordt er een JOIN clausule
toegevoegd die een relatie legt met de andere tabel. Dit werkt hetzelfde bij de includes
method. Het verschil hier is dat bij de includes method een extra query wordt uitgevoerd
om alle relaties op te halen.

5.10.3 has_one
Dit is een one-to-one relatie. Het is misschien de meest logische relatie tussen verliefde
mensen, maar in de Rails wereld komt dit niet al te vaak voor. Het is natuurlijk wel handig
om te weten dat deze method bestaat in Rails. Het werkt precies hetzelfde als de
belongs_to method. Het verschil is dat deze niet in de tabel staat van de foreign key. Je
krijgt altijd maar één object terug en schrijft de relatie ook in het enkelvoud.
Je gebruikt deze relatie vooral om data in een tabel te scheiden, zodat je niet een tabel
krijgt met ontzettend veel kolommen. Stel je hebt een proﬁel van een gebruiker waar een
heleboel informatie aan gekoppeld is. Dan wil je misschien deze informatie scheiden in
aparte tabellen. In het voorbeeld hieronder zie je hoe een User een has_one relatie heeft
met PersonalInfo. Alle persoonlijke informatie over de gebruiker zit in een aparte tabel,
zodat de users tabel overzichtelijker is.
class User < ActiveRecord::Base
has_one :personal_info
end
class PersonalInfo < ActiveRecord::Base
belongs_to :user
end

106 - Instappen in Ruby on Rails 3 - Robin Brouwer

5.10.4 has_and_belongs_to_many
Dat is een hele mond vol. De afkorting hiervoor is habtm. Het is een many-to-many relatie
en zorgt ervoor dat je heel gemakkelijk een koppeltabel kunt gebruiken. Het is een
koppeltabel waar alleen twee foreign keys inzitten. Je kunt er geen extra data instoppen.
Daarvoor is een andere relatie, die ik zometeen uitleg.
Er zijn wel een paar extra conventies waar je je aan moet houden bij het habtm relatie.
- De naam van de koppeltabel moet altijd de namen van de twee tabellen in het meervoud
bevatten, gescheiden door een liggend streepje en in alfabetische volgorde. Als je een
projects en users tabel hebt heet de koppeltabel: projects_users.
- De koppeltabel mag geen primary key bevatten.
- De koppeltabel mag alleen twee foreign keys bevatten. Deze zijn zoals gewoonlijk in het
enkelvoud met _id erachter.
Stel we hebben een Project model en een User model. Hiervoor hebben we een koppeltabel
nodig. Bij een koppeltabel heb je geen Model nodig. Je moet wel een migration maken.
rails g migration create_projects_users_table

Je stopt dan het volgende in het migration bestand:
class CreateProjectsUsersTable < ActiveRecord::Migration
def self.up
create_table :projects_users, id: false do |t|
t.integer :project_id
t.integer :user_id
end
end
def self.down
drop_table :projects_users
end
end

Je moet vooral opletten dat je de :id optie op false zet. Er mag geen primary key in komen.
Handig om te weten is dat je ook op een andere manier foreign keys kunt toevoegen in een
migration.

107 - Instappen in Ruby on Rails 3 - Robin Brouwer

create_table :projects_users, id: false do |t|
t.references :project, :user
end

Dit doet precies hetzelfde als ik hierboven liet zien.

In Rails 3.1 zal bij gebruik van ‘references’ ook automatisch een index erop worden
geplaatst. Het is daarom handiger om references te gebruiken in een migration dan
direct de integer kolommen aan te maken.

Als je nu de migratie uitvoert kun je het volgende in de Models stoppen:

class Project < ActiveRecord::Base
has_and_belongs_to_many :users
end
class User < ActiveRecord::Base
has_and_belongs_to_many :projects
end

En zo simpel is het! Rails doet de rest automatisch voor je. Je krijgt net als de has_many
relatie een Array terug aan objecten en kunt er op dezelfde manier mee omgaan als een
has_many relatie.

In Rails 3.0 was het nogal een gedoe om de koppeling tussen habtm relaties te
verwijderen. Als je ‘destroy’ aanriep op de relatie werd niet de relatie verwijderd,
maar de gekoppelde rijen. In Rails 3.1 is dit opgelost en zal alleen de relatie worden
verwijderd als je ‘destroy’ erop aanroept.

5.10.5 has_many :through
Stel je hebt orders en products. Een bestelling (order) heeft meerdere producten (products)
eraan gekoppeld. Andersom geldt hetzelfde (een product is meerdere malen besteld). Er is
dus een many-to-many relatie nodig. Je zou een habtm relatie kunnen gebruiken, maar
dan zou je niet kunnen opgeven hoeveel er van het product is besteld. Ook is het handig
om de data van het product op te slaan in de koppeltabel, zodat als je iets aanpast aan het
product, dit niet bij alle bestellingen wordt doorgevoerd. Als je een prijsverlaging
doorvoert wil je niet dat deze prijs bij alle bestaande bestellingen ook wordt gebruikt.

108 - Instappen in Ruby on Rails 3 - Robin Brouwer

Er is dus een andere relatie nodig. Dit is precies waar je de has_many :through relatie voor
kunt gebruiken. Dit is hetzelfde als de habtm relatie. Het verschil is dat je een Model nodig
hebt voor de koppeltabel, dat er een primary key in moet zitten en dat je extra kolommen
eraan kunt toevoegen. Ook is de naam van de tabel anders. Hier is niet echt een speciﬁeke
conventie voor. Wat ik meestal doe is kijken wat de relatie is en hiervoor een goede naam
verzinnen.
De koppeltabel zal bestelde producten bevatten. De naam ‘ordered_products’ zou daar
goed bij passen. Het zijn immers ‘bestelde producten’. Ik maak daarom een
OrderedProduct Model en een ordered_products tabel.

rails g model OrderedProduct

Dit is een gewone Model met twee foreign keys (order_id en product_id), een primary key
en extra kolommen met informatie over het product. De relatie leggen is wel wat
ingewikkelder dan een habtm relatie.

class Order < ActiveRecord::Base
has_many :ordered_products
has_many :products, through: :ordered_products
end
class OrderedProduct < ActiveRecord::Base
belongs_to :order
belongs_to :product
end
class Product < ActiveRecord::Base
has_many :ordered_products
has_many :orders, through: :ordered_products
end

In de OrderedProduct Model moet je de belongs_to relaties leggen. In de twee gekoppelde
Models moet je eerst een has_many relatie leggen met de OrderedProduct Model. Hierna
kun je een has_many relatie opgeven voor de andere Model en aangeven dat deze ‘door’
de andere relatie moet gaan. Dat is de has_many :through relatie.
Je kunt er weer op dezelfde manier mee omgaan als een has_many relatie. Je kunt
hiernaast ook de :ordered_products relatie aanspreken om kolommen uit deze tabel aan te
spreken.

109 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je kunt de has_many :through relatie ook gebruiken om van een tabel naar een andere
tabel te gaan via een aantal andere tabellen. De juiste JOIN wordt dan automatisch voor je
uitgevoerd.

Ook bij een has_many :through relatie zal alleen de koppeling worden verwijderd
als je de ‘destroy’ method op de relatie aanspreekt. Ook hier was het in Rails 3.0 zo
dat de gekoppelde rijen werden verwijderd.
Om alle gekoppelde rijen te verwijderen kun je het volgende doen (ook bij habtm):
order = Order.first
order.ordered_products.each(&:destroy)

De ‘&:destroy’ parameter is een short-cut voor een block. Hier wordt automatisch
op elke block variabele de ‘destroy’ method aangeroepen.

In Rails 3.1 is het mogelijk om has_many :through te nesten. Dit kon niet in Rails
3.0. Ook is het in Rails 3.1 mogelijk om aan de :through optie een habtm relatie
mee te geven. Dit kon ook niet in Rails 3.0.

5.10.6 Relational callbacks
Je hebt speciale callbacks voor de relaties die ik hier heb behandeld. Deze kun je opgeven
door de :dependent optie mee te geven aan de relatie. Deze accepteert drie
waardes: :destroy, :nullify en :delete.
class Post < ActiveRecord::Base
has_many :comments, dependent: :destroy
end

Bij de :destroy waarde worden alle comments verwijderd als de post wordt verwijderd.
Bij :delete wordt er gelijk een SQL query uitgevoerd zoals bij de delete method. De :nullify
waarde zorgt ervoor dat alle foreign keys NULL worden. Met deze relationele callbacks
kun je gemakkelijk connecties verwijderen als een bepaalde rij wordt verwijderd.
Naast de :dependent optie kun je nog veel meer opties meegeven. Zo heb
je :conditions, :counter_cache, :class_name, :foreign_key en nog veel meer. Deze kun je
gebruiken om je relaties verder te conﬁgureren. Aan het einde van het relaties gedeelte
geef ik een link waar dit ook wordt uitgelegd.

110 - Instappen in Ruby on Rails 3 - Robin Brouwer

5.10.7 Polymorphic associations
Een iets geavanceerde relatie is de ‘polymorphic’ relatie. Hiermee kun je meerdere Models
aan één Model koppelen. Denk aan een applicatie waar je een Post, Event en Photo Model
hebt. Aan elke Model wil je comments kunnen hangen. Je hebt ook een Comment Model.
Maar hoe leg je deze relatie? Je kunt drie foreign keys toevoegen aan de comments tabel,
maar dat is natuurlijk niet heel netjes. Hier komt de polymorphic relatie van pas.
Een polymorphic association houdt in dat je door middel van slechts twee kolommen kunt
aangeven waar bijvoorbeeld een comment bijhoort. Je hebt een string (VARCHAR) die
aangeeft welke model het is en een integer die aangeeft welke ID van de model het is. In
Rails is dit heel gemakkelijk op te zetten. Je moet je wel aan een aantal conventies houden
om dit goed te laten werken.
Het eerste wat je moet doen is twee kolommen aanmaken:
create_table :comments do |t|
t.text :body
t.string :commentable_type
t.integer :commentable_id
t.timestamps
end

Je hebt twee kolommen: commentable_type en commentable_id. De _type geeft aan wat
voor Model er moet worden gebruikt en de _id geeft de ID waaraan het gekoppeld moet
worden. Je MOET ervoor zorgen dat de kolomnamen dezelfde naam hebben en eindigen
op _type en _id. Ik heb hier voor commentable gekozen als naam. Zo'n soort naam wordt
namelijk veel gebruikt bij polymorphic associations. Zo heb ik ook twee 'loggable'
kolommen in een applicatie die ik heb ontwikkeld.
Je kunt het aanmaken van deze twee kolommen ook wat eenvoudiger maken door het via
‘references’ te doen.
create_table :comments do |t|
t.text :body
t.references :commentable, polymorphic: true
t.timestamps
end

Het volgende wat je moet doen is alles goedzetten in de Model. Eerst de Comment model:

111 - Instappen in Ruby on Rails 3 - Robin Brouwer

class Comment < ActiveRecord::Base
belongs_to :commentable, polymorphic: true
end

Je hebt een belongs_to relatie en geeft aan dat het een polymorphic association is. Nu
kunnen we de has_many relaties regelen:

class Post < ActiveRecord::Base
has_many :comments, as: :commentable
end
class Event < ActiveRecord::Base
has_many :comments, as: :commentable
end
class Photo < ActiveRecord::Base
has_many :comments, as: :commentable
end

De :as optie zorgt ervoor dat Rails weet om welke relatie het gaat. Je kunt nu de comments
aanspreken door de ‘comments’ relatie aan te roepen. Als je het object wilt ophalen vanuit
de Comment Model moet je de ‘commentable’ relatie aanspreken. Je krijgt dan een Post,
Event of Photo terug.
Als je meer wilt weten over relaties in Rails kun je het beste naar de Rails guide kijken:
Association Basics
http://guides.rubyonrails.org/association_basics.html
(TinyURL: http://tinyurl.com/5kpesv)

5.11 attr_accessor en attr_accessible
Voordat we met Controllers gaan werken zal ik nog een essentieel onderdeel van Models
uitleggen. Dit zijn de attr_accessor en attr_accessible methods. De ene method is om
virtuele attributen te maken en de andere is voor de beveiliging.

5.11.1 attr_accessor
Met deze method kun je virtuele attributen maken. Dit zijn een soort kolommen voor de
tabel die niet worden opgeslagen in de database. Denk aan de _conﬁrmation attributen die
verschijnen als je validates_conﬁrmation_of gebruikt. Dit is een tijdelijke attribuut waar je
iets in kunt stoppen maar niet wordt opgeslagen. In het ‘Ruby leren’ hoofdstuk heb ik al
laten zien dat attr_accessor een getter en setter maakt. Dit gebeurt ook in een Model.

112 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je kunt een attr_accessor onder andere gebruiken voor een password attribuut. Je wilt dat
de gebruiker zijn of haar wachtwoord in een password attribuut stopt, maar je wilt deze
natuurlijk niet opslaan in de database. Je gaat namelijk nooit het wachtwoord van de
gebruiker gelijk opslaan in de database. Je moet er een encryptie op loslaten voordat je dit
doet. Hier een voorbeeld met de SHA1 encryptie:

class User < ActiveRecord::Base
attr_accessor :password
validates_confirmation_of :password, if: :password?
validates_presence_of :password, :password_confirmation, on: :create
before_save :set_password, if: Proc.new { |u| u.password.present? }
private
def set_password
self.encrypted_password = User.encrypt_password(self.password)
end
def self.encrypt_password(password)
Digest::SHA1.hexdigest(password)
end
end

Nu wordt de encrypted_password kolom gevuld met een beveiligde versie van het
wachtwoord. Deze wordt dan opgeslagen in de database. Het password attribuut wordt
hierna vergeten.

In Rails 3.1 zit een handige functie om alles wat je hierboven ziet in één regel te
stoppen:
class User < ActiveRecord::Base
has_secure_password
end

5.11.2 attr_accessible
Deze method is om je database iets meer te beveiligen. Stel je hebt een User Model met een
aantal gegevens die de gebruiker kan invullen. Er zijn echter een paar kolommen waar de
gebruiker niet aan mag komen. Stel we hebben een admin kolom waarin staat of de
gebruiker een admin is of niet. We willen natuurlijk niet dat de gebruiker dit kan
aanpassen. Hiervoor hebben we attr_accessible.

113 - Instappen in Ruby on Rails 3 - Robin Brouwer

In Rails kun je een heleboel parameters meegeven aan de ‘new’ en ‘update_attributes’
method. Deze gebruik je om alle gegevens uit een formulier op te slaan. Het ziet er dan
ongeveer als volgt uit:

User.new(params[:user])

De params variabele is een Hash die je in de Controller en View kunt aanspreken om alle
GET en POST variabelen aan te spreken. In de :user key zit dan alles wat de gebruiker
heeft ingevuld in het formulier. Door deze aan de new (of update_attributes) method mee
te geven worden al deze gegevens in de Model gestopt. Een heel erg handige manier om
veel gegevens in één keer te verwerken. De gebruiker kan echter zo gemeen zijn door ook
een admin parameter in deze user parameter te stoppen. Rails zal automatisch ook deze
admin attribuut vullen met de desbetreffende parameter. En dan is de gebruiker opeens
een admin. Dat wil je natuurlijk niet.
Je kunt aan de attr_accessible method meegeven welke attributen allemaal mogen worden
aangepast als ze worden meegegeven aan new of update_attributes. Je kunt deze
attributen dan nog wel veranderen door ze individueel aan te spreken.

class User < ActiveRecord::Base
attr_accessible :name, :password, :email
end

Als er dan toch een keer iemand is die een admin parameter meestuurt, dan blijft deze
leeg en gebeurt er niks mee. Om alle attributen niet veranderbaar te maken via new en
update_attributes kun je het volgende doen:

class User < ActiveRecord::Base
attr_accessible :none
end

Dan kun je de twee methods niet meer gebruiken. Er verandert namelijk niks meer als je
deze methods aanspreekt. Je krijgt geen foutmelding of iets dergelijks. De data wordt
simpelweg niet aangepast.

114 - Instappen in Ruby on Rails 3 - Robin Brouwer

In Rails 3.1 kun je ook een rol meegeven aan attr_accessible. Een admin mag bijvoorbeeld meer attributen aanpassen dan een gewone gebruiker. In Rails 3.0 kon
dit niet zomaar. In Rails 3.1 dus wel.
attr_accessible :name, :password, :email
attr_accessible :all, as: :admin
User.new(params[:user], as: :admin)

5.12 Samenvatting
De Model in Ruby on Rails is ontzettend handig om mee te werken. Het zorgt ervoor dat
je op een veel gemakkelijkere manier kunt communiceren met de database. Het leggen van
relaties is erg simpel en het valideren van bepaalde attributen krijg je ook in een paar
regels voor elkaar. Hiernaast zijn er genoeg andere handige dingen die je kunt doen in de
Model.
Misschien is het je opgevallen dat bijna alle voorbeelden erg kort waren. Dit is iets wat je
een stuk vaker zult tegenkomen in Ruby on Rails. Je krijgt in Rails echt heel veel voor
elkaar met heel weinig code. Vooral in de Model heeft het ‘Rails core team’ dit goed
uitgewerkt.
Als het goed is begrijp je nu de basis van de M in MVC. Er is nog genoeg extra te leren
over de Model, dus duik in de API en lees het Model gedeelte van de Ruby on Rails guide
door. Maak een aantal relaties aan, voeg wat validatie en callbacks toe en ga ermee spelen.
Als je denkt dat je genoeg weet kun je verder naar het volgende gedeelte: de View.
Hier nog een keer op een rijtje wat je allemaal hebt geleerd:
- De naamgeving conventies van de Model;
- Hoe je een nieuwe Model kunt aanmaken;
- Hoe de versie beheer van een Rails database werkt;
- Hoe je seed-data kunt toevoegen;
- Hoe je data via een Model kan manipuleren;
- Wat voor Rails scopes er zijn;
- Hoe je een scope kunt maken;
- Hoe je validatie kunt toevoegen op Model niveau;
- Hoe je callbacks kunt gebruiken;
- Hoe je relaties legt tussen Models en wat voor soorten relaties er zijn;
- Wat attr_accessor en attr_accessible voor je kunnen betekenen.

115 - Instappen in Ruby on Rails 3 - Robin Brouwer

6. View
Voordat we echt met de V in MVC bezig kunnen gaan zal ik eerst de basis uitleggen van
de Controller. Je hebt namelijk een Controller nodig om met Views te werken. In het
volgende hoofdstuk ga ik een stuk dieper in op de Controller.

6.1 Controller aanmaken
Het eerste wat we moeten doen is de Controller aanmaken. Dit doe je weer met een rails
script in de terminal.
rails g controller posts

Nu wordt er in de /app/controllers map een bestand aangemaakt genaamd
‘posts_controller.rb’. Ook wordt er een nieuwe map onder /app/views aangemaakt
genaamd ‘posts’. Hier komen alle views voor de Posts Controller.

In Rails 3.1 wordt er ook een JavaScript en CSS bestand gemaakt per Controller.
Dit wordt gedaan om ook je JavaScript en CSS zoveel mogelijk te scheiden.

Maar wat zit er precies in een Controller? Een lege Controller ziet er als volgt uit:
class PostsController < ApplicationController
end

Zoals je ziet wordt er geërfd van ApplicationController. Dit is de Controller voor de gehele
applicatie. Hier in het volgende hoofdstuk meer over. Het eerste wat je moet begrijpen in
de Controller zijn de zogenaamde ‘actions’. Dit zijn publieke methods in de Controller.
class PostsController < ApplicationController
def index
...
end
end

Dit is de index actie van de Controller. Dit is de actie die wordt uitgevoerd als je naar de
root van de Controller gaat in de browser:
116 - Instappen in Ruby on Rails 3 - Robin Brouwer

http://localhost:3000/posts

Als je dan bijvoorbeeld een ‘new’ actie zou maken kun je deze benaderen met de volgende
url:

http://localhost:3000/posts/new

In het Routing hoofdstuk ga ik een stuk dieper in op hoe de routing in Rails werkt. Je
krijgt namelijk niet zomaar van die mooie RESTful url’s.
Als de index actie wordt uitgevoerd zoekt Rails automatisch naar een bepaalde view in
de /posts map. Dit bestand is ‘index.html.erb’. De .erb extensie staat voor ‘Embedded
Ruby’ en houdt in dat je in de HTML Ruby kan insluiten. Rails zoekt automatisch naar
dezelfde naam als de actie die is uitgevoerd.
In Rails zijn er in totaal 7 standaard acties. Dit zijn ‘index’, ‘show’, ‘new’, ‘edit’, ‘create’,
‘update’ en ‘destroy’. In het volgende hoofdstuk leg ik uit hoe je deze acties moet
aanmaken.
De naamgeving van een View is ook vrij belangrijk. Deze moet hetzelfde zijn als de
desbetreffende Controller actie, mag alleen kleine letters bevatten en spaties moeten
worden vervangen door liggende streepjes. Voor de rest zijn er niet echt regels qua
naamgeving voor Views.
Wat nog belangrijk is voordat we met de Views bezig gaan is hoe je een variabele van de
Controller naar de View krijgt. Je kunt namelijk niet een lokale variabele in de Controller
aanmaken en deze aanspreken in de View. Je gebruikt hiervoor een instance variabele die
je aanmaakt in de Controller. Een ‘best-practice’ in Rails is om bijna alle Model-calls in de
Controller te doen en deze door te geven aan de View.
In de index actie zouden we alle posts willen ophalen. Deze stoppen we in een instance
variabele.

class PostsController < ApplicationController
def index
@posts = Post.order("id DESC")
end
end

117 - Instappen in Ruby on Rails 3 - Robin Brouwer

Omdat we meerdere posts ophalen is de variabele in het meervoud geschreven. Als we nu
een ‘index.html.erb’ bestand aanmaken in /app/views/posts, dan wordt deze view
getoond in de browser. Zet er maar ‘Hello World!’ in. Voordat we het resultaat kunnen
zien moeten we nog één ding toevoegen aan het routes.rb bestand in de /conﬁg map. Ik
ga hier niet verder op in, want dit zal ik allemaal in het Routing hoofdstuk behandelen.
Voeg het volgende toe:

MyApp::Application.routes.draw do
resources :posts
end

Nu kun je de server starten met ‘rails s’ en naar de volgende url afreizen:

http://localhost:3000/posts

Je ziet dan als het goed is ‘Hello World!’ staan. Gefeliciteerd, je hebt je eerste View
gemaakt. We kunnen nu verder met het echte werk.

6.2 Ruby tags
Je kunt de @posts variabele die je hebt aangemaakt in de Controller in de View
aanspreken. Maar hoe kun je Ruby uitvoeren in een HTML document? Hiervoor zijn de
speciale Ruby tags beschikbaar in bestanden met de .erb extensie.
De eerste Ruby tag is:

<% ... %>

Met deze tag kun je Ruby code uitvoeren zonder iets te laten zien aan de gebruiker. Om
het resultaat van de Ruby code te laten zien kun je de volgende Ruby tag gebruiken:

<%= ... %>

Met het is-teken kun je het resultaat laten zien in de View. Nu kunnen we door de @posts
variabele heenlopen en elk resultaat laten zien.

118 - Instappen in Ruby on Rails 3 - Robin Brouwer

<ul>
<% @posts.each do |post| %>
<li><%= post.title %></li>
<% end %>
</ul>

Nu worden alle titels in <li> tags gestopt. Bij de loop willen we het resultaat niet zien en is
er dus geen is-teken. We willen wel de titel laten zien en daarom gebruiken we hier wel
een is-teken in de Ruby-tag.
Om een Ruby comment in de View te stoppen kun je de volgende Ruby tag gebruiken:

<%# Commentaar %>

Dit is commentaar in de View die de gebruiker ook niet krijgt te zien. Het is niet te zien in
de HTML die gegenereerd wordt.
Een belangrijke vernieuwing in Rails 3 is hoe de Ruby tags werken in combinatie met
blocks. Eerst werkte het als volgt als je een <div> tag wilde toevoegen via een zogenaamde
‘Rails helper’:

<% content_tag(:div) do %>
Ik zit in een div!
<% end %>

Als je dit in Rails 3 doet krijg je in de log het volgende bericht te zien:

DEPRECATION WARNING: <% %> style block helpers are deprecated.
Please use <%= %>.

Een block helper is een functie waar je een blok tekst (Ruby, HTML, gewone tekst, etc.) aan
kunt meegeven door het tussen ‘do’ en ‘end’ te zetten. Hier kun je in de functie
verschillende dingen mee doen, zoals het ervoor zorgen dat het tussen <div> tags komt te
staan.
Als je in Rails 3 een block helper gebruikt moet je het is-teken gebruiken. Eigenlijk ook best
logisch, want je wilt het resultaat ook daadwerkelijk zien. In het voorbeeld van hierboven
willen we <div> tags laten zien. Het werkt nu als volgt:

119 - Instappen in Ruby on Rails 3 - Robin Brouwer

<%= content_tag(:div) do %>
Ik zit in een div!
<% end %>

De <% end %> tag hoef je niet met een is-teken te maken. Dit is alleen nodig in de block
helper.
Als je een String in Ruby tags stopt wordt alle HTML die in deze String zit automatisch
omgezet naar HTML entities. Elke < wordt een &lt; en elke > wordt een &gt;. In Rails 2.3
was dit niet zo. Hier moest je het volgende doen om dit voor elkaar te krijgen:

<%= h("<p>Veilig</p>") %>

Als je de ‘h’ wegliet dan zou de HTML worden getoond. Niet handig als de gebruiker
HTML tags zou kunnen toevoegen in een formulier. Als je dan een keer de ‘h’ vergeet
kunnen mensen misbruik maken van deze fout. Daarom staat deze beveiliging in Rails 3
standaard aan. Nu moet je iets extra’s doen om het uit te zetten. Dit kan op twee manieren:

<%= raw("<p>Rauw</p>") %>
<%= "<strong>HTML safe</strong>".html_safe %>

Dit zorgt ervoor dat de HTML in de String wordt gebruikt als HTML en niet wordt
getransformeerd naar HTML entities, zoals ‘&gt;’ en ‘&lt;’. Dit moet je alleen gebruiken als
je 100% zeker weet dat dit niet misbruikt kan worden. De html_safe method kun je op een
String aanroepen. Nadeel hiervan is dat als de String toevallig nil is, je een error krijgt. Je
kunt namelijk geen ‘html_safe’ op een nil object aanroepen. Daarom is in veel gevallen de
raw method net iets handiger. Deze accepteert wel een nil object en geeft geen error. Mijn
vuistregel: html_safe als je 100% zeker weet dat het altijd een String is en voor de rest
gewoon raw gebruiken.

6.3 Layouts
Het is natuurlijk niet handig als je voor elke view opnieuw de <html>, <head> en <body>
tags moet opgeven. Hiervoor zijn de zogenaamde layouts in Rails. In /app/views/layouts
zit een bestand genaamd ‘application.html.erb’. Dit is de layout voor de gehele applicatie.
Een layout is de standaard HTML template voor jouw applicatie. Hierin stop je alle
HTML die statisch is. Als je in de layout kijkt zie je het volgende:

120 - Instappen in Ruby on Rails 3 - Robin Brouwer

<!DOCTYPE html>
<html>
<head>
<title>MyApp</title>
<%= stylesheet_link_tag :all %>
<%= javascript_include_tag :defaults %>
<%= csrf_meta_tag %>
</head>
<body>
<%= yield %>
</body>
</html>

Een simpele HTML layout die gelijk klaar is voor HTML5. Op de plek waar ‘yield’ wordt
uitgevoerd komt de speciﬁeke View HTML. De index.html.erb wordt dus in de yield
gestopt. Ook zie je een paar andere speciale dingen.
De stylesheet_link_tag is een method die je kunt uitvoeren om naar een stylesheet te
linken. De javascript_include_tag kun je gebruiken om hetzelfde te doen met JavaScript.
De csrf_meta_tag zorgt ervoor dat je applicatie een stuk meer beveiligd is tegen Cross-site
request forgery (CSRF). Er komen namelijk een aantal <meta> tags met wat codes die
steeds worden meegestuurd met de formulieren. Dit zorgt ervoor dat mensen
daadwerkelijk jouw formulier moeten invullen om iets toe te voegen aan de database. Ze
kunnen niet (gemakkelijk) van buitenaf vreemde dingen doen. Mijn collega Daniël
Zwijnenburg heeft hier een handig artikel over geschreven.
Invalid Authenticity Token + csrf_meta_tag
http://45north.nl/atoms/posts/314-invalid-authenticity-token-csrf_meta_tag
(TinyURL: http://tinyurl.com/4xdj6w7)

In Rails 3.1 ziet de layout er net iets anders uit. Zo staat er een ‘s’ achter
‘csrf_meta_tag’ en wordt er naar ‘application’ verwezen bij zowel de stylesheet
als javascript helpers. Dit komt omdat het gebruik van assets in Rails 3.1 totaal
op de schop is gegaan.

De application layout geldt voor de gehele applicatie. Als je een layout maakt met
dezelfde naam als een Controller zal deze worden gebruikt voor alle Views van die
Controller. Ook kun je in de Controller opgeven welke layout je wilt gebruiken. Dit kan op
twee manieren:

121 - Instappen in Ruby on Rails 3 - Robin Brouwer

class PostsController < ApplicationController
layout "admin"
end

Nu wordt voor alle acties in de Controller de admin layout gebruikt. Je kunt dit ook per
actie aangeven.

class PostsController < ApplicationController
def index
render(layout: "admin")
end
end

Je kunt er ook voor zorgen dat er geen layout wordt gebruikt.

class PostsController < ApplicationController
def index
render(layout: false)
end
end

Layouts zorgen ervoor dat je alle standaard HTML maar één keer hoeft op te geven. Dit is
een goed voorbeeld van de DRY conventie.

6.4 Rails helpers
Een helper is een method die je kunt gebruiken in de View. Het ‘helpt’ je bij het DRY
houden van je Views en zorgt ervoor dat je Ruby kunt uitvoeren om HTML te genereren.
Rails heeft een aantal standaard helpers die je kunt aanroepen. De drie methods in de
layout zijn ook helpers. Ik zal nu een aantal belangrijke helpers behandelen.

6.4.1 link_to
Elke website is opgebouwd uit een heleboel hyperlinks. In Rails is dit precies hetzelfde en
heb je links nodig om naar andere Controller acties te gaan. Hiervoor zit in Rails een
speciale ‘link_to’ helper waarmee je heel gemakkelijk een link kunt maken.
<%= link_to("Klik hier!", "/posts") %>

De volgende HTML wordt gegenereerd.

122 - Instappen in Ruby on Rails 3 - Robin Brouwer

<a href="/posts">Klik hier!</a>

Het eerste argument dat je meegeeft is de label voor de link. Hierna geef je de url mee.
Hier kan je een gewone String meegeven met een url, maar ook een speciaal Rails pad.

<%= link_to("Klik hier!", posts_path) %>

De posts_path method is een route die gecreëerd is doordat je de resources hebt geplaatst
in routes.rb. Dit is de index actie van de Posts Controller (zie het meervoud: posts_path).
Je kunt dezelfde route ook als volgt maken:

<%= link_to("Klik hier!", :posts) %>

Rails weet automatisch dat er een url voor gemaakt moet worden. Als je naar de ‘show’
actie wilt gaan, dan kun je de volgende link maken:

<%= link_to(post.title, post_path(post)) %>

We hebben hier een post in de lokale variabele post gestopt. De id van deze post is 1 en de
titel is ‘Hello World!’. Je spreekt de post_path (enkelvoud) method aan en geeft het post
object mee. Rails maakt dan de volgende link voor je:

<a href="/posts/1">Hello World!</a>

Hij haalt automatisch de id uit het object en stopt deze in de link. Je kunt ook dit pad
verkorten:

<%= link_to(post.title, post) %>

Je geeft simpelweg het object mee. Rails weet wat hiermee moet gebeuren en dezelfde link
wordt gecreëerd.
Nu je weet hoe je een link kunt maken kunnen we dit in de index View stoppen die we
toenet hebben gemaakt.

123 - Instappen in Ruby on Rails 3 - Robin Brouwer

<ul>
<% @posts.each do |post| %>
<li><%= link_to(post.title, post) %></li>
<% end %>
</ul>

En dan maken we voor nu even snel een show actie aan in de Controller:

class PostsController < ApplicationController
def index
@posts = Post.order("id DESC")
end
def show
@post = Post.find(params[:id])
end
end

Je ziet in de show actie iets speciaals staan. Dit is de ‘params’ variabele. Dit is een Hash die
je bij elke request kunt aanspreken om alle GET en POST variabelen aan te spreken. Zo zit
de id die we meesturen in de :id key. Je kunt de actie aanspreken met de :action key en de
Controller met de :controller key.

params[:controller] 	# => posts
params[:action]	
# => show

Als je nu een show view maakt (show.html.erb) en het volgende erin stopt kun je testen
hoe links werken in Rails:

<p><%= link_to "Terug", :posts %></p>
<h2><%= @post.title %></h2>

Als je nu naar /posts gaat in de browser zie je als het goed is een aantal titels in een lijst
staan (tenminste, als je posts hebt toegevoegd via de console). Als je hierop klikt ga je
automatisch naar de show actie. Hier heb je een terug-knop en de titel van de post.
Links aanmaken in Rails is dus vrij simpel. Het maakt niet uit als je niet veel begrijpt van
al die url’s die we toenet hebben aangemaakt. Hoe de url’s precies werken zal ik in het
Routing hoofdstuk uitleggen.

124 - Instappen in Ruby on Rails 3 - Robin Brouwer

6.4.2 image_tag
De volgende Rails helper is de image_tag. Hiermee kun je <img> tags aanmaken.
Allereerst moet je weten waar al deze beelden moeten worden opgeslagen. In Rails zit er
in de /public map een map genaamd images. Hierin kun je alle beelden stoppen die je wilt
gebruiken voor de applicatie. Om deze beelden in de View te stoppen kun je de image_tag
helper gebruiken.
<%= image_tag("rails.png") %>

Rails kijkt automatisch in de /public/images map als je de image_tag helper gebruikt. Als
je je aan de conventies houdt - en dus alles in de images map plaatst - kun je op een erg
simpele manier beelden toevoegen aan de applicatie. Je hoeft niet het hele pad uit te
schrijven.

In Rails 3.1 is het hele assets gedeelte overhoop gegooid. Alle images moet je nu
in /app/assets/images stoppen. Er zit geen images map meer in /public.

Aan de image_tag helper kun je een aantal extra argumenten meegeven. Deze argumenten
worden vertaald naar HTML attributen.
<%= image_tag("rails.png", title: "Rails logo", class: "rails") %>

Dit genereert de volgende HTML:
<img src="/images/rails.png" title="Rails logo" class="rails" />

De argumenten die je meegeeft na de locatie van het beeld zullen worden omgezet naar
HTML attributen in de <img> tag. Zo kun je ook een width en height meegeven.

6.4.3 stylesheet_link_tag
Als je naar een bepaalde stylesheet wilt linken dan kun je de stylesheet_link_tag helper
gebruiken. In de /public map zit een map genaamd stylesheets. Hier moet je alle CSS
bestanden opslaan. Als je dan de stylesheet_link_tag gebruikt kun je naar deze CSS
bestanden linken.
Stel je hebt een style.css bestand in /public/stylesheets zitten. Je kunt dan het volgende
doen:

125 - Instappen in Ruby on Rails 3 - Robin Brouwer

<%= stylesheet_link_tag("style") %>

Je hoeft geen .css erachter te zetten en ook niet het complete pad. Rails weet - net als bij de
image_tag - dat het bestand in de stylesheets map hoort te zitten.

Bij de stylesheets geldt hetzelfde als bij de images. Deze zijn nu te vinden in de
/app/assets/stylesheets map. Hoe deze worden ingeladen gaat ook totaal anders.
Je hoeft alleen application.css in te laden en kunt vanuit dat bestand bepalen welke
andere stylesheets moeten worden ingeladen.

Als je meerdere stylesheets wilt gebruiken kan dat ook. Je geeft de andere stylesheets dan
als extra argumenten mee.

<%= stylesheet_link_tag("style", "jquery-ui") %>

Nu worden twee stylesheets in de HTML aangeroepen. Als je een heleboel stylesheets hebt
wil je natuurlijk niet alle stylesheets hier opgeven. Gelukkig is dit makkelijk te regelen in
deze helper.

<%= stylesheet_link_tag(:all) %>

Nu worden alle CSS bestanden in de stylesheets map aangeroepen. Als je mappen hebt
binnen de stylesheets map waarin nog meer CSS bestanden zitten kun je het volgende
toevoegen:

<%= stylesheet_link_tag(:all, recursive: true) %>

Nu worden ook alle CSS bestanden in submappen toegevoegd. Je zou nu kunnen denken:
maar wat als ik 10 CSS bestanden heb? Dan worden er per gebruiker 10 HTTP requests
uitgevoerd om de CSS bestanden op te halen. Dat is toch niet handig? Dat klopt helemaal.
Hiervoor kun je in Rails CSS bestanden ‘cachen’.

<%= stylesheet_link_tag(:all, cache: true) %>

126 - Instappen in Ruby on Rails 3 - Robin Brouwer

Als je in production mode zit zal er een ‘all.css’ bestand worden aangemaakt en alleen
deze zal worden aangeroepen in de HTML. Rails voegt alle bestanden samen en stopt
deze in dit bestand. Je kunt dit bestand ook een andere naam geven.

<%= stylesheet_link_tag(:all, cache: "base") %>

Nu zal er een base.css bestand worden aangemaakt.

In Rails 3.1 zal het cachen automatisch gebeuren in production.

Je kunt naast het :cache en :recursive argument ook een :media argument meesturen om de
media attribuut in de <link> tag te veranderen. Deze staat standaard op ‘screen’ als je de
helper gebruikt.

<%= stylesheet_link_tag("print", media: "print") %>

Dit geeft dan de volgende HTML:

<link href="/stylesheets/print.css" media="print" rel="stylesheet"
type="text/css" />

De stylesheet_link_tag is een heel handige manier om stylesheets te koppelen aan de
HTML. Het gaat weer uit van een conventie en als je je hieraan houdt wordt het een stuk
gemakkelijker om stylesheets toe te voegen.

6.4.4 javascript_include_tag
De javascript_include_tag werkt hetzelfde als de stylesheet_link_tag, alleen is het voor
javascripts. Je hoeft geen .js erachter te zetten om het bestanden in te sluiten en Rails gaat
er vanuit dat alle javascripts in de /public/javascripts map worden gezet. Het werkt als
volgt:
<%= javascript_include_tag("application") %>

Nu wordt het application.js bestand aangeroepen. Als je een kijkje neemt in de javascripts
map zie je dat er al een aantal bestanden zijn. Je hebt application.js, rails.js en een paar

127 - Instappen in Ruby on Rails 3 - Robin Brouwer

prototype bestanden. Als je deze allemaal in één keer wilt toevoegen kun je het volgende
doen:

<%= javascript_include_tag(:defaults) %>

Nu worden alle standaard javascripts ingesloten. In Rails wordt het JavaScript framework
Prototype gebruikt om allerlei AJAX requests en dergelijke uit te voeren. In Rails 3 hebben
ze dit een stuk ﬂexibeler gemaakt en je kunt erg gemakkelijk van framework veranderen.
Om bijvoorbeeld jQuery te gebruiken moet je het volgende doen:
1) Bij het aanmaken van een Rails project voeg je het volgende toe:

rails new my_app --skip-prototype

Met --skip-prototype kun je de Prototype bestanden achterwege laten. Als je al een project
hebt kun je alle Prototype bestanden handmatig verwijderen (alles in de javascripts map,
behalve application.js).
2) Maak een rails.js bestand aan en stop het volgende erin: http://github.com/rails/
jquery-ujs/raw/master/src/rails.js. Of zoek naar ‘rails jquery-ujs’ op Google en zoek
naar het rails.js bestand op de Github pagina.
Je kunt ook het volgende uitvoeren in de root van je applicatie als je op een Mac werkt.

curl -L http://github.com/rails/jquery-ujs/raw/master/src/rails.js > public/
javascripts/rails.js

Nu wordt alles automatisch voor je gedaan. Ik heb dit in mijn .bash_proﬁle gestopt als een
alias, zodat ik alleen ‘jquery’ hoef aan te roepen in de root van mijn applicatie.

alias jquery='curl -L http://github.com/rails/jquery-ujs/raw/master/src/
rails.js > public/javascripts/rails.js'

3) Nu kun je of jquery.js toevoegen aan de javascripts map (http://jquery.com) of de
googleapis link ernaartoe toevoegen aan de HTML.
4) Je kunt dan het volgende toevoegen aan /conﬁg/application.rb:

128 - Instappen in Ruby on Rails 3 - Robin Brouwer

config.action_view.javascript_expansions[:defaults] =
%w(jquery rails application)

Als je nu :defaults aanroept worden deze bestanden toegevoegd. Als je jQuery via de
googleapis link wilt toevoegen moet je natuurlijk jquery uit deze conﬁguratie halen. Stop
dan het volgende in het layout bestand:

<%= javascript_include_tag("http://ajax.googleapis.com/ajax/libs/jquery/
1.6.2/jquery.min") %>
<%= javascript_include_tag(:defaults) %>

Als je MooTools wilt gebruiken moet je het rails.js bestand hiervoor zoeken en MooTools
toevoegen.
Als je de JavaScript bestanden wilt cachen kun je dit ook doen. Dit werkt precies hetzelfde
als bij de stylesheet_link_tag. Je kunt ook :all gebruiken en :recursive toevoegen.

Ook het inladen van JavaScript is in Rails 3.1 totaal anders. Alle JavaScript
bestanden zitten in de map /app/assets/javascripts. In production worden alle
JavaScript in één bestand gestopt en gecomprimeerd.
Ook is in Rails 3.1 jQuery het standaard framework geworden. Alles wat je hierboven ziet hoef je dus niet te doen als je met Rails 3.1 werkt. Het omwisselen van
framework is in Rails 3.1 ook een stuk gemakkelijker geworden. Je hoeft alleen
de Gemﬁle aan te passen en ‘bundle install’ uit te voeren.

6.4.5 form_for
De laatste Rails helper die ik zal behandelen is de form_for helper. Dit is een helper om
een formulier mee te maken in Rails. De form_for helper gebruik je alleen als je een
formulier wilt maken voor een Model. Als dit niet het geval is moet je de form_tag helper
gebruiken. Als je hier meer over wilt weten kun je de link hieronder bezoeken.
Rails Form helpers
http://guides.rubyonrails.org/form_helpers.html
(TinyURL: http://tinyurl.com/5z595h)
In de View van de new actie stop je meestal een formulier waarmee je een nieuwe rij in de
tabel kunt aanmaken. Het formulier verwijst naar de create actie. Deze actie zorgt ervoor
dat het object daadwerkelijk wordt opgeslagen. In de edit actie komt hetzelfde formulier,
129 - Instappen in Ruby on Rails 3 - Robin Brouwer

maar dan met ingevulde velden. De update actie wordt dan aangeroepen en de rij wordt
aangepast.
Bij de ‘new’ actie stop je het volgende in de Controller:

class PostsController < ApplicationController
def new
@post = Post.new
end
end

Het formulier ziet er als volgt uit:

<%= form_for(@post) do |f| %>
...
<% end %>

Je geeft aan de form_for helper het Post object mee. Als je de resources hebt gezet in het
routes.rb bestand (heb ik in het kort uitgelegd in het ‘Controller aanmaken’ gedeelte en zal
ik later dieper op ingaan) weet Rails automatisch naar welke actie het formulier moet
worden gestuurd. Rails ziet namelijk dat het object nog niet bestaat in de database en dat
het naar de create actie moet worden gestuurd. Als in @post een bestaande rij zou zitten,
dan weet Rails dat het naar de update actie zou moeten gaan.
De velden voor het formulier maken is erg gemakkelijk. Rails kent een aantal form helpers
waarmee de velden kunnen worden aangemaakt. Deze helpers zorgen er ook gelijk voor
dat als er iets in het attribuut is ingevuld dit gelijk wordt getoond. Hier een voorbeeld:

<%= form_for(@post) do |f| %>
<%= f.text_field(:title) %>
<%= f.text_area(:body) %>
<% end %>

Je hebt een text_ﬁeld helper en een text_area helper. Hier geef je aan mee voor welke
attribuut dit veld is. Als er al iets in het attribuut zit, dan wordt dit veld automatisch
gevuld. Dit is extreem handig voor de edit actie. Je hoeft hiervoor namelijk niks extra’s te
doen om de velden in te vullen met bestaande data.
Naast deze twee form helpers zijn er een aantal andere helpers. Zo heb je ‘select’,
‘check_box’, ‘radio_button’, ‘label’ en ‘submit’. Hoe deze werken kun je in de Rails API
bekijken. De label helper is best handig, omdat de label gelijk wordt gekoppeld aan het
130 - Instappen in Ruby on Rails 3 - Robin Brouwer

veld. Als je er dan op klikt wordt gelijk het veld geselecteerd (zoals het hoort bij
formulieren).

<%= form_for(@post) do |f| %>
<p>
<%= f.label(:title) %><br />
<%= f.text_field(:title) %>
</p>
<p>
<%= f.label(:body) %><br />
<%= f.text_area(:body) %>
</p>
<% end %>

Je kunt na de attribuut ook opgeven wat de label precies wordt.

<%= f.label(:title, "Titel:") %>

Je geeft een String mee en deze zal worden gebruikt voor de label. Rails maakt er
automatisch ‘Title’ en ‘Body’ van als je dit niet opgeeft.
De volgende form helper is de submit helper.

<%= form_for(@post) do |f| %>
<p>
<%= f.label(:title) %><br />
<%= f.text_field(:title) %>
</p>
<p>
<%= f.label(:body) %><br />
<%= f.text_area(:body) %>
</p>
<p><%= f.submit %></p>
<% end %>

De submit helper maakt een submit knop aan. Als hierop wordt geklikt zal het formulier
worden verstuurd. Je kunt aan de submit helper meegeven wat er in de knop moet staan.

<%= f.submit("Verzenden") %>

131 - Instappen in Ruby on Rails 3 - Robin Brouwer

Nu komt er in de submit knop ‘Verzenden’ te staan. Als je niks meegeeft maakt Rails er
iets van op basis van of het object is opgeslagen. Als dit niet zo is zal er ‘Create Post’
komen te staan. Als het object al in de database zit zal er ‘Update Post’ komen te staan. Het
is dus ‘Create’ of ‘Update’ plus de Model naam.
Aan de form_for helper kun je ook extra HTML toevoegen of naar een andere actie
verwijzen. Hiervoor heb je de :url en :html opties.

<%= form_for(@post, url: post_path(@post), html: { multipart: true, id:
"my_form" }) do |f| %>
...
<% end %>

Met de :url optie kun je de actie speciﬁceren waar het formulier naartoe moet worden
gestuurd. De :html optie accepteert een Hash met allerlei extra opties. Zo zorgt de :id optie
ervoor dat er een id attribuut wordt toegevoegd aan de <form> tag. De :multipart optie
zorgt ervoor dat er een extra attribuut komt die ervoor zorgt dat je bestanden kunt
versturen via het formulier. Het versturen van een bestand naar een Rails actie kan met de
ﬁle_ﬁeld helper.

<%= form_for(@post, html: { multipart: true }) do |f| %>
<%= f.file_field(:file) %>
<% end %>

Hoe je precies zo’n bestand kunt uploaden naar de server zal ik een stuk later behandelen.

In Rails 3.1 is het niet meer nodig om ‘multipart’ mee te geven aan het formulier.
Als je ‘ﬁle_ﬁeld’ in het formulier gebruikt zal dit automatisch worden toegevoegd.

Dit waren de meest belangrijke Rails helpers die je kunt gebruiken. Er zijn nog veel meer
helpers die je kunt aanspreken in de Views. Uiteraard is dit allemaal terug te vinden in de
Rails API.

6.5 Custom helpers
De Rails helpers die ik net heb behandeld zijn maar een heel klein gedeelte van alle
helpers die Rails je biedt. Tijdens je Rails loopbaan zul je constant nieuwe Rails helpers
tegenkomen die het bouwen van een applicatie net iets simpeler maken. Ik kom ook nog
steeds tijdens projecten nieuwe Rails helpers tegen waar ik nooit van had gehoord.

132 - Instappen in Ruby on Rails 3 - Robin Brouwer

Als je een keer een bepaalde helper nodig hebt en je kunt niet een soortgelijke helper
vinden in Rails, dan kun je altijd je eigen helper maken. Ook als je een complex stuk
HTML wilt genereren kun je hiervoor een helper maken. Het idee achter helpers is dat je
gemakkelijk dynamische HTML kunt genereren door een Ruby method aan te roepen.
Deze kun je dan in elke View aanroepen, zodat je je niet steeds herhaalt met dezelfde
HTML. Het is één van de wapens die Rails je biedt bij het DRY houden van je code.
Het aanmaken van een helper is vrij simpel. In /app zit een map genaamd helpers. Hierin
komt voor elke Controller een speciaal helper bestand. Zo heb je als het goed is nu
‘posts_helper.rb’ en ‘application_helper.rb’. Als je een bepaalde helper gebruikt voor de
Post Views dan kun je deze in de PostsHelper stoppen. Heb je bepaalde helpers voor je
gehele applicatie dan kun je deze in de ApplicationHelper stoppen. Een helper bestand
ziet er als volgt uit:

module PostsHelper
end

Het is een Module. Zoals ik heb uitgelegd in het ‘Ruby leren’ hoofdstuk is dit een
verzameling aan functies en constanten. Hierin kunnen we dus allerlei methods stoppen.
Dit zijn de helpers.
Stel we willen een soort ‘Lees verder’ knop hebben. Deze willen we niet steeds opnieuw
maken in onze Views. We maken er daarom een helper van.

module PostsHelper
def post_link(path, *args)
link_to("Lees verder", path, *args)
end
end

We hebben nu een helper waar we een pad aan mee kunnen geven en wat argumenten. De
*args parameter die je meegeeft is een gemakkelijke manier om in Ruby een heleboel
argumenten mee te kunnen sturen. Denk aan een :class of :id. Deze worden dan
doorgegeven aan de link_to helper, zodat je nog steeds HTML attributen mee kunt sturen.
Wat nog belangrijk is om te weten is dat alleen de laatste regel van een helper wordt
getoond in de View. Zorg er dus voor dat de laatste regel hetgeen bevat wat je wilt laten
zien.
De helper kunnen we nu in de index View aanspreken:

133 - Instappen in Ruby on Rails 3 - Robin Brouwer

<% @posts.each do |post| %>
<div>
<h1><%= post.title %></h1>
<p>
<%= truncate(post.body, length: 100) %>
<%= post_link(post, class: "read_more") %>
</p>
</div>
<% end %>

De truncate helper is een Rails helper die een String verkort en er drie puntjes (...) achter
zet. Hierna roepen wij onze helper aan om de ‘Lees verder’ link toe te voegen. We geven
de Post mee, zodat Rails weet wat de link moet worden en hierna geven we een class mee.
Je kunt alle *args argumenten ook in een Hash stoppen. Dit doe je als volgt:

module PostsHelper
def args_test(*args)
options = args.extract_options!
options.inspect
end
end

Met extract_options worden de argumenten in een Hash gestopt. Met ‘inspect’ kun je van
bijna elk object een nette String maken. Denk erom dat bij elke helper alleen de laatste
regel wordt getoond in de View. Als ik aan het einde ‘false’ zou neerzetten krijg ik ook
alleen ‘false’ te zien.
Zo simpel is het om een Rails helper te maken. Naast *args is er nog een handige
parameter die je kunt meesturen: &block. Hiermee kun je een block helper maken.

module PostsHelper
def post_div(post, &block)
content_tag(:div, class: "posts", id: "post_#{post.id}", &block)
end
end

Dan kunnen we het volgende doen om automatisch een <div> om elke post te plaatsen.
Elke <div> heeft dan een uniek id.

134 - Instappen in Ruby on Rails 3 - Robin Brouwer

<% @posts.each do |post| %>
<%= post_div(post) do %>
...
<% end %>
<% end %>

Je moet niet vergeten ‘do’ neer te zetten. Dan weet Ruby namelijk dat je een block mee
wilt geven. Voor deze helper is er trouwens al een Rails helper genaamd ‘div_for’:

<% @posts.each do |post| %>
<%= div_for(post) do %>
...
<% end %>
<% end %>

Deze helper doet precies hetzelfde als onze post_div helper. Zo zie je maar weer dat ze
bijna overal aan hebben gedacht in Rails.
Er zijn behoorlijk veel Rails helpers, dus als je een keer iets speciaals nodig hebt kan het zo
zijn dat deze al bestaat. Als je deze niet kunt vinden is het handig om te weten hoe je
custom helpers kunt maken in Rails. Het maakt je code een stuk overzichtelijker en zorgt
ervoor dat je minder herhaalt. De voorbeelden die ik heb laten zien zijn vrij simpel. Je kunt
het natuurlijk zo lastig maken als je wilt.

6.6 Partials
Het laatste belangrijke wat je moet weten over Views is het gebruik van de zogenaamde
partials. Dit zijn stukjes HTML die je opslaat in aparte bestanden. Je gebruikt dit om je
HTML op te delen, DRY te houden en om HTML via AJAX te vervangen.
Ik heb in het Rails helpers gedeelte al laten doorschemeren dat de ‘new’ en ‘edit’ View
eigenlijk precies hetzelfde formulier nodig hebben. De form_for helper zorgt namelijk
automatisch voor de juiste actie en de form helpers krijgen automatisch de juiste data in
de velden. Je hoeft in het edit formulier niet per veld aan te geven wat er in de database
staat. Daarom zou het raar zijn als we hetzelfde formulier twee keer gebruiken voor deze
twee acties. Het is niet volgens de DRY conventie.
Dit is precies waar een partial van pas kan komen. We stoppen het formulier in de partial
en stoppen deze partial in de twee acties. Als er dan iets aangepast moet worden binnen
het formulier hoeven we dit maar één keer te doen en niet twee keer.
Het eerste wat we moeten doen is een partial aanmaken. Een partial heeft altijd een
liggend streepje voor de naam. Als we een form partial aanmaken zal de bestandsnaam
135 - Instappen in Ruby on Rails 3 - Robin Brouwer

‘_form.html.erb’ worden. Deze stop je in /app/views/posts. Het komt in dezelfde map als
alle andere Views. In dit bestand stoppen we dan het formulier die we hebben gemaakt.
De volgende stap is de partial inladen. Dit werkt heel gemakkelijk:

<%= render("form") %>

De partial wordt nu op deze plaats gestopt. Je hoeft niet een liggend streepje te gebruiken.
Rails weet dat je een partial wilt plaatsen, omdat je de render helper aanroept vanuit een
View. Als je bekend bent met oudere versies van Rails valt hier je misschien iets op.
Vroeger moest het namelijk zo (Ruby 1.8 syntax):

<%= render(partial => "form") %>

Dit :partial argument is niet meer nodig. Je kunt het nog wel op deze manier doen! Zorg er
dan wel gelijk voor dat het volgens de Ruby 1.9 Hash syntax is.
Als je een bepaalde variabele wilt sturen naar deze partial kun je het volgende doen:

<%= render("form", post: @post) %>
<%= render(partial: "form", locals: { post: @post }) %>

De bovenste manier is de nieuwe manier en de onderste de oude manier. Je kunt nu de
lokale variabele ‘post’ aanspreken in de partial. Je kunt in de partial de @post variabele
ook aanspreken. Instance variabelen zijn ook te gebruiken in partials. Het is echter een
handige bezigheid om variabelen op deze manier naar de partial te sturen. Anders moet je
in de Views altijd dezelfde instance variabele hebben en is het een stuk minder dynamisch.
Je kunt nog veel meer dingen doen met partials. Hier een voorbeeld:

136 - Instappen in Ruby on Rails 3 - Robin Brouwer

# index.html.erb
<%= render(@posts) %>
# _post.html.erb
<%= div_for(post) do %>
<h1><%= post.title %></h1>
<p>
<% if params[:action] == "index" %>
<%= truncate(post.body, length: 100) %>
<%= post_link(post, class: "read_more") %>
<% else %>
<%= post.body %>
<% end %>
</p>
<% end %>

Door @posts mee te geven aan de render helper wordt automatisch gezocht naar de ‘post’
partial en deze wordt dan voor de gehele Array geplaatst in de index View. Je krijgt
precies hetzelfde resultaat als de each loop die we hebben gebruikt. Het verschil is dat je
nu een partial gebruikt. Elke post wordt in de lokale variabele post gestopt. Deze partial
zouden we dan ook voor de show View kunnen gebruiken.

# show.html.erb
<p><%= link_to("Terug", posts_path) %></p>
<%= render(@post) %>

Nu wordt dezelfde partial gebruikt voor de show actie. Bij de index actie wordt de body
tekst ingekort en een ‘Lees verder’ link toegevoegd. Bij de show actie krijg je de gehele
body tekst te zien. Dit doen we door een check te doen op params[:action]. Deze waarde
kun je ook op een andere manier aanspreken.

action_name 	 	
controller_name	

# => Zelfde als params[:action]
# => Zelfde als params[:controller]

Het gebruik van een partial voor de index en show actie is een handige manier om in de
index en show View hetzelfde te laten zien. Een mooie bijkomstigheid is dat het redelijk
DRY is. Het is ook een handige manier om een stuk gemakkelijker met AJAX te werken.
Als je bijvoorbeeld een post wilt aanpassen met AJAX kun je deze partial gebruiken om
alleen de aangepaste post met AJAX te updaten. Hier vertel ik in het Unobtrusive
JavaScript hoofdstuk meer over.

137 - Instappen in Ruby on Rails 3 - Robin Brouwer

Het verschil tussen partials en helpers is overigens hoeveel HTML je wilt genereren.
Helpers geven meestal een klein beetje HTML terug of een heleboel dynamische HTML
die opgebouwd is uit andere helpers. Bij partials kun je een heel groot stuk HTML ergens
plaatsen. Dit zou je niet in een helper willen doen. Dit maakt je helper bestand erg
onoverzichtelijk. Hiernaast moet je dan ook overal html_safe of raw op moeten aanroepen,
omdat je een Ruby String moet teruggeven.
Partials gebruik je om stukken HTML op te delen, zodat je niet steeds dezelfde HTML
meerdere keren hoeft uit te schrijven. Het zorgt ervoor dat je je aan de DRY conventie kunt
houden en het maakt met AJAX werken een stuk gemakkelijker.

6.7 Haml
Tot nu toe hebben we ‘erb’ gebruikt om Ruby in te sluiten in HTML. Er zijn andere
manieren om Views te generen en eentje daarvan is Haml. Dit is een andere manier van
Views genereren waar je of van houdt of een grote hekel aan hebt. In mijn boek ga ik erb
gebruiken. Simpelweg vanwege het feit dat het merendeel van de Rails community erb
gebruikt en de meeste tutorials hier gebruik van maken. Het is echter handig om te weten
wat Haml is. Misschien bevalt het je zelfs een stuk meer dan erb.
Wat je eerst moet doen is Haml installeren. Stop het volgende in de Gemﬁle van je
applicatie:

gem "haml"

Voer nu het volgende uit in de terminal:

bundle install

De gem wordt geïnstalleerd en je kunt het gebruiken in jouw applicatie. Dit is de manier
om binnen Rails bepaalde gems te gebruiken. Hier in het laatste hoofdstuk meer over.
Haml is vrij gemakkelijk te begrijpen. Het is wel totaal anders dan je misschien gewend
bent. Laat ik maar gelijk een voorbeeld laten zien. Stel we hebben de volgende erb:

138 - Instappen in Ruby on Rails 3 - Robin Brouwer

<div id="posts">
<% @posts.each do |post| %>
<p class="post">
<%= post.title %>
</p>
<% end %>
</div>

Wat je eerst moet doen om de erb om te zetten naar Haml is de ‘.erb’ in de bestandsnaam
veranderen naar ‘.haml’. Als het bestand ‘index.html.erb’ heet wordt dit ‘index.html.haml’.
De HTML omzetten naar Haml is vrij eenvoudig. Om de bovenstaande HTML om te
zetten kun je het volgende doen:

#posts
- @posts.each do |post|
%p.post
= post.title

Scheelt weer een aantal regels. Met tab of een aantal spaties (zoals de Ruby conventie zegt:
2 spatie soft-tabs) kun je aangeven hoe de HTML genest moet worden. Wat ook handig is,
is dat je de tags niet hoeft af te sluiten. Dat regelt Haml voor je. Met een hash (#) kun je een
id meegeven aan een HTML element en met de punt (.) een class. Door een streepje (-) neer
te zetten kun je Ruby code uitvoeren, maar niet laten zien. Met het is-teken (=) laat je het
resultaat daadwerkelijk zien. Dan heb je nog een procent-teken (%) waarmee je de HTML
tag kunt kiezen. Als je dit niet doet wordt er standaard een <div> gemaakt.
Er zijn nog een aantal extra dingen die je kunt leren over Haml. Er zijn ook manieren om
bepaalde dingen te verkorten. Het is al bij al een erg handige manier om templates in
elkaar te zetten. Bekijk deze website voor meer informatie over Haml: http://hamllang.com.
In dit boek ga ik niet dieper in op Haml, dus ik raad je aan om zelf Haml te bekijken en
voor jezelf te bepalen wat je liever wilt gebruiken: Haml of ERB. Ik gebruik Haml en ben
er erg tevreden over. Zeker het proberen waard!

6.8 Samenvatting
De V in MVC zorgt ervoor dat je iets kunt genereren wat naar de browser van de
gebruiker kan worden gestuurd. Het is het visuele gedeelte van je applicatie. Rails kent
veel handige functies om het maken van Views erg gemakkelijk te houden. Helpers en
partials houden je View DRY en de standaard Rails helpers maken je leven een stuk
gemakkelijker. Haml zorgt hiernaast voor een andere manier van templates maken die
voor sommigen een stuk beter en sneller werkt dan ERB.
139 - Instappen in Ruby on Rails 3 - Robin Brouwer

Hier nog een keer op een rijtje wat je allemaal hebt geleerd:
- Hoe je een Controller kunt aanmaken met Views;
- Wat Ruby tags zijn en hoe je deze kunt gebruiken;
- Hoe je een basis layout kunt aanmaken;
- Wat Rails helpers zijn en hoe je deze kunt benutten;
- Hoe je helpers kunt aanmaken;
- Wat partials zijn en hoe je deze kunt gebruiken;
- Een andere manier van templates schrijven met Haml.

140 - Instappen in Ruby on Rails 3 - Robin Brouwer

7. Controller
We zijn alweer bij het laatste gedeelte van MVC aangekomen: de Controller. Hiermee vang
je alle requests van de gebruiker op, zodat je uiteindelijk een View terug kan geven. In het
vorige hoofdstuk heb ik al de basis van de Controller uitgelegd. Wat nog belangrijk is om
te weten is dat een Controller meestal in het meervoud is geschreven. Als je een Post
Model hebt zul je een Posts Controller nodig hebben. De methods binnen deze Controller
zijn altijd met kleine letters geschreven met liggende streepjes in plaats van spaties.
In dit hoofdstuk gaan we dieper in op de Controller en laat ik je zien hoe een Rails CRUD
eruit ziet. Eerst moet je natuurlijk een Controller maken. In het vorige hoofdstuk liet ik dit
al zien. Je kunt echter iets extra’s ermee doen.
rails g controller Posts index show new

Nu wordt er een PostsController aangemaakt met drie lege acties: index, show en new.
Ook worden voor deze acties gelijk een aantal Views aangemaakt.

7.1 Requests afhandelen
Als je naar een bepaalde actie gaat wordt altijd de corresponderende view erbij gezocht.
Het kan echter zo zijn dat je een andere view wilt gebruiken voor een actie of dat je de
gebruiker ergens naar wilt doorverwijzen. Ook zou het zo kunnen zijn dat je XML of JSON
wilt genereren. Dat kan allemaal.

7.1.1 render
Als je een andere View wilt tonen dan de standaard View voor de actie kun je de render
method gebruiken.

def index
@posts = Post.all
render(action: "posts")
end

Nu wordt de posts.html.erb View gebruikt voor de index actie en niet de index.html.erb
View. Je geeft de naam van de actie mee om aan te geven welke View moet worden
getoond. Je hoeft, net als bij de partials, niet op te geven dat het een ‘action’ is. Rails gaat er
vanuit dat je een actie wilt renderen omdat het in de Controller wordt uitgevoerd. Je kunt
het daarom verkorten.

141 - Instappen in Ruby on Rails 3 - Robin Brouwer

def index
@posts = Post.all
render("posts")
end

Dit doet precies hetzelfde en is iets korter. Je kunt hiermee ook een View uit een andere
Controller renderen.

def show
@post = Post.find(params[:id])
render("comments/index")
end

Nu wordt de index View van de Comments Controller getoond.
Het belangrijkste verschil tussen render in de View en render in de Controller is dat de
View een partial wilt inladen en dat de Controller een action verwacht.
Zoals ik al aangaf in het vorige hoofdstuk kun je ook met de render method aangeven of er
een bepaalde layout moet worden getoond.

def show
@post = Post.find(params[:id])
render(layout: "posts")
end

Nu wordt de ‘posts’ layout getoond. Je kunt hier ook aan meegeven dat je geen layout wilt
laten zien. Je geeft dan ‘false’ mee.
Nog iets wat je kunt doen met render is alleen een tekst teruggeven, zonder een View te
renderen.

def show
render(text: "De View voor deze actie bestaat nog niet")
end

De gebruiker krijgt dan alleen deze tekst te zien. Geen layout of View.

142 - Instappen in Ruby on Rails 3 - Robin Brouwer

7.1.2 redirect_to
Als je naar een bepaalde actie wilt verwijzen kun je de redirect_to method gebruiken.
def create
@post = Post.create(params[:post])
redirect_to(@post)
end

Je kunt hier een pad aan meegeven en de gebruiker wordt automatisch naar deze actie
gestuurd. In dit geval geef ik de gecreëerde post mee, waardoor de gebruiker naar de
show actie wordt gestuurd. De redirect_to method doet precies wat het zegt:
doorverwijzen naar een bepaalde actie.
Je kunt hier ook een absoluut pad neerzetten.
def google
redirect_to("http://google.com")
end

Vaak wordt in combinatie met redirect_to iets genaamd ‘ﬂash’ gezet. Dit is niet Flash als in
Adobe Flash. Dit is een bericht die je aan de gebruiker wilt laten zien nadat ze een
bepaalde actie hebben uitgevoerd. Als een bepaald object is aangemaakt of verwijderd wil
je dit misschien aan de gebruiker laten zien. Dit wil je echter maar één keer in beeld
hebben en alleen nadat de actie is uitgevoerd. Hiervoor heb je in Rails de ﬂash Hash.
Hierin kun je een bericht stoppen die maar één keer wordt getoond.
Je moet wel iets speciaals doen. Je zet deze ﬂash namelijk in de Controller en moet het
altijd vóór een redirect doen. Als je dit niet doet zal de ﬂash twee keer worden getoond.
Dit is nou eenmaal de manier waarop de ﬂash Hash werkt. Deze wordt na elke tweede
request geleegd. De redirect_to geldt als één request en als de gebruiker hierna naar een
andere actie gaat is dat de tweede request en is de ﬂash geleegd. Zonder een redirect zal
de ﬂash dus twee keer worden getoond.
Maar hoe werkt de ﬂash nou precies? Je zet het sowieso in de Controller. Je moet hiernaast
altijd een key van de Hash vullen. Deze mag je noemen zoals je wilt. De conventie is
echter om :notice te gebruiken:

143 - Instappen in Ruby on Rails 3 - Robin Brouwer

def create
@post = Post.create(params[:post])
flash[:notice] = "Post is opgeslagen"
redirect_to(@post)
end

Het tonen van het bericht doe je meestal in de layout.

<% if flash[:notice] %>
<p class="notice"><%= flash[:notice] %></p>
<% end %>

Nu wordt een extra <p> tag getoond met een bericht erin als er iets in ﬂash[:notice] zit.
Deze kun je met CSS stijlen en als je wilt kun je ook JavaScript gebruiken om het mooi in
beeld te laten komen. Je kunt geheel zelf bepalen hoe het eruit ziet. Het is een handige
manier om aan de gebruiker te laten zien wat er allemaal gebeurt. Een beetje feedback kan
nooit kwaad.
Als je gelijk de ﬂash[:notice] wilt laten zien - zonder redirect - kun je het volgende doen:

flash.now.notice = "Er is iets fout gegaan"

Dit wordt vaak gebruikt in combinatie met de render method i.p.v. de redirect_to method.
Hier een voorbeeld van een standaard create actie met beide mogelijkheden.

def create
@post = Post.new(params[:post])
if @post.save
flash[:notice] = "Post is opgeslagen"
redirect_to(@post)
else
flash.now.notice = "Er is iets fout gegaan"
render("new")
end
end

In Rails 3 is er een nieuwe manier om de ﬂash te zetten. Aangezien het zo gebonden is aan
de redirect_to hebben ze in Rails 3 het er ook echt aan gekoppeld.

144 - Instappen in Ruby on Rails 3 - Robin Brouwer

def create
@post = Post.create(params[:post])
redirect_to(@post, notice: "Post is opgeslagen")
end

Je geeft de :notice optie mee aan de redirect_to method. Een stuk logischer. Naast
de :notice key kun je ook de :alert key meegeven.

def create
@post = Post.create(params[:post])
redirect_to(@post, alert: "Er is iets fout gegaan")
end

Deze spreek je aan met ‘ﬂash[:alert]’. Om een geheel eigen key te gebruiken kun je
de :ﬂash key meegeven.

def create
@post = Post.create(params[:post])
redirect_to(@post, flash: { info: "Het is gelukt" })
end

Deze kun je, zoals je al verwacht, met ‘ﬂash[:info]’ aanspreken.
Ik heb een plugin gemaakt waarbij je een soort custom ﬂash notiﬁcatie kunt hebben door
middel van Growl notiﬁcaties. Deze plugin heet ‘gritter’ en maakt gebruik van een jQuery
plugin met dezelfde naam. Het werkt iets anders dan ﬂash, maar is wel een stuk
dynamischer. Hiernaast krijg je een mooie Growl notiﬁcatie terug en hoef je niet met CSS
en JavaScript te klooien. De ﬂash notiﬁcatie in deze plugin heet ‘gﬂash’ en werkt erg
gemakkelijk. Hoe dit precies werkt kun je op de Github pagina vinden: https://
github.com/RobinBrouwer/gritter. Ik zal hier aan blijven werken om het nog
gemakkelijker te maken en extra functies toe te voegen.

7.1.3 respond_to
Naast de simpele redirect_to en render methods heb je ook een speciale respond_to
method. Hiermee kun je ook dingen als XML en JSON renderen. Dit kun je in Rails 3 op
twee verschillende manier doen. In de actie of globaal in de Controller.

145 - Instappen in Ruby on Rails 3 - Robin Brouwer

class PostsController < ApplicationController
def index
@posts = Post.all
respond_to do |format|
format.html
format.xml { render(xml: @posts) }
format.json { render(json: @posts) }
end
end
end

In de respond_to block kun je aangeven wat voor soorten views er allemaal moeten
worden gegenereerd. Als je ‘format.html’ aanroept zal er een standaard HTML view
worden gegeneerd. Je kunt ook XML en JSON views maken. Door de render method aan
te roepen en aan te geven wat voor :xml of :json er moet worden gegeneerd zal Rails
automatisch voor alle posts een nette XML of JSON view aanmaken.
Hoe je deze views aanspreekt is ook vrij simpel. Je hebt nu drie verschillende url’s voor
deze actie:

http://localhost:3000/posts
http://localhost:3000/posts.xml
http://localhost:3000/posts.json

Je kunt zoals je ziet erg gemakkelijk XML en JSON views maken. Deze kunnen externe
applicaties dan gebruiken om data uit je applicatie te halen. Je kunt in de respond_to block
ook voor de HTML aangeven wat er moet worden getoond en of er moet worden
verwezen.

class PostsController < ApplicationController
def create
@post = Post.create(params[:post])
respond_to do |format|
format.html { redirect_to(@post) }
format.xml { render(xml: @post) }
format.json { render(json: @post) }
end
end
end

Je kunt tussen de accolades de gewone redirect_to en render methods uitvoeren. Je kunt
ook een custom JSON of XML bestand renderen.
146 - Instappen in Ruby on Rails 3 - Robin Brouwer

class PostsController < ApplicationController
def index
@posts = Post.all
respond_to do |format|
format.html
format.xml { render("posts") }
format.json { render("posts") }
end
end
end

Nu zoekt Rails naar een posts.xml.erb en posts.json.erb bestand bij de views. Deze wordt
dan gebruikt en kun je customizen. Hierin schrijf je XML of JSON en gebruik je Ruby tags
om Ruby code uit te voeren. Dit werkt hetzelfde als bij de HTML views.
Deze manier van respond_to werkte ook al in Rails 2.3. In Rails 3 is er een nieuwe manier
toegevoegd om je Controller net iets netter te maken. Deze werkt als volgt:

class PostsController < ApplicationController
respond_to :html, :xml, :json
def index
@posts = Post.all
respond_with(@posts)
end
def create
@post = Post.create(params[:post])
respond_with(@post, location: @post)
end
end

Je roept bovenaan de Controller de respond_to method aan en geeft aan wat voor views je
allemaal wilt genereren. In de acties geef je met respond_with aan wat je wilt renderen.
Rails maakt dan zo’n format block aan achter de schermen met precies hetzelfde erin als je
kon doen met de oude manier. Bij de create actie wordt ook een locatie meegestuurd.
Hierdoor weet Rails dat er een redirect_to moet komen voor de HTML views.
Je kunt naast het voorbeeld hierboven nog wat extra dingen doen met de respond_to en
respond_with methods. Meer hierover kun je vinden op de volgende link:
What’s New in Edge Rails: Cleaner RESTful Controller w/ respond_with

147 - Instappen in Ruby on Rails 3 - Robin Brouwer

http://ryandaigle.com/articles/2009/8/6/what-s-new-in-edge-rails-cleaner-restfulcontrollers-w-respond_with/
(TinyURL: http://tinyurl.com/yzuqjbg)

7.2 CRUD
De term CRUD staat voor Create Read Update Delete. Een CRUD houdt in dat je iets kunt
aanmaken, uitlezen, aanpassen en verwijderen. Het is een simpele user-interface waarmee
je alle belangrijke dingen kunt doen met een bepaald object. Denk aan ons Post voorbeeld.
Hierbij wil je een post kunnen aanmaken, bekijken, aanpassen en verwijderen. Hier heb je
een aantal Controller acties voor nodig en een aantal views. Als iemand je vraagt een
CRUD te maken moet je denken aan de volgende zeven acties:

index
show
new
edit
create
update
destroy

Dit zijn de standaard acties die je in de Controller stopt. Je kunt ook andere acties in de
Controller stoppen als je wilt. Soms kan het echter zo zijn dat je een actie hebt die eigenlijk
een eigen Controller moet hebben. Denk bijvoorbeeld aan een Users Controller. Het
inloggen zou je in dezelfde Controller kunnen afhandelen door een login actie aan te
maken. Je kunt echter ook een Sessions of Login Controller aanmaken en hier new, create
en destroy te gebruiken. Hierbij is new het formulier, create het inloggen en destroy het
uitloggen.
Ik zal nu alle zeven acties individueel behandelen, inclusief een standaard View per actie.
Belangrijk is weer om de resources op te geven in routes.rb. Anders werkt dit niet.

7.2.1 index
De index actie in een Rails CRUD is de actie waar een overzicht van alle rijen in de
database wordt getoond. Je haalt alle objecten op, loopt hier doorheen en voegt misschien
wat paginanummering toe om het overzichtelijker te maken. De actie in de Controller is
vrij simpel. Je stopt in een instance variabele die in het meervoud is geschreven alle
objecten die gevonden zijn.
def index
@posts = Post.order("id DESC")
end

148 - Instappen in Ruby on Rails 3 - Robin Brouwer

Let hier vooral op dat de variabele in het meervoud is geschreven. Je haalt immers
meerdere posts op. Een simpele View om al deze posts te tonen kan er als volgt uitzien:

<% @posts.each do |post| %>
<%= div_for(post) do %>
<h1><%= link_to(post.title, post) %></h1>
<p><%= truncate(post.body, length: 150) %></h1>
<% end %>
<% end %>

Nu worden alle posts onder elkaar getoond en kun je op de titel klikken. Deze titel brengt
je naar de show actie.
De link naar de index actie ziet er als volgt uit:

http://localhost:3000/posts	

# GET

7.2.2 show
De show actie is om één object te laten zien. Dit is bij een blog de post met de reacties
eronder. Je moet één post ophalen uit de database. Hier gebruik je de ﬁnd method voor. De
id die je zoekt is echter variabel. Je kunt dit niet vastzetten. Gelukkig wordt de id
automatisch in de url gestopt, waardoor we deze kunnen aanspreken.
Bij elke request die je doet zit standaard een ‘params’ variabele die je kunt gebruiken in
zowel de Controller als de View. In deze variabele zit een Hash met allerlei informatie over
de url en de variabelen die zijn meegestuurd. Je kunt hiermee alle GET en POST
variabelen uitlezen. Op de volgende manier kun je de naam van de Controller en actie
halen:
params[:controller]
params[:action]

Op deze manier kunnen we ook de id, van de post die we willen zoeken, aanspreken.
Deze geven we dan mee aan de ﬁnd method.
def show
@post = Post.find(params[:id])
end

149 - Instappen in Ruby on Rails 3 - Robin Brouwer

We zoeken één post, dus de instance variabele is ook in het enkelvoud geschreven. De id
kun je aanspreken met params[:id]. Bij de show actie ziet de link er als volgt uit:

http://localhost:3000/posts/:id	 # GET

Aan het einde van de url staat :id. Hier kun je stoppen wat je wilt. Meestal is dit een cijfer.
Het cijfer aan het einde van de url kun je dan aanspreken in de params Hash met de :id
key, zoals bij het voorbeeld hierboven.
De View die wordt gegenereerd bij een show actie kan er als volgt uitzien:

<p><%= link_to("Terug", :posts) %></p>
<%= div_for(@post) do %>
<h1><%= @post.title %></h1>
<p><%= @post.body %></h1>
<% end %>

Er wordt één post getoond en er is een terugknop die naar de index-actie gaat.

7.2.3 new
De new actie is om een formulier te laten zien om een nieuw object aan te maken. Dit is
een niet-ingevuld formulier met een submit-knop die naar de create actie verwijst. In de
Controller moet je een nieuwe instantie van de desbetreffende Model aanmaken die je
gebruikt in het formulier.
def new
@post = Post.new
end

In ons geval is dat de Post Model. We stoppen dit weer in een instance variabele die in het
enkelvoud is geschreven. We willen immers slechts één object opslaan.
De View van een new actie kan er als volgt uitzien:

150 - Instappen in Ruby on Rails 3 - Robin Brouwer

<p><%= link_to("Terug", :posts) %></p>
<%= form_for(@post) do |f| %>
<p>
<%= f.label(:title) %><br />
<%= f.text_field(:title) %>
</p>
<p>
<%= f.label(:body) %><br />
<%= f.text_area(:body) %>
</p>
<p><%= f.submit %></p>
<% end %>

Dit is een simpel formulier voor de @post variabele. Rails zorgt ervoor dat naar de juiste
actie wordt verwezen.
De link naar deze actie ziet er als volgt uit:

http://localhost:3000/posts/new	 # GET

7.2.4 edit
De edit actie is ook een formulier voor één object. Het verschil met de new actie is dat hier
een bestaand object wordt aangepast. In de Controller moet je eerst dit object opzoeken.
Dit werkt precies hetzelfde als bij de show actie.
def edit
@post = Post.find(params[:id])
end

We zoeken de post en stoppen deze in een instance variabele die in het enkelvoud is
geschreven. De View hiervoor ziet er precies hetzelfde uit als de new actie. Het is daarom
aan te raden om beide formulieren in een partial te stoppen en deze aan te roepen in de
views. Deze partial wordt meestal ‘form’ genoemd.
De link naar deze actie ziet er als volgt uit:
http://localhost:3000/posts/:id/edit 	 # GET

151 - Instappen in Ruby on Rails 3 - Robin Brouwer

7.2.5 create
De create actie is de actie waar het formulier van de new actie naartoe wordt gestuurd.
Deze actie heeft geen View en redirect meestal naar de show actie.
def create
@post = Post.new(params[:post])
if @post.save
redirect_to(@post, notice: "Post is aangemaakt")
else
render("new")
end
end

Als eerste wordt er een nieuwe instantie van de Post Model aangemaakt en wordt de
POST variabele ‘post’ (aan te spreken met params[:post]) hieraan meegegeven. De
attributen worden automatisch gevuld. De post kan daarom meteen worden opgeslagen
door de save method aan te roepen. Dit moet wel in een if-statement, omdat je de validatie
wilt opvangen. Als het is gelukt wordt er een redirect_to uitgevoerd naar de show actie en
een mooie :notice meegestuurd.
Als het is mislukt wordt de new View opnieuw getoond, zodat je in het formulier kunt
aangeven wat er fout is gegaan. Omdat er in de @post variabele hetzelfde zit als in het
formulier die je hebt verstuurd, wordt het formulier gevuld en hoeft de gebruiker niet
alles opnieuw in te vullen. Wat Rails ook voor je doet is allemaal <div> tags om labels en
velden stoppen die niet juist zijn ingevuld. Al deze <div> tags hebben de class
‘ﬁeld_with_errors’ en kun je met CSS aanpassen, zodat het veld of de label een rode kleur
krijgt. Ook kun je zelf het errors object aanspreken om door alle fouten heen te gaan.
De link naar deze actie ziet er iets anders uit. Dit is namelijk een actie die alleen aan te
roepen is met de HTTP method POST. Deze kun je alleen aanroepen door een formulier te
versturen.
http://localhost:3000/posts	

# POST

7.2.6 update
Dit is de actie waar het formulier van de edit actie naartoe wordt gestuurd. Ook deze actie
heeft geen View en redirect meestal naar de show actie.

152 - Instappen in Ruby on Rails 3 - Robin Brouwer

def update
@post = Post.find(params[:id])
if @post.update_attributes(params[:post])
redirect_to(@post, notice: "Post is aangepast")
else
render("edit")
end
end

Als eerste wordt er net als bij de edit en show actie gezocht naar het desbetreffende object.
Het formulier stuurt dit mee in de url. Alle parameters om het object aan te passen worden
gestuurd als PUT variabelen. Je kunt deze parameters op dezelfde manier aanspreken als
bij de create actie. Het verschil hier is dat je deze moet meegeven aan de update_attributes
method. Deze leest al deze parameters uit, stopt deze in de kolommen en slaat alles op.
Als dit is gelukt wordt je teruggestuurd naar de show actie en komt in de ﬂash[:notice] een
bericht te staan.
Als het echter is mislukt wordt weer de edit View getoond met alle aanpassingen die je al
had gedaan. Hier kun je dan laten zien wat er fout is gegaan. Ook hier krijg je allemaal
‘ﬁeld_with_errors’ <div> tags om velden en labels heen.
De link naar deze actie is weer wat anders dan je gewend bent. Je kunt deze actie namelijk
alleen aanroepen met de HTTP method PUT. Je moet hier ook een id meegeven. Je past
immers één rij in de tabel aan.

http://localhost:3000/posts/:id

# PUT

7.2.7 destroy
De laatste CRUD actie is om objecten te verwijderen. Dit is de destroy actie. Let op: het is
geen delete. De HTTP method die je gebruikt heet delete. De actie heet destroy.
def destroy
@post = Post.find(params[:id])
@post.destroy
redirect_to(:posts, notice: "Post is verwijderd")
end

Eerst wordt het object opgezocht met de id die wordt meegestuurd. Hierna wordt de
destroy method op het object aangeroepen. Je kunt hier ook delete op aanroepen, maar
dan worden callbacks en dat soort dingen genegeerd en wordt er gelijk SQL uitgevoerd.
Hierna wordt je teruggestuurd naar de index actie. Er is geen object meer, dus je kunt niet
153 - Instappen in Ruby on Rails 3 - Robin Brouwer

naar de show actie gaan. Ook voor deze actie is geen View nodig. Je wordt altijd
doorverwezen naar de index actie.
Zoals ik al aangaf gebruik je voor deze actie de HTTP method delete. De link is hetzelfde
als voor de show en update actie.

http://locahost:3000/posts/:id

# DELETE

En dat is hoe je een CRUD maakt in Ruby on Rails. Dit zijn de zeven standaard acties die
je enorm vaak zult gebruiken in alle Controllers die je aanmaakt. Soms gebruik je maar een
paar hiervan, maar soms moet je ze echt allemaal gebruiken.
In het volgende hoofdstuk zal ik wat uitleggen over routing in Rails en hierna zal ik een
voorbeeld laten zien van hoe je de kennis die je hebt opgedaan kan bundelen. Ik laat dan
ook stap voor stap zien hoe je een CRUD maakt. Er zijn echter nog een paar dingen die je
moet weten over de Controller, dus blijf nog even in dit hoofdstuk hangen.

7.3 Fat Model, Skinny Controller
Een belangrijke conventie als het om Controllers gaat is de ‘Fat Model, Skinny Controller’
conventie. In het begin kan het behoorlijk verleidelijk zijn om allerlei logica in de
Controller te stoppen. Zo had ik in het begin ook een fase dat ik het uploaden van
bestanden in de Controller regelde. Dit is echter zeker niet aan te raden. Je kunt dit veel
beter in een Model stoppen. Je kunt deze logica dan namelijk ook in de rest van je
applicatie aanroepen, waardoor je code een stuk meer DRY wordt. Daarnaast is de
Controller alleen om een request van de gebruiker op te vangen en iets hiermee doen. Het
is de bedoeling dat je zo min mogelijk code in de Controller stopt en de Model vooral het
werk laat doen.
Als je bijvoorbeeld validatie wilt doen kun je dit in de Controller doen, maar dan zou je dit
twee keer moeten doen in een CRUD: de create en update actie. Daarom zit de validatie in
Rails ook op Model niveau. Dit moedigt aan om dit soort code in de Model te stoppen en
niet in de Controller. Vaak is het zo dat je enkel de zeven CRUD acties in de Controller
stopt en soms een paar extra acties toevoegt om speciale dingen te doen met een object.
Voor de rest is je Controller vrij leeg.
Als je in bijvoorbeeld de index actie een grote query moet maken zou je denken dat het
handig is om het op de volgende manier te doen:

154 - Instappen in Ruby on Rails 3 - Robin Brouwer

def index
@posts = Post.where(draft: false).order(:published_at).limit(10)
.includes(:comments)
end

Maar wat als je precies dezelfde query ergens anders wilt gebruiken? Dan moet je
kopiëren en dat is niet DRY! Dit kun je daarom beter in de Model regelen door middel van
een scope.

class Post < ActiveRecord::Base
scope :new_posts, where(draft: false).order(:published_at).limit(10)
.includes(:comments)
end

Nu kun je deze scope aanroepen in de gehele applicatie. Als er iets aan moet worden
aangepast hoeft dit maar op één plek.

def index
@posts = Post.new_posts
end

Sommigen vinden het zelfs al te veel om een CRUD helemaal uit te schrijven in de
Controller. Ze gebruiken dan een gem als InheritedResources om alle CRUD acties
automatisch aan te maken. Voor nu is het handig als jij dat niet doet en bij de gewone
CRUD Controllers blijft. Daar leer je immers een stuk meer van dan gelijk een gem te
gebruiken.
Deze conventie geldt overigens ook voor de View. Je wilt niet te veel code in de View
stoppen. Als dit wel gebeurt moet je vaak een partial of helper maken. Soms is het ook
handig om deze code in de Model te stoppen. Hier een klein voorbeeld:

<%= @user.first_name %> <%= @user.last_name %>

Dit is een View waarbij je de voor- en achternaam van een gebruiker laat zien. Het is
echter niet echt handig. Wat als er later ook een tussenvoegsel bijkomt? Dan moet je dit in
alle views aanpassen. Een oplossing is om dit in een helper te stoppen. Dit is echter niet de
beste oplossing. De data wordt namelijk uit de Model gehaald en daarom zou het
handiger zijn om ook de volledige naam uit de Model te halen.

155 - Instappen in Ruby on Rails 3 - Robin Brouwer

class User < ActiveRecord::Base
def name
"#{first_name} #{last_name}"
end
end

Nu kunnen we deze method aanroepen in de View:

<%= @user.name %>

We hebben nu precies hetzelfde effect en hebben de View wat opgeschoond. Het handige
hieraan is dat je deze naam nu ook kunt aanroepen in de Controller of in een mail. Kijk
altijd kritisch naar je code en bepaal wanneer iets naar de Model kan worden verplaatst.

7.4 Sessions
Als een gebruiker op jouw systeem inlogt wil je natuurlijk onthouden wie er is ingelogd
gedurende de sessie. Dit wil je opslaan in een cookie in de browser van de gebruiker. Als
de gebruiker door je site heengaat moet deze cookie bewaard blijven en wil je deze kunnen
aanspreken. Zo weet je op elk moment wie er is ingelogd en kun je bepaalde zaken wel of
niet laten zien. In Ruby on Rails heb je een gemakkelijke manier om deze sessies aan te
maken. Je gebruikt hier een speciaal cookie voor: een session. Deze cookie wordt
automatisch verwijderd als de browser wordt afgesloten en bestaat alleen gedurende de
sessie van de gebruiker. Je kunt hier van alles in opslaan. Meestal sla je hier de id van de
gebruiker in op.
Als je echter wilt dat de cookie bewaard blijft na het afsluiten moet je de gewone cookies
gebruiken in Rails. Hier moet je wel wat extra dingen mee doen. Ik zal in dit boek alleen
ingaan op sessions. Als je meer wilt weten over cookies kun je de volgende link bekijken.
Sessions and cookies in Ruby on Rails
http://www.quarkruby.com/2007/10/21/sessions-and-cookies-in-ruby-on-rails
(TinyURL: http://tinyurl.com/38ny8de)
Een sessie maken in Ruby on Rails is vrij simpel. Stel we hebben een SessionsController
waarmee we het in- en uitloggen van gebruikers regelen. Hierbij is de new actie voor het
inlog formulier, de create actie voor het aanmaken van de sessie en de destroy actie voor
het uitloggen. De new en create actie kunnen er als volgt uitzien:

156 - Instappen in Ruby on Rails 3 - Robin Brouwer

class SessionsController < ApplicationController
def new
@user = User.new
end
def create
@user = User.new(params[:user])
if @user.try_to_login
session[:user_id] = @user.id
redirect_to(:root, notice: "Succesvol ingelogd")
else
render("new")
end
end
end

De try_to_login method is een zelfgemaakte method in de Model die kijkt of er mag
worden ingelogd. Voor nu is dat niet belangrijk. Het gaat hier om de sessie die wordt
aangemaakt. Je hebt namelijk in Rails een ‘session’ Hash waarin alle sessies worden
bewaard. Wij stoppen in de :user_id key het id van de gebruiker die net is ingelogd. Deze
kunnen we hierna in bijvoorbeeld de View aanroepen:

<%= session[:user_id] %>

Je krijgt nu een getal terug. Dit is het id van de gebruiker. Je kunt deze dan gebruiken om
de gebruiker op te zoeken in de database en om te kijken wat deze gebruiker wel en niet
mag doen. Je kunt een sessie alleen aanroepen vanuit de Controller en de View. Het is niet
mogelijk om een sessie aan te roepen vanuit de Model.
Als je een sessie wilt verwijderen is het enkel een kwestie van de value op nil zetten.

def destroy
session[:user_id] = nil
redirect_to(:new_session, notice: "Succesvol uitgelogd")
end

Nu zit hier niks meer in en is de gebruiker uitgelogd.
Je kunt sessies voor veel dingen gebruiken binnen een applicatie. Zo kun je onthouden
wat er in een winkelmandje zit bij een webshop en bepaalde ﬁlters op een zoekresultaat
onthouden. Je moet echter opletten dat je niet te veel met sessies doet. Als je een RESTful
applicatie maakt is het de bedoeling dat je niet tot nauwelijks gebruikmaakt van sessies.
157 - Instappen in Ruby on Rails 3 - Robin Brouwer

Veel dingen kun je namelijk ook via de url regelen. Als je bijvoorbeeld een project
management systeem hebt en je wilt onthouden in welk project de gebruiker zit, kun je dit
het beste via de url oplossen in plaats van een sessie. Om de to-do’s van een project te
laten zien kun je bijvoorbeeld de volgende url genereren:

http://localhost:3000/projects/1/todos

Je zit in het project met id 1 en wilt hiervoor de to-do’s hebben. Hoe dit precies moet leg ik
uit in het volgende hoofdstuk. Hetzelfde kun je doen door een sessie te gebruiken. Het is
echter veel handiger om dit soort dingen via de url te regelen en kan ook voor de
gebruiker wat duidelijker zijn. De terugknop in de browser zal dan namelijk een stuk beter
werken.
Hiernaast kan je niet oneindig veel dingen in een sessie stoppen. Er zit een limiet aan. Als
je een sessie nodig hebt moet je ervoor zorgen dat alleen een getal of iets dergelijks wordt
opgeslagen. In ons geval is dit het id van de gebruiker en dus niet het gehele object van de
gebruiker. Bij een winkelmandje kun je ook alleen de id van een bestelling in een sessie
bewaren in plaats van alle producten die worden besteld.

7.5 ApplicationController
Zoals je al hebt opgemerkt erven alle Controllers van één Controller. Dit is de
ApplicationController. Hierin kun je methods stoppen die vanuit alle Controllers aan te
roepen zijn. De ApplicationController wordt automatisch aangemaakt in /app/
controllers. Deze ziet er standaard als volgt uit:

class ApplicationController < ActionController::Base
protect_from_forgery
end

De ‘protect_from_forgery’ method zorgt ervoor dat over de gehele applicatie alle
formulieren een speciale hash moeten meesturen naar een actie. Als bijvoorbeeld de create
actie wordt aangeroepen wordt er gekeken of er een ‘authenticity_token’ wordt
meegestuurd. Als dit niet wordt gedaan of deze klopt niet, dan krijgt de gebruiker een
foutmelding. Het is een manier om je applicatie te beveiligen en ik raad je aan om dit zo te
laten staan. De authenticity_token wordt overigens gegeneerd door de csrf_meta_tag die
in je layout staat.
Wat je onder andere in de ApplicationController kunt stoppen is een method die de
huidige gebruiker zoekt op basis van het id die in de sessie staat. Deze is dan in alle
andere Controllers te gebruiken.

158 - Instappen in Ruby on Rails 3 - Robin Brouwer

class ApplicationController < ActionController::Base
protect_from_forgery
helper_method :current_user
private
def current_user
if session[:user_id].present?
@current_user ||= User.find(session[:user_id])
end
end
end

Let wel op dat je dit als private actie aanmaakt. Je hoeft deze niet vanuit een andere Class
aan te spreken. Hiernaast gebruik ik iets speciaals wat je misschien nog niet hebt gezien.

@current_user ||= User.find(session[:user_id])

De ||= is een manier om iets te cachen. Als je de current_user method voor een tweede
keer aanspreekt wil je niet dat Rails opnieuw een query gaat doen om de gebruiker te
zoeken. Met ||= geef je het huidige object terug als deze al bestaat en stopt iets in de
variabele als deze nog niet bestaat. Als we het nu voor een tweede keer aanroepen geeft de
method @current_user terug, omdat deze al een keer was opgezocht. Let hier wel op dat je
het ook echt in een instance variabele stopt. Anders werkt dit niet.
Een ander ding wat je nog niet bent tegengekomen is de ‘helper_method’.

helper_method :current_user

Zoals ik al aangaf kun je de current_user method in elke Controller gebruiken. Je kunt
deze echter niet in de View gebruiken. Er moet een helper van worden gemaakt. In de
ApplicationController kun je helper_method gebruiken om deze method ook te laten
werken in alle Views. Om nu bijvoorbeeld de naam van de gebruiker te laten zien doe je
het volgende:

<%= current_user.name %>

Nu kun je ook bepaalde knoppen in de View wel of niet laten zien aan de hand van de
gebruiker. Je kunt een heleboel dingen in de ApplicationController stoppen. Let nog wel
159 - Instappen in Ruby on Rails 3 - Robin Brouwer

op de ‘Skinny Controller, Fat Model’ regel! Vaak kun je dingen in de ApplicationController
ook ergens anders kwijt.

7.6 Filters
Nu je weet hoe je sessies kunt gebruiken en wat de ApplicationController allemaal kan is
het handig om te weten hoe ‘ﬁlters’ werken. Dit zijn speciale methods in Controllers die
bepalen welke acties mogen worden uitgevoerd. Stel er is een gebruiker die is ingelogd en
iets wilt doen wat alleen een admin mag doen. Dat wil je natuurlijk niet zomaar laten
gebeuren. Je wilt de gebruiker uit deze acties ﬁlteren. En wat als iemand juist niet is
ingelogd en iets wilt doen wat alleen gebruikers mogen doen die zijn ingelogd. Daar heb je
ook een ﬁlter voor nodig. Dit is de zogenaamde ‘before_ﬁlter’. Deze ﬁlter wordt
uitgevoerd vóór elke actie. Je hebt ook een ‘after_ﬁlter’ en ‘around_ﬁlter’, maar deze zul je
bijna nooit gebruiken en doen wat je zou verwachten.
De before_ﬁlter kun je in elke Controller gebruiken. De before_ﬁlter ﬁltert automatisch alle
acties voor de desbetreffende Controller. Als je de before_ﬁlter in de ApplicationController
stopt kun je alle acties van de hele applicatie ﬁlteren.
Als je een applicatie hebt waar je altijd ingelogd moet zijn is het handig om de ﬁlter in de
ApplicationController te stoppen. De gebruikers mogen de acties in de applicatie namelijk
alleen zien als ze zijn ingelogd. Als je dan extra ﬁlters wilt hebben voor administratoren
kun je dit per Controller regelen. Hier een voorbeeld van een before_ﬁlter die kijkt naar de
current_user method die we net hebben gemaakt.

class ApplicationController < ActionController::Base
before_filter :authorize_user
private
def authorize_user
if current_user.blank?
redirect_to(:new_session, notice: "U moet eerst inloggen")
end
end
end

Bovenaan declareer je welke method een before_ﬁlter is. In deze actie kijk je dan of er een
huidige gebruiker is. Als dit niet zo is wordt de gebruiker naar het inlog formulier
gestuurd. Let op dat je er een private method van maakt.
Je kunt deze before_ﬁlter ook uitzetten voor bepaalde Controllers. Hiervoor gebruik je
‘skip_before_ﬁlter’. Zo willen we de ﬁlter niet gebruiken in onze SessionsController. Hier
moet namelijk ingelogd worden en dat wil je niet onderscheppen.

160 - Instappen in Ruby on Rails 3 - Robin Brouwer

class SessionsController < ApplicationController
skip_before_filter :authorize_user
...
end

Nu zal deze ﬁlter niet worden uitgevoerd in deze Controller. Maar wat als je dit alleen wilt
doen op de new en create actie? Je kunt hiervoor de except en only keys meegeven.

class SessionsController < ApplicationController
skip_before_filter :authorize_user, only: [:new, :create]
skip_before_filter :authorize_user, except: [:destroy]
...
end

De only key zorgt ervoor dat het alleen gebeurt op de desbetreffende acties en de except
key zorgt dat de before_ﬁlter wordt overgeslagen bij alle acties, behalve de opgegeven
acties. Je geeft een Array mee waarin de acties als Symbols zijn geschreven. Ditzelfde kun
je ook doen met een before_ﬁlter.

class PostsController < ApplicationController
before_filter :authorize_admin, except: [:index, :show]
before_filter :allowed_to_view, only: [:show]
end

Zo kun je per Controller speciale ﬁlters maken. Het is een erg handige manier om je
applicatie te beveiligen en ervoor te zorgen dat gebruikers niet op plekken komen waar ze
niet mogen komen.

7.7 Samenvatting
Als het goed is begrijp je nu hoe de basisstructuur van een Rails applicatie in elkaar zit. Je
hebt alle letters in de MVC structuur gehad en bent klaar voor de volgende stap: Routing.
Hier nog op een rijtje wat je in dit hoofdstuk hebt geleerd:
- Hoe je een Controller aanmaakt, inclusief lege acties en views;
- Hoe je requests kunt afhandelen met render, redirect_to en respond_to;
- Hoe een Rails CRUD eruit ziet;
- Wat ‘Fat Model, Skinny Controller’ inhoudt;
- Hoe je sessies kunt aanmaken in Rails;
- Wat je allemaal kunt doen met de ApplicationController;
- Hoe ﬁlters in elkaar zitten en waar je deze voor kunt gebruiken.
161 - Instappen in Ruby on Rails 3 - Robin Brouwer

8. Routing
Voordat een request bij een Controller kan komen moet deze eerst door de routing in Rails
gaan. Dit regel je allemaal in het routes.rb bestand in de /conﬁg map. Ik heb je hier al een
klein voorbeeld van laten zien en zal in dit hoofdstuk een stuk dieper ingaan op hoe dit
precies werkt. Hiernaast komen dingen als een ‘root’ pad, nested routing en namespaces
aan de orde. Er is dus nog genoeg te bespreken!

8.1 Root
Open eerst het routes.rb bestand. Zoals je ziet zitten er veel comments in dit bestand. Deze
comments zijn bedoeld om je uitleg te geven over wat je allemaal met dit bestand kunt
doen. Laat dit maar even zo staan en focus je op de volgende regel:
# root :to => "welcome#index"

Deze comment laat zien hoe je de root van je applicatie kunt zetten. Hiermee kun je naar
een bepaalde Controller verwijzen als de gebruiker op de volgende url komt:
http://localhost:3000/

Zoals je ziet wordt de oude Hash syntax gebruikt. Dat kun je veranderen, maar dat hoeft
natuurlijk niet. Als we bijvoorbeeld naar de PostsController willen verwijzen kunnen we
het volgende doen:
root to: "posts#index"

Nu gaan we naar de index actie van de PostsController. Je geeft eerst de naam van de
Controller op, volgt dit met een hash (#) en geeft hierna de naam van de actie. Als je naar
de new actie van de SessionsController wilt doe je het volgende:
root to: "sessions#new"

Zo gemakkelijk is dat. Het zal echter niet gelijk werken. Je moet namelijk eerst het
index.html bestand uit de /public map verwijderen. Rails kijkt namelijk eerst of er een
index.html bestand is voordat hij naar de routes kijkt. Dit doet Rails overigens met alle
requests. Stel we hebben de volgende request:
162 - Instappen in Ruby on Rails 3 - Robin Brouwer

/images/rails.png

Rails kijkt dan eerst of er een bestand is met deze naam. Dit doet Rails vanaf de /public
map. Als dit bestand er is wordt deze ingeladen. Is deze er echter niet, dan gaat Rails
kijken naar het routes bestand. Hier kan jij regelen wat er moet gebeuren met de request.
Maar wat jij nu moet doen is het index.html bestand verwijderen. Deze hebben we
namelijk niet meer nodig.

8.2 Match
Om een speciﬁeke request op te vangen kun je ‘match’ gebruiken. Je kunt dan
verschillende dingen met deze request doen. In routes.rb staat al het volgende:

# Sample of regular route:
#
match 'products/:id' => 'catalog#view'
# Keep in mind you can assign values other than :controller and :action

Deze route zou ervoor zorgen dat als iemand naar /products/1 gaat naar de view actie
van de CatalogController wordt verwezen. In het vorige hoofdstuk hebben we een
SessionsController gemaakt voor het inloggen. Het zou handig zijn als de gebruiker niet
een vreemde url als /sessions/new krijgt te zien, maar iets als /login.

match 'login' => 'sessions#new'

En dat is alles. Als een gebruiker nu naar /login gaat zal hij/zij worden verwezen naar de
new actie in de SessionsController. Hier wordt overigens de oude Hash syntax gebruikt
omdat de key niet een Symbol is. Het is namelijk een String.
Naast het gelijk meegeven van de locatie kun je ook de :to key gebruiken.

match 'login', to: 'sessions#new'

Nu kun je wel de Ruby 1.9 syntax gebruiken. De :to key is namelijk een Symbol.

8.2.1 redirect
Je kunt ook een echte redirect doen bij een bepaalde request. Dit kun je zowel aan de :to
key meegeven of aan het pijltje.
163 - Instappen in Ruby on Rails 3 - Robin Brouwer

match 'google' => redirect('http://www.google.com')

Nu wordt er gelijk een redirect gedaan naar Google als je naar /google gaat. Je hoeft niet
naar een Controller te verwijzen en hier een redirect_to te stoppen.

8.2.2 parameters
Zoals je in het voorbeeld van Rails zag kun je ook iets speciaals meegeven aan de route. Ze
gaven namelijk een :id mee aan de route. Dit zorgt ervoor dat er iets variabels op die plek
kan staan, die je dan vanuit de Controller kunt aanspreken met params[:id]. Dit zijn
variabele parameters. Zo kunnen we voor een post een speciale route aanmaken:
match 'posts/:year/:month/:day/:id/:title' => 'posts#show'

Nu kan er een request komen zoals dit:
/posts/2011/12/05/20313/zo-doe-je-dat

Deze verwijst door naar de show actie in de PostsController. Je kunt alle data aanroepen in
de params Hash met de desbetreffende keys.
def show
params[:year]
params[:month]
params[:day]
params[:id]
params[:title]
end

#
#
#
#
#

=>
=>
=>
=>
=>

2011
12
05
20313
zo-doe-je-dat

Je kunt helemaal zelf bepalen wat je doet met de variabele keys in de route.

8.2.3 named_routes
Je kunt van een gewone route ook een named_route maken. Dit zorgt ervoor dat je deze
route kunt aanspreken en bijvoorbeeld aan een link_to of redirect_to kunt meegeven.
Laten we onze login route erbij pakken.

164 - Instappen in Ruby on Rails 3 - Robin Brouwer

match 'login', to: 'sessions#new', as: 'login'

Nu kunnen we het aanspreken met de volgende twee methods:

login_path
login_url

# => /login
# => http://localhost:3000/login

Het verschil tussen _path en _url is dat de één relatieve url’s geeft en de ander absolute
url’s. Zoals je ziet kunnen we nu onze zelfgemaakte route in link_to en redirect_to
stoppen. Hier een voorbeeld voor in een link_to helper in een View:

<%= link_to("Inloggen", login_path) %>
<%= link_to("Inloggen", :login) %>

Je kunt dit pad op meerdere manieren meegeven. Zo kun je het pad direct uitschrijven,
maar ook als een Symbol opschrijven. Hier hoef je dan geen _path achter te zetten. Dat
doet Rails voor je. Als je een complexe naam hebt kun je een Array aan Symbols en
objecten meegeven.

# edit_admin_post_comment_path(@post)
<%= link_to("Inloggen", [:edit, :admin, @post, @comment]) %>

Ik gebruik graag deze methode. Het is meestal net iets korter, is wat duidelijker en ziet er
ook wat netter uit.

8.2.4 via
Het laatste wat ik ga behandelen over match is de :via key. Hiermee kan je aangeven welke
HTTP methods worden geaccepteerd. We moeten nog een /logout route maken voor onze
SessionsController en deze mag alleen beschikbaar zijn bij de HTTP method DELETE.
match 'logout', to: 'sessions#destroy', as: 'logout', via: :delete

Nu is deze route alleen beschikbaar als deze wordt aangeroepen met de DELETE method.
Je kunt ook ervoor zorgen dat meerdere HTTP methods zijn toegestaan. Dan geef je een
Array aan de :via key.

165 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je kunt dit soort routes versimpelen met behulp van zogenaamde Verb routes. Deze
zorgen ervoor dat je per HTTP method kan opgeven wat de route is.

get 'login', to: 'sessions#new', as: 'login'
delete 'logout', to: 'sessions#destroy', as: 'logout'

In plaats van match gebruik je de HTTP method. Deze hoef je dan niet op te geven aan
de :via key.

8.3 RESTful resources
Nu het belangrijkste gedeelte van de Routing in Rails: het RESTful maken van je
applicatie. In het eerste hoofdstuk heb ik al uitgelegd wat dit precies inhoudt. Nu zal ik
uitleggen hoe je het voor elkaar krijgt in Rails.

8.3.1 resources
Je gebruikt hiervoor de ‘resources’ method. Hiermee kun je aangeven welke Controller
RESTful routes moet krijgen. Rails doet dan alles voor je om deze routes aan te maken,
inclusief de named_routes. Als je naar het routes.rb bestand kijkt zie je al het volgende:
# Sample resource route (maps HTTP verbs to controller actions
automatically):
#
resources :products

Met dit voorbeeld worden er RESTful routes aangemaakt voor de ProductsController. Dit
kunnen wij ook doen voor onze PostsController.
resources :posts

De routes zien er als volgt uit:
URL	
	
	
/posts	 	
/posts/1		
/posts/new	
/posts/1/edit	
/posts	 	
/posts/1		
/posts/1		

Method
GET
GET
GET
GET
POST
PUT
DELETE

Actie
index
show
new
edit
create
update
destroy

Named route	
	
posts_path	
	
	
post_path(post)	 	
new_post_path	
	
edit_post_path(post)	
posts_path	
	
	
post_path(post)	 	
post_path(post)	 	

166 - Instappen in Ruby on Rails 3 - Robin Brouwer

Afkorting	
:posts
post
[:new, :post]
[:edit, post]
:posts
post
post

Om naar de destroy actie te linken kunnen we het volgende doen:

<%= link_to("Verwijderen", post, method: :delete) %>

Zonder de :method key zou deze link naar de show actie verwijzen. Er wordt nu wel
gebruikgemaakt van JavaScript. Een simpele <a href> kan namelijk alleen de GET method
gebruiken. De JavaScript maakt een formulier en submit deze in de achtergrond. Je kunt
ook de button_to helper gebruiken. Deze maakt een klein formulier en een submit knop.
Hier is geen JavaScript voor nodig. Het enige wat je hier wel moet doen is de submit knop
een stijl geven, zodat het op een link lijkt.

8.3.2 as
Om de routes een andere naam te geven dan /posts kun je de :as key gebruiken.
resources :posts, as: :berichten

Nu zullen alle routes met /berichten beginnen en alle named_routes zullen ook
veranderen. Rails zal wel naar de PostsController verwijzen.

8.3.3 resource
Naast resources heb je ook het enkelvoud: resource. Deze gebruik je als de Controller in
het enkelvoud is geschreven en er geen index actie nodig is. Er wordt met deze method
namelijk geen route aangemaakt voor de index actie.

resource :account

Je krijgt nu alle routes in het enkelvoud en zonder de index route. Je gebruikt deze method
alleen als je geen index actie nodig hebt en alleen individuele objecten wilt aanmaken,
aanpassen of verwijderen.

8.3.4 member en collection
Als je extra acties maakt die afwijken van de standaard CRUD acties moet je deze
deﬁniëren bij de resources method. Om dit te doen moet je een block meegeven aan de
resources. Hierin kun je dan een member of collection toevoegen. Een member is voor
acties waarbij een id nodig is en een collection is voor acties waarbij geen id nodig is. Een
member is als je met één object wilt werken en een collection als je met meerdere objecten
wilt werken.

167 - Instappen in Ruby on Rails 3 - Robin Brouwer

Stel we hebben twee acties bij een TodosController. Een ‘complete’ actie om een to-do af te
vinken en een ‘completed’ actie om alle to-do’s te bekijken die zijn afgevinkt. Hiervoor
moeten we twee nieuwe routes maken.

resources :todos do
collection do
get 'completed'
end
member do
put 'complete'
end
end

Er is nu een extra collection route voor de completed actie die alleen met de HTTP method
GET is aan te spreken. De member route is voor de complete actie en kan alleen met PUT
worden aangesproken. We gebruiken hier PUT omdat je iets aanpast in de database. Je
kunt dit ook nog iets verkorten.

resources :todos do
get 'completed', on: :collection
put 'complete', on: :member
end

Je kunt met de :on key aangeven of het een member of collection is. Het kan handiger zijn
om de andere methode te gebruiken als je veel extra acties hebt. Dan is het gelijk ook wat
meer gestructureerd.

8.3.5 nested resources
Het laatste onderdeel die ik ga behandelen op het gebied van RESTful resources zijn de
nested resources. Dit zijn routes waarbij allerlei Controllers genest zijn in elkaar. Stel je
hebt een TodosController en een CommentsController. Je wilt dat een Comment altijd
geplaatst moet worden op een Todo. Je wilt eigenlijk van dit soort url’s hebben:
http://localhost:3000/todos/1/comments
http://localhost:3000/todos/1/comments/new

Bij de eerste link haal je de comments op voor to-do met id 1. Bij de tweede link krijg je een
formulier om een nieuwe comment te maken voor deze to-do. Dit kan met nested
resources.

168 - Instappen in Ruby on Rails 3 - Robin Brouwer

resources :todos do
resources :comments
end

En dat is alles. Er zullen nu routes worden aangemaakt voor de CommentsController
binnen de TodosController. Deze zien er net iets anders uit.

todo_comments_path	 	
todo_comment_path	
	
new_todo_comment_path	
...

[@todo, :comments]
[@todo, @comment]
[:new, @todo, :comment]

De routes worden iets complexer. Ook zorgt dit ervoor dat je een nieuwe parameter krijgt
in de CommentsController: ‘todo_id’. Deze kun je gebruiken om in de
CommentsController te zoeken naar de to-do.

class CommentsController < ApplicationController
helper_method :current_todo
def index
@comments = current_todo.comments
end
def create
@comment = Comment.new(params[:comment])
@comment.todo = current_todo
...
end
private
def current_todo
@current_todo ||= Todo.find(params[:todo_id])
end
end

Elke keer als je in de CommentsController ‘current_todo’ aanroept heb je de to-do waar de
comment aan gekoppeld moet worden. Zo kun je bijvoorbeeld in de index actie de
comments ophalen via deze to-do, maar ook in de create actie de comment aan de to-do
koppelen.

169 - Instappen in Ruby on Rails 3 - Robin Brouwer

Het nesten van routes kun je zo diep doen als je wilt. Het is echter niet aan te raden, omdat
je dan ontzettend lastige routes krijgt. Je links en redirects zullen er niet bepaald mooi en
overzichtelijk uitzien. Gebruik het dus met mate.

8.4 Namespace
In sommige gevallen wil je de applicatie die je maakt opdelen in meerdere stukken. Een
voorbeeld hiervan is het maken van een admin gedeelte voor de applicatie. Hierin moeten
dezelfde Controllers komen, maar met andere Views en meer mogelijkheden. Dit kan je
niet zomaar in de gewone Controllers stoppen, maar moet je in een apart gedeelte van je
applicatie stoppen. Dit doe je in Rails met behulp van een ‘namespace’. Met een
namespace kun je een nieuw gedeelte in je applicatie maken en deze een bepaalde naam
geven. Hier kun je dan geheel nieuwe Controllers maken en speciale Views en layouts
gebruiken.
Om zo’n namespace te maken moet je naar het routes.rb bestand gaan. Hierin staat al een
voorbeeld van een admin namespace.

# Sample resource route within a namespace:
#
namespace :admin do
#
# Directs /admin/products/* to Admin::ProductsController
#
# (app/controllers/admin/products_controller.rb)
#
resources :products
#
end

Laten we even de overbodige zaken eruit halen zodat het eruitziet als hieronder.

namespace :admin do
end

Je roept de namespace method aan en geeft aan wat de naam wordt. Hierna geef je een
block mee. In deze block kun je alles doen wat je al geleerd hebt in dit hoofdstuk. Het
grote verschil is dat overal ‘admin’ voor komt te staan. Stel we maken een TodosController
in de admin namespace. Dan voegen we het volgende toe:

namespace :admin do
resources :todos
end

Het volgende wordt onder andere gegenereerd:

170 - Instappen in Ruby on Rails 3 - Robin Brouwer

/admin/todos
/admin/todos/1
/admin/todos/new
...

admin_todos_path	
	
admin_todo_path	
	
new_admin_todo_path	
	

[:admin, :todos]
[:admin, todo]
[:new, :admin, :todo]

Overal komt de namespace voor te staan. Je moet ook nog iets extra’s doen om de
Controllers en Views werkend te krijgen. In /app/controllers en /app/views komt een
extra map genaamd ‘admin’. Hierin stop je de Controller bestanden en de View mappen
voor de admin namespace. Voor de TodosController komt er in /app/controllers/admin
een bestand genaamd ‘todos_controller.rb’. In de /app/views/admin map komt een map
genaamd ‘todos’ waarin alle corresponderende Views komen te zitten. Gelukkig hoeft dit
niet handmatig en kunnen we een rails script gebruiken.

rails g controller admin/todos

Je zet de namespace voor de naam van de Controller die je aan wilt maken. Nog iets
anders is de naamgeving van de TodosController class. Neem maar eens een kijkje in het
bestand dat net is aangemaakt.

class Admin::TodosController < ApplicationController
end

Er komt ‘Admin::’ voor te staan. Dit is bij elke Controller in een namespace nodig.
Om een root locatie voor /admin te zetten kun je de root method gebruiken binnen de
namespace.

namespace :admin do
root to: "todos#index"
resources :todos
end

Nu wordt er automatisch naar de index actie van Admin::TodosController verwezen.
Maar wat als je nu een before_ﬁlter wilt maken voor de gehele admin namespace? Je kunt
dit niet in de ApplicationController stoppen. Deze is namelijk voor de gehele applicatie en
niet alleen de namespace. Een handige manier is om een extra Controller aan te maken in
de admin namespace. Ik noem deze meestal ‘BaseController’. Je kunt dit ook een andere
naam geven, zoals ApplicationController. Dit is echter geen Controller voor de gehele
171 - Instappen in Ruby on Rails 3 - Robin Brouwer

applicatie, dus vind ik dat geen goede naam. Iets in de trant van AdminController zou op
zich ook een goede naam zijn. Ik ben echter BaseController gewend, dus zal het ook hierbij
laten.

rails g controller admin/base

Stop dan het volgende in de Controller:

class Admin::BaseController < ApplicationController
before_filter :authorize_admin
private
def authorize_admin
unless current_user.admin?
redirect_to :root, notice: "U mag niet in dit gedeelte komen"
end
end
end

Je kunt ook in plaats van ApplicationController de ActionController::Base overerven.
Vergeet dan niet ‘protect_from_forgery’ aan te roepen. De namespace is dan geheel
gescheiden van de rest van de applicatie. Je bent dan wel de current_user method kwijt.
Deze staat namelijk in de ApplicationController.
Het enige wat je nog moet doen is in de andere namespace Controllers de geërfde Class
veranderen:

class Admin::TodosController < Admin::BaseController

Nu is de BaseController een soort ApplicationController voor de namespace. Vergeet niet
om bij elke nieuwe namespace Controller dit te veranderen! Dit staat namelijk standaard
op ApplicationController.
Nu heb je een nieuw gedeelte om je applicatie in te bouwen. Het werkt voor de rest precies
hetzelfde. Je hoeft nu niet overal in de publiekelijke Controllers before_ﬁlters te stoppen
op admin acties. Dit hoeft alleen in de BaseController van de namespace.

172 - Instappen in Ruby on Rails 3 - Robin Brouwer

Voor zover routing in Ruby on Rails 3. Als je meer wilt weten over de routing in Rails 3
kun je het beste naar het onderstaande artikel kijken. Hierin staat duidelijk uitgelegd wat
je er allemaal mee kunt doen en kom je wat dingen tegen die ik niet heb behandeld.
The Lowdown on Routes in Rails 3
http://www.engineyard.com/blog/2010/the-lowdown-on-routes-in-rails-3/
(TinyURL: http://tinyurl.com/yb6qwm5)

8.5 Samenvatting
Routing in Rails is vrij simpel en toch behoorlijk krachtig. Je kunt er van alles mee en kunt
erg gemakkelijk complexe routes maken. Er is nog ontzettend veel over dit onderwerp te
leren, dus als je meer wilt weten kun je het beste de bovenstaande link bezoeken. Je bent
nu klaar om een simpele applicatie te maken. Dat zullen we dan ook gezamenlijk doen in
het volgende hoofdstuk.
Hier nog op een rijtje wat je in dit hoofdstuk hebt geleerd:
- De root van je applicatie opgeven;
- Met ‘match’ verschillende routes aanmaken;
- Je applicatie RESTful maken met ‘resources’;
- Hoe je namespaces moet gebruiken om je applicatie op te delen.

173 - Instappen in Ruby on Rails 3 - Robin Brouwer

9. Je eerste applicatie
Nu je weet hoe je de MVC structuur kunt gebruiken in Rails 3 en hoe de routing precies in
elkaar zit kunnen we een simpele applicatie maken. Je kunt het my_app voorbeeld waar
we aan hebben gewerkt voor nu vergeten. Dit was om een beetje te spelen met Rails en de
basis uit te leggen. We zullen nu de kennis die je hebt opgedaan bundelen om een kleine
applicatie te maken waarmee je to-do lijstjes kunt maken en beheren. Ik zal hier stap voor
stap doorheen lopen. Als je iets niet begrijpt kun je teruggaan naar een van de vorige
hoofdstukken.
Ik ga natuurlijk niet alles wat ik heb behandeld in deze applicatie stoppen. Ik zal de meest
belangrijke gedeeltes erin proberen te verwerken. Als je klaar bent met dit hoofdstuk kun
je natuurlijk verder werken aan deze applicatie en extra dingen erin stoppen. Dat is geheel
aan jou.

9.1 Rails applicatie maken
Het eerste wat moet gebeuren is het aanmaken van de Rails applicatie. Open de terminal
en ga naar de map waarin je alle applicaties bewaart. Voer dan het volgende uit:
rails new todo_manager -d mysql --skip-prototype

In Rails 3.1 is --skip-prototype niet nodig. jQuery is de standaard library.

Er zal nu een nieuwe Rails applicatie worden gemaakt waarbij de database gebruikmaakt
van MySQL. Als je dit niet wilt en bijvoorbeeld SQLite3 wilt gebruiken kun je ‘-d mysql’
achterwege laten of iets anders invullen. We gebruiken skip-prototype om de Prototype
bestanden achterwege te laten. We gaan in het volgende hoofdstuk namelijk met jQuery
werken, dus is het handig om alvast alle Prototype bestanden te verwijderen.
Het volgende wat we moeten doen is de database aanmaken. Eerst moet je in de terminal
naar de root van je applicatie gaan en ‘bundle install’ uitvoeren.
cd todo_manager
bundle install

174 - Instappen in Ruby on Rails 3 - Robin Brouwer

In Rails 3.1 is het niet nodig om ‘bundle install’ uit te voeren na het creëren van de
applicatie. Dit wordt automatisch voor je gedaan.

Nu zit je in de root van je applicatie en kun je de database aanmaken.

rake db:create

Vergeet niet om in /conﬁg/database.yml de gegevens te veranderen mocht je niet
gebruikmaken van de standaardgegevens. De development database is nu voor je
aangemaakt.

9.2 Model aanmaken en migraten
De volgende stap bij het maken van een Rails applicatie is de database inrichten en de
Models gereed maken. Wij zullen in de applicatie drie Models hebben:

Todo
Comment
User

Voor nu kunnen we ons focussen op de Todo model. Laten we deze eerst aanmaken.

rails g model todo title:string completed:boolean

We maken nu een Model genaamd Todo en een migration bestand waarin alvast een ‘title’
string en ‘completed’ boolean wordt gestopt. Open dit migration bestand.

175 - Instappen in Ruby on Rails 3 - Robin Brouwer

class CreateTodos < ActiveRecord::Migration
def self.up
create_table :todos do |t|
t.string :title
t.boolean :completed
t.timestamps
end
end
def self.down
drop_table :todos
end
end

Je ziet dat het bestand helemaal goed is. We kunnen nu een migration uitvoeren. Voer het
volgende uit in de terminal:

rake db:migrate

Nu hebben we een ‘todos’ tabel in de database waarmee de Todo Model kan
communiceren. Het volgende wat we doen is validatie toevoegen aan de Model en een
simpele callback. Open de Model (/app/models/todo.rb).

class Todo < ActiveRecord::Base
end

We stoppen eerst validatie op de title kolom. Een to-do moet altijd een titel hebben van
minimaal twee tekens.

class Todo < ActiveRecord::Base
validates :title, presence: true, length: { minimum: 2 }
end

De validatie is toegevoegd en we kunnen doorgaan met de callback. De callback die we
gaan maken zal ervoor zorgen dat completed altijd op ‘false’ wordt gezet als de to-do
wordt aangemaakt. Dit zou je overigens ook in de migration kunnen doen door daar een
default mee te geven. Ik doe het alleen nu in de Model omdat ik een callback wil laten
zien.

176 - Instappen in Ruby on Rails 3 - Robin Brouwer

class Todo < ActiveRecord::Base
validates :title, presence: true, length: { minimum: 2 }
before_create :set_completed
private
def set_completed
self.completed = false
true
end
end

We roepen een method genaamd ‘set_completed’ aan net voordat een to-do wordt
aangemaakt. In deze method zetten we de completed kolom op false. Handig om te weten
is dat als de laatste regel van een callback ‘false’ teruggeeft de procedure wordt gestopt.
Als we completed op false zetten geven we ook false terug, waardoor Rails denkt dat het
niet moet worden opgeslagen. Daarom stop ik een extra regel erna met ‘true’ om aan te
geven dat Rails door moet gaan.
Naast een method aanspreken om een callback uit te voeren kunnen we alles op één regel
stoppen door een Procedure aan te maken.

class Todo < ActiveRecord::Base
validates :title, presence: true, length: { minimum: 2 }
before_create Proc.new { |todo| todo.completed = false; true }
end

Let hier weer op dat je geen ‘false’ aan het einde opgeeft. Als je meerdere regels Ruby code
op één regel wilt uitvoeren kun je een puntkomma gebruiken. Hiermee kun je
verschillende regels Ruby scheiden. Zoals je ziet gebruiken we hier ook accolades in plaats
van ‘do’ en ‘end’. Hierdoor kun je een block meegeven op één regel. Handig om te weten.
Nu we een Model hebben aangemaakt en wat validatie hebben toegevoegd kunnen we het
testen in de console. Start deze in de terminal:

rails c

Nu kunnen we een nieuwe to-do toevoegen aan de database.

177 - Instappen in Ruby on Rails 3 - Robin Brouwer

todo = Todo.new
todo.save
# => false
todo.title = "Ruby on Rails boek afmaken"
todo.save
# => true
todo
# => #<Todo id: 1, title: "Ruby on Rails boek afmaken", completed: false>

De to-do wordt zoals je ziet niet opgeslagen als je geen titel meegeeft. Nadat je dit wel hebt
meegeven lukt het wel. Als je dan naar het object kijkt zie je dat completed op false is
gezet. Alles werkt zoals we het willen hebben. We kunnen nu een user-interface bouwen.

9.3 CRUD maken
De volgende stap is het maken van een CRUD voor de Todo Model. Hiervoor hebben we
een TodosController nodig. Laten we deze in de terminal aanmaken:

rails g controller todos

De Controller wordt aangemaakt en er komt een extra map bij de Views te staan. Laten we
beginnen met de index actie. Open de TodosController in /app/controllers.

class TodosController < ApplicationController
end

Als eerste gaan we de index actie erin stoppen.

class TodosController < ApplicationController
def index
@todos = Todo.all
end
end

Alle to-do’s worden opgehaald en in een instance variabele gestopt. Het volgende wat we
kunnen doen is de index view aanmaken. Stop een bestand genaamd ‘index.html.erb’ in
de map /app/views/todos. Hierin kun je de volgende HTML stoppen:

178 - Instappen in Ruby on Rails 3 - Robin Brouwer

<h1>To-do overview</h1>
<div id="todos">
<% @todos.each do |todo| %>
<%= div_for(todo) do %><%= todo.title %><% end %>
<% end %>
</div>

Nu we een overzicht hebben kunnen we de server opstarten en kijken naar het resultaat.
Voordat we dit doen moeten we nog een paar dingen in de routing veranderen. Open /
conﬁg/routes.rb en stop het volgende erin:

TodoManager::Application.routes.draw do
resources :todos
root to: "todos#index"
end

We maken alvast de RESTful routing voor de TodosController en zetten de root van de
applicatie ook naar deze Controller. Verwijder nu het index.html bestand in de /public
map en start de server in de terminal:

rails s

Nu kun je naar het volgende adres afreizen in de browser om het overzicht aan to-do’s te
zien:

http://localhost:3000

Voordat we verder gaan met de overige CRUD acties, gaan we alvast de application layout
klaarmaken voor het volgende hoofdstuk. Ook zullen we een standaard CSS bestand
toevoegen om alles wat mooier te maken. Eerst de application layout in /app/views/
layouts:

179 - Instappen in Ruby on Rails 3 - Robin Brouwer

<!DOCTYPE html>
<html>
<head>
<title>TodoManager</title>
<%= stylesheet_link_tag(:all) %>
<%= javascript_include_tag(:defaults) %>
<%= csrf_meta_tag %>
</head>
<body>
<%= yield %>
</body>
</html>

We veranderen dit naar het volgende:

<!DOCTYPE html>
<html>
<head>
<title>To-Do Manager</title>
<%= stylesheet_link_tag("style") %>
<%= javascript_include_tag("http://ajax.googleapis.com/ajax/libs/jquery/
1.6.2/jquery.min.js") %>
<%= javascript_include_tag("rails", "application") %>
<%= csrf_meta_tag %>
</head>
<body>
<div id="wrapper">
<%= yield %>
</div>
</body>
</html>

We laden jQuery alvast in, veranderen de titel van de pagina, laden style.css in en voegen
een nieuwe <div> toe waarin de Views zullen worden gestopt. Om het rails.js bestand te
genereren kun je de jquery alias aanroepen die ik een paar hoofdstukken terug heb laten
zien. Mocht je deze zijn vergeten kun je het volgende in de terminal uitvoeren:

curl -L http://github.com/rails/jquery-ujs/raw/master/src/rails.js >
public/javascripts/rails.js

180 - Instappen in Ruby on Rails 3 - Robin Brouwer

Het volgende wat we doen is een simpel CSS bestand toevoegen. Stop ‘style.css’ in de
stylesheets map in /public en voeg het volgende hieraan toe:

body {
margin: 0; padding: 0;
font-family: Arial, sans-serif;
background: #ddd;
text-align: center;
}
#wrapper {
width: 800px;
margin: 0 auto;
padding: 25px;
background: #fff;
text-align: left;
}
h1 { margin-top: 0; font-size: 24px; font-weight: normal; }
p { margin-top: 0; }

In Rails 3.1 werkt dit, zoals ik al eerder heb aangegeven, een stuk anders. Er is
een assets map in /app toegevoegd waarin alle stylesheets en javascripts komen te
staan. Ook zit hier standaard een application.css en application.js bestand waarnaar
ook automatisch wordt verwezen in de layout. De jQuery bestanden worden ook
automatisch ingeladen, waardoor dit ook niet nodig is. Het enige wat je moet doen
van het bovenstaande is de CSS toevoegen aan application.css.

Nu kunnen we doorgaan met de CRUD. Laten we eerst de show actie aanmaken in de
Controller.

def show
@todo = Todo.find(params[:id])
end

Het volgende is de show View maken (/app/views/todos/show.html.erb):

<p><%= link_to "&laquo; Back".html_safe, :todos %></p>
<h1><%= @todo.title %></h1>
<p>Completed: <%= @todo.completed ? "YES" : "NO" %></p>

We moeten in de index View nog even links maken van alle to-do’s.
181 - Instappen in Ruby on Rails 3 - Robin Brouwer

...
<%= div_for(todo) do %><%= link_to(todo.title, todo) %><% end %>
...

Nu kun je van de index actie naar de show actie gaan door op de to-do’s te klikken. De
volgende stap is een formulier maken om nieuwe to-do’s te maken. Dit is de new actie.

def new
@todo = Todo.new
end

Hier moeten we ook een View bij maken:

<p><%= link_to("&laquo; Back".html_safe, :todos) %></p>
<%= form_for(@todo) do |f| %>
<p>
<%= f.label(:title, "To-do:") %>
<%= f.text_field(:title) %>
<%= f.submit %>
</p>
<% end %>

Kijk eens aan. We gebruiken dezelfde link om terug te gaan als bij de show View. Laten we
hier een helper van maken. Open /app/helpers/application_helper.rb en stop het
volgende erin:

module ApplicationHelper
def back_to(path)
link_to("&laquo; Back".html_safe, path)
end
end

Nu kun je de back_to helper aanspreken in zowel de new als show Views.

<p><%= back_to(:todos) %></p>

182 - Instappen in Ruby on Rails 3 - Robin Brouwer

Laten we nu een create actie aanmaken in de Controller. Dit is de actie waar het formulier
naartoe wordt gestuurd.

def create
@todo = Todo.new(params[:todo])
if @todo.save
redirect_to(@todo, notice: "To-do has been created.")
else
render("new")
end
end

Als het opslaan is gelukt wordt je naar de show actie verwezen en anders wordt de new
View opnieuw getoond. Er wordt om de label en het veld een <div> met als class
‘ﬁeld_with_errors’ toegevoegd als er iets fout is. Laten we hier CSS voor maken:

.field_with_errors { display: inline; color: red; }

De laatste stap is om een link naar de new actie te maken. Deze link hebben we alleen op
de index pagina nodig. Stop dit aan het einde van index.html.erb:

<p class="new_todo"><%= link_to("Create new To-do", [:new, :todo]) %></p>

Laten we hier gelijk wat CSS voor maken:

.new_todo { margin-top: 24px; }
.new_todo a {
padding: 12px;
background: #777;
color: #fff;
text-decoration: none;
}

Als je nu op deze link klikt kun je een nieuwe to-do aanmaken en opslaan. Het volgende is
een to-do kunnen aanpassen en verwijderen. Dit gaan we vanuit de show View doen. Stop
het volgende aan het einde van deze View:

183 - Instappen in Ruby on Rails 3 - Robin Brouwer

<p>
<%= link_to("Edit To-do", [:edit, @todo]) %> |
<%= link_to("Delete To-do", @todo, method: :delete, confirm: "Are you
sure?") %>
</p>

De destroy actie maken is het makkelijkste, dus laten we dit eerst doen. Stop het volgende
in de Controller:

def destroy
@todo = Todo.find(params[:id])
@todo.destroy
redirect_to(:todos, notice: "To-do has been deleted.")
end

Als je nu op de destroy link klikt zal de to-do worden verwijderd. Eerst krijg je een
JavaScript pop-up te zien die vraagt of je het zeker weet. Hier in het volgende hoofdstuk
meer over.
Laten we nu de edit en update acties in de Controller stoppen. De edit actie is om het
formulier te laten zien en update is waar het formulier naartoe wordt gestuurd.

def edit
@todo = Todo.find(params[:id])
end
def update
@todo = Todo.find(params[:id])
if @todo.update_attributes(params[:todo])
redirect_to(@todo, notice: "To-do has been updated.")
else
render("edit")
end
end

De volgende stap is om de View voor de edit actie te maken.

184 - Instappen in Ruby on Rails 3 - Robin Brouwer

<p><%= back_to(@todo) %></p>
<%= form_for(@todo) do |f| %>
<p>
<%= f.label(:title, "To-do:") %>
<%= f.text_field(:title) %>
<%= f.submit %>
</p>
<% end %>

Het formulier is precies hetzelfde als het formulier bij de new actie. Dit kunnen we
daarom in een partial stoppen. Dit formulier noemen we ‘_form.html.erb’. We stoppen het
formulier erin.

<%= form_for(@todo) do |f| %>
<p>
<%= f.label(:title, "To-do:") %>
<%= f.text_field(:title) %>
<%= f.submit %>
</p>
<% end %>

En roepen deze aan vanuit de new en edit acties:

<%= render("form") %>

En nu kunnen we de to-do’s bekijken, toevoegen, aanpassen en verwijderen. Het enige
wat we nu nog moeten doen is de ﬂash[:notice] laten zien in de application layout.

<% if flash[:notice].present? %>
<div id="flash"><%= flash[:notice] %></div>
<% end %>
<div id="wrapper">
<%= yield %>
</div>

Laten we hier gelijk wat CSS voor maken:

185 - Instappen in Ruby on Rails 3 - Robin Brouwer

#flash {
position: absolute;
width: 100%;
background: #000;
color: #fff;
padding: 10px 0;
font-size: 16px;
}

En om het helemaal gelikt te maken kunnen we wat JavaScript toevoegen in het
application.js bestand:

$(function(){
if ($("#flash").length > 0) {
$("#flash").hide();
$("#flash").fadeIn(1000, function(){
	
setTimeout(fadeOutFlash, 3000);
});
}
function fadeOutFlash() {
$("#flash").fadeOut(1000);
}
});

Nu wordt het bericht met een fade-in getoond en gaat deze na 3 seconden weg met een
fade-out.
We hebben nu een simpele CRUD gemaakt voor de to-do’s in onze applicatie. Er is echter
nog genoeg te doen, dus laten we doorgaan naar het volgende gedeelte.

9.4 To-do’s afvinken
Heel leuk allemaal dat we nu to-do’s kunnen beheren, maar de bedoeling is natuurlijk dat
we to-do’s kunnen afvinken. Hiervoor zullen we een extra actie genaamd ‘complete’
aanmaken in de Controller. Als deze wordt aangeroepen zal de to-do worden afgevinkt.
Hiervoor moeten we een member toevoegen aan de RESTful routing. We gaan immers één
to-do aanpassen en het is niet een standaard CRUD actie. Verander daarom het volgende
in routes.rb:

186 - Instappen in Ruby on Rails 3 - Robin Brouwer

resources :todos do
member do
put "complete"
end
end

Aangezien we een to-do aanpassen gebruiken we de HTTP method PUT. Nu kunnen we
in de Controller deze actie aanmaken:

def complete
@todo = Todo.find(params[:id])
@todo.update_attribute(:completed, true)
redirect_to(@todo, notice: "To-do has been completed.")
end

Nu kunnen we een link aanmaken die de to-do afvinkt. Deze stoppen we voor nu in de
show actie.

<p>
<%= link_to("Complete To-do", [:complete, @todo], method: :put) %> |
<%= link_to("Edit To-do", [:edit, @todo]) %> |
<%= link_to("Delete To-do", @todo, method: :delete, confirm: "Are you
sure?") %>
</p>

Als je nu op die link klikt zal de to-do worden afgevinkt. Als je dit wilt terugdraaien moet
je een nieuwe actie aanmaken. Laten we deze ‘incomplete’ noemen.

resources :todos do
member do
put "complete"
put "incomplete"
end
end

En dan ook een actie in de Controller.

187 - Instappen in Ruby on Rails 3 - Robin Brouwer

def incomplete
@todo = Todo.find(params[:id])
@todo.update_attribute(:completed, false)
redirect_to(@todo, notice: "To-do has been reassigned.")
end

We moeten nu ook de link aanpassen. Hier een simpel voorbeeld met behulp van een ifstatement.

<% if @todo.completed %>
<%= link_to("Reassign To-do", [:incomplete, @todo], method: :put) %> |
<% else %>
<%= link_to("Complete To-do", [:complete, @todo], method: :put) %> |
<% end %>

En nu kunnen we taken afvinken en opnieuw activeren. Het volgende wat we kunnen
doen is bij de index actie sorteren op afgevinkte taken en de afgevinkte taken anders laten
zien. Eerst gaan we een scope maken in de Todo Model.

scope :order_by_completed, order("completed ASC")

Deze scope kunnen we dan aanspreken in de index actie om de to-do’s te sorteren:

def index
@todos = Todo.order_by_completed
end

In de index View kunnen we nu een extra class meegeven als de to-do is afgevinkt.

<% @todos.each do |todo| %>
<%= div_for(todo, class: todo.completed ? "completed" : nil) do %>
<%= link_to(todo.title, todo) %>
<% end %>
<% end %>

Er wordt een extra class aan toegevoegd als de to-do is afgevinkt. Dan kunnen we met CSS
de to-do er anders uit laten zien:

188 - Instappen in Ruby on Rails 3 - Robin Brouwer

.completed {
opacity: 0.5;
}

Nu zie je de to-do’s die zijn afgevinkt iets lichter dan de rest, zodat je duidelijk ziet wat
wel en niet is afgevinkt.
De manier die ik hier heb laten zien is overigens niet de beste manier waarop je het
afvinken van to-do’s voor elkaar kunt krijgen. Je kunt ook alles via de update actie laten
gaan. Je hoeft dan niet extra acties aan te maken. In het volgende hoofdstuk zal ik laten
zien hoe dit werkt in combinatie met JavaScript. Ik wilde je hier laten zien hoe je om moet
gaan met acties die afwijken van de standaard CRUD acties.

9.5 Has many comments
Een simpele to-do is vaak niet genoeg om te vertellen wat er moet gebeuren. Ook wil je zo
nu en dan een status update plaatsen op een to-do, zodat je later precies ziet wat er is
gedaan en wat er nog moet gebeuren. Dit kan je op verschillende manieren voor elkaar
krijgen. Wij gaan dit doen door comments toe te voegen aan een to-do. Een to-do
‘has_many’ comments.
Eerst moeten we een nieuwe Model aanmaken voor de comments die worden geplaatst.
Voer het volgende uit in de terminal:

rails g model comment body:text todo_id:integer

Het migration bestand is al in orde doordat we de kolommen hebben meegegeven, dus
kunnen we gelijk een migratie uitvoeren:

rake db:migrate

Het volgende wat we moeten doen is de relatie aanleggen tussen de twee Models:

189 - Instappen in Ruby on Rails 3 - Robin Brouwer

class Comment < ActiveRecord::Base
belongs_to :todo
end
class Todo < ActiveRecord::Base
has_many :comments
end

Nu dit is gedaan kunnen we de CommentsController toevoegen die ervoor moet zorgen
dat comments kunnen worden geplaatst.

rails g controller comments

Aangezien een comment altijd bij een to-do hoort zullen we gebruikmaken van nested
resources. Verander het volgende bij de routes:

resources :todos do
resources :comments
...
end

Bij de show View van de TodosController willen we de comments laten zien. Laten we dit
met een partial doen. Maak in /app/views/comments een partial genaamd
‘_comment.html.erb’ en stop het volgende erin:

<p>
<strong>Posted on <%= comment.created_at.strftime("%d/%m/%Y") %>:</
strong><br />
<%= comment.body %>
</p>

Nu kunnen we aan het einde in de show View het volgende stoppen:

<%= render(@todo.comments) %>

Alle comments die bij de to-do horen komen daar nu te staan. De volgende stap is om een
formulier te maken waarmee een comment kan worden toegevoegd. Dit zullen we in de

190 - Instappen in Ruby on Rails 3 - Robin Brouwer

show View van de TodosController doen. Eerst zullen we iets extra’s aan de Controller
moeten toevoegen:

def show
@todo = Todo.find(params[:id])
@comment = Comment.new
end

We kunnen dit nu gebruiken om in de show View een formulier te maken.

<%= form_for([@todo, @comment]) do |f| %>
<p>
<%= f.label(:body, "Add a new comment:") %><br />
<%= f.text_area(:body) %>
</p>
<p><%= f.submit %></p>
<% end %>

Deze zal met de HTTP method POST verwijzen naar /todos/:todo_id/comments.
De :todo_id kunnen we aanspreken in de CommentsController, waardoor we de comment
goed kunnen koppelen.

class CommentsController < ApplicationController
def create
@comment = Comment.new(params[:comment])
current_todo.comments << @comment
redirect_to(current_todo, notice: "Comment has been created.")
end
private
def current_todo
@current_todo ||= Todo.find(params[:todo_id])
end
end

We hebben een speciale current_todo method gemaakt om de huidige to-do op te halen.
We voegen de nieuwe comment dan toe aan deze to-do en verwijzen terug naar de show
actie van de TodosController. Nu kun je comments toevoegen aan to-do’s.

191 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je kunt nu de CRUD afmaken, zodat je comments kunt verwijderen en aanpassen. Denk
om de nested resources! Je moet namelijk bij elke url de to-do meegeven om alles goed te
laten werken.

9.6 Gebruikersbeheer
Het volgende wat we in onze applicatie stoppen is gebruikersbeheer. We zullen ervoor
zorgen dat een admin gebruikers kan aanmaken en dat gebruikers dan kunnen inloggen
voor hun eigen to-do lijstjes. De gebruikers krijgen dan alleen de to-do’s te zien die van
hun zijn.
In een redelijk nieuwe railscast op http://railscasts.com wordt er speciaal aandacht
besteed aan gebruikersbeheer. Hierin wordt uitgelegd hoe je een inlog systeem kunt
maken zonder gebruik te maken van een plugin of gem.
Authentication from scratch
http://railscasts.com/episodes/250-authentication-from-scratch
(TinyURL: http://tinyurl.com/5rbttya)

In Rails 3.1 is dit nog gemakkelijker geworden. Toevallig is hier ook een railscast
over gemaakt: http://railscasts.com/episodes/270-authentication-in-rails-3-1.

Wij zullen dit net iets anders aanpakken. Ik raad je aan om na dit hoofdstuk een kijkje te
nemen naar deze railscast om te zien hoe Ryan Bates, die alle railscasts maakt, het doet.

9.6.1 Gebruikers CRUD
Het eerste wat we doen is een CRUD maken voor het beheren van gebruikers. Ik zal
hiervoor een begin maken en ga er vanuit dat je zelf de CRUD kunt afmaken. Eerst moeten
we een User Model hebben.
rails g model user email:string

Open nu het migration bestand.

192 - Instappen in Ruby on Rails 3 - Robin Brouwer

class CreateUsers < ActiveRecord::Migration
def self.up
create_table :users do |t|
t.string :email
t.timestamps
end
end
def self.down
drop_table :users
end
end

We focussen ons op de up method. We zullen naast een e-mailadres ook het wachtwoord
van de gebruiker opslaan en een boolean toevoegen om te kijken of diegene een admin is.
Een wachtwoord kun je natuurlijk niet in een tabel opslaan. Je moet deze eerst veranderen
in een hash. Hiernaast gebruiken we een ‘salt’ om de hash nog beter te beveiligen.

create_table :users do |t|
t.string :email
t.string :password_hash
t.string :password_salt
t.boolean :admin
t.timestamps
end

Een hash is niet zoals de Hash in Ruby. Dit is de encryptie die je kunt uitvoeren op een
String, zoals een wachtwoord. Een salt is een willekeurige String. Als je deze samenvoegt
met het wachtwoord en van dit geheel een hash maakt, krijg je een behoorlijk veilig
opgeslagen wachtwoord.

In Rails 3.1 is er een makkelijkere manier om wachtwoorden op te slaan. Je hoeft
niet de salt in een aparte kolom op te slaan. Noem het veld ‘password_digest’ en
maakt er een String van. Rails zal d.m.v. BCrypt het wachtwoord op een nog
veiligere manier opslaan in alleen deze kolom.

Deze migration kunnen we nu uitvoeren.

193 - Instappen in Ruby on Rails 3 - Robin Brouwer

rake db:migrate

Het volgende wat we moeten doen is de Controller aanmaken voor de CRUD. We doen dit
niet in een gewone Controller, maar in een namespace Controller. We gaan namelijk een
admin namespace maken. Laten we eerst de routes hiervoor goed zetten.

namespace :admin do
root to: "users#index"
resources :users
end

Nu dit is geregeld kunnen we de Controller aanmaken.

rails g controller admin/users

Nu dit is gedaan kunnen we een BaseController toevoegen aan de admin namespace.

rails g controller admin/base

Nu we een BaseController hebben kunnen we de UsersController hiervan laten erven.

class Admin::UsersController < Admin::BaseController
end

Nu kunnen we een CRUD maken voor het beheren van de gebruikers. Voordat we dit
doen moeten we echter nog wat dingen doen in de User Model. We kunnen immers de
admin niet de password_hash laten invullen in een formulier. De admin moet een
wachtwoord invullen en Rails moet hier automatisch een hash voor maken. Hiernaast
willen we gelijk wat validatie eraan toevoegen.

194 - Instappen in Ruby on Rails 3 - Robin Brouwer

class User < ActiveRecord::Base
attr_accessor :password
before_save :encrypt_password
validates_confirmation_of :password
validates_presence_of :password, on: :create
validates :email, presence: true, uniqueness: true
def encrypt_password
if password.present?
self.password_salt = User.generate_salt
self.password_hash = User.hash_secret(password, password_salt)
end
end
private
def self.generate_salt
ActiveSupport::SecureRandom.hex(16)
end
def self.hash_secret(pass, salt)
Digest::SHA1.hexdigest(pass + salt)
end
end

In Rails 3.1 hoef je alleen ‘has_secure_password’ aan te roepen in de Model om hetgeen wat hierboven staat voor elkaar te krijgen. Je moet dan wel een andere kolom
hebben voor het wachtwoord: password_digest. Deze zal dan automatisch worden
gevuld. Wat je hierboven ziet is dus niet meer nodig in Rails 3.1.

Ik zal hier van boven naar beneden doorheen lopen. Als eerste hebben we een
attr_accessor die ervoor zorgt dat er een virtueel attribuut genaamd ‘password’ wordt
aangemaakt. Deze kunnen we gebruiken in formulieren, zodat de gebruiker een
wachtwoord kan invullen. Hierna komt een before_save die een method uitvoert. Deze
method heet ‘encrypt_password’ en zorgt ervoor dat de password_salt en password_hash
wordt gezet. Hier zometeen meer over.
Hierna komt de validatie. Als eerste maken we een virtuele attribuut aan genaamd
‘password_conﬁrmation’ door ‘validates_conﬁrmation_of’ te gebruiken. Hiernaast
checken we altijd bij de create actie of er een wachtwoord is ingevuld en zorgen we ervoor
dat een e-mailadres altijd moet worden ingevuld en uniek moet zijn.

195 - Instappen in Ruby on Rails 3 - Robin Brouwer

De password_salt wordt ingevuld met een class method die ik heb toegevoegd genaamd
‘generate_salt’. Deze maakt een random String van 16 tekens. Er zijn verschillende
manieren om een random String te genereren. Ik gebruik een method die in Rails zelf zit.
Meer hierover op Stack Overﬂow.
How best to generate a random string in Ruby
http://stackoverﬂow.com/questions/88311
(TinyURL: http://tinyurl.com/yzc5bw9)

Toevallig is ActiveSupport::SecureRandom ‘deprecated’ in Rails 3.1. Dit betekent
dat er een waarschuwing wordt gegeven als je dit gebruikt en dat het in een latere
versie zal worden verwijderd. SecureRandom zit namelijk standaard in Ruby 1.9,
waardoor je geen Rails meer nodig hebt om deze functie te gebruiken.

Nadat de salt is gemaakt kunnen we het wachtwoord een hash geven. Hiervoor gebruiken
we een SHA1 hash. Dit is een Ruby Class die je kunt gebruiken. Als je een error krijgt in de
trant van dat Ruby ‘Digest’ niet kan vinden, moet je het volgende boven de Class
neerzetten:

require 'digest/sha1'

Als je Ruby 1.9 gebruikt hoort dit geen probleem te zijn. Zoals je ziet wordt het
wachtwoord samengevoegd met de salt voordat er een hash van wordt gemaakt. En
aangezien dit in een before_save gedaan wordt zal dit ook in de database zo worden
opgeslagen. Wat zijn callbacks toch handig.
Wat we nu wel zijn vergeten is een attr_accessible toevoegen. We willen natuurlijk niet dat
een gebruiker de admin kolom kan aanpassen door het formulier aan te passen. Voeg dit
toe aan de User Model:

attr_accessible :email, :password, :password_confirmation

Nu kunnen alleen het e-mailadres, het wachtwoord en de bevestiging hiervan worden
meegestuurd naar de ‘new’ en ‘update_attributes’ methods.
Nu we de Model klaar hebben kunnen we beginnen aan de UsersController. Ik zal even
snel drie acties hieraan toevoegen.

196 - Instappen in Ruby on Rails 3 - Robin Brouwer

class Admin::UsersController < Admin::BaseController
def index
@users = User.all
end
def new
@user = User.new
end
def create
@user = User.new(params[:user])
if @user.save
redirect_to([:admin, :users], notice: "User has been created.")
else
render("new")
end
end
end

Een vrij standaard begin voor een CRUD. Laten we de Views hiervoor aanmaken. Deze
moeten natuurlijk in de admin namespace worden gestopt. Ik geef bij de hekjes (#) aan in
welke bestanden je de code moet stoppen.

# /app/views/admin/users/index.html.erb
<h1>Users overview</h1>
<div id="users">
<% @users.each do |user| %>
<%= div_for(user) do %>
<%= user.email %>
<% end %>
<% end %>
</div>
<p class="new_user"><%= link_to("Create new User", [:new, :admin, :user])
%></p>

# /app/views/admin/users/new.html.erb
<p><%= back_to([:admin, :users]) %></p>
<%= render("form") %>

197 - Instappen in Ruby on Rails 3 - Robin Brouwer

# /app/views/admin/users/_form.html.erb
<%= form_for([:admin, @user]) do |f| %>
<p>
<%= f.label(:email) %><br />
<%= f.text_field(:email) %>
</p>
<p>
<%= f.label(:password) %><br />
<%= f.password_field(:password) %>
</p>
<p>
<%= f.label(:password_confirmation) %><br />
<%= f.password_field(:password_confirmation) %>
</p>
<p><%= f.submit %></p>
<% end %>

Zoals je ziet wordt bij elke url :admin ervoor gezet. Dit moet omdat we in de admin
namespace zitten. Als je nu de server start en naar de volgende link gaat kun je gebruikers
beheren:

http://localhost:3000/admin

De rest van de CRUD kun je zelf afmaken. Denk erom dat je in een namespace zit.

9.6.2 Inloggen
Nu we een admin gedeelte hebben is het handig om dit gedeelte te beschermen. Er moet
een inlogsysteem komen en alleen de admin mag bij de admin komen. Laten we eerst een
standaard admin maken door middel van een seed. Open in de /db map het bestand
‘seeds.rb’ en stop het volgende erin:
# Create admin user
user = User.new(email: "admin@todomanager.com", password: "admin",
password_confirmation: "admin")
user.admin = true
user.save

We moeten niet vergeten dat attr_accessible ervoor heeft gezorgd dat we de admin kolom
niet meer via de new method kunnen zetten. Vandaar dat we dit apart moeten opgeven.
Nu kunnen we de seed uitvoeren om een admin te maken voor onze applicatie.

198 - Instappen in Ruby on Rails 3 - Robin Brouwer

rake db:seed

Laten we nu het inlog gedeelte maken. Hiervoor maken we een SessionsController.

rails g controller sessions

Hierin maken we een new en create actie voor het inloggen.

class SessionsController < ApplicationController
def new
end
def create
@user = User.authenticate(params[:email], params[:password])
if @user
session[:user_id] = @user.id
url = @user.admin ? [:admin, :root] : root
redirect_to(url, notice: "Logged in!")
else
flash.now.notice = "Invalid email or password."
render("new")
end
end
end

De create actie ziet er net iets anders uit dan je gewend bent. We roepen hierin een class
method aan genaamd ‘authenticate’ die het inloggen zal regelen. Deze class method geeft
een gebruiker terug als het inloggen is gelukt en zal niks teruggeven als er iets fout gaat.
De if-statement doet een check hierop. Als het niet is gelukt wordt de new View opnieuw
getoond en wordt er direct in de ﬂash notice een bericht gestopt. Als het is gelukt zal de
sessie worden aangemaakt en wordt de gebruiker naar de root gestuurd of naar de admin.
De volgende stap is de authenticate method aanmaken. Stop deze in de User Model.

def self.authenticate(email, password)
user = where("email = ?", email).first
user if user && user.password_hash == User.hash_secret(password,
user.password_salt)
end

199 - Instappen in Ruby on Rails 3 - Robin Brouwer

Als je ‘has_secure_password’ gebruikt in Rails 3.1 wordt er automatisch een method
toegevoegd aan de Model om authenticatie toe te voegen. Deze heet toevallig ook
‘authenticate’. Deze accepteert, in tegenstelling tot mijn voorbeeld, maar één
argument.
user = User.find_by_email(params[:email])
if user && user.authenticate(params[:password])
...
end

Je moet eerst de gebruiker opzoek d.m.v. het e-mail adres. Hierna kun je het wachtwoord meegeven aan de ‘authenticate’ method. Deze geeft true of false terug.

De gebruiker wordt eerst gezocht door middel van het e-mailadres. Als een gebruiker is
gevonden en als het wachtwoord overeenkomt zal het gebruikersobject worden
teruggegeven. Zo niet krijg je nil terug. Dit kunnen we testen in de console.

rails c
user = User.authenticate("admin@todomanager.com", "admin")

In de user variabele komt nu het object van de admin te zitten. Het is dus gelukt. Probeer
maar eens een ander wachtwoord in te vullen en je zult zien dat dit niet werkt.
De logica is nu in orde. Wat we nog moeten doen is de routes goedzetten en de new View
maken voor de SessionsController. Eerst de routes.

get "logout" => "sessions#destroy", as: "logout"
get "login" => "sessions#new", as: "login"
resources :sessions

We maken named routes voor de new en destroy acties en zetten de resources voor de
SessionsController.
We kunnen nu de new View maken voor de SessionsController. We maken hier gebruik
van de form_tag helper. We gebruiken hier namelijk niet een instantie van een Model en
zullen niks opslaan in de database. We moeten daarom gebruikmaken van de
text_ﬁeld_tag en password_ﬁeld_tag. Ook moeten we niet vergeten de waarde van een
veld te zetten mocht dit nodig zijn.

200 - Instappen in Ruby on Rails 3 - Robin Brouwer

<!-- /app/views/sessions/new.html.erb -->
<h1>Log in</h1>
<%= form_tag(:sessions) do %>
<p>
<%= label_tag(:email) %><br />
<%= text_field_tag(:email, params[:email]) %>
</p>
<p>
<%= label_tag(:password) %><br />
<%= password_field_tag(:password) %>
</p>
<p><%= submit_tag("Log in") %></p>
<% end %>

De parameters die we meesturen kun je aanspreken met params[:email] en
params[:password]. Als het inloggen is mislukt moet het e-mailadres nog wel ingevuld
blijven. Vandaar dat we aan de text_ﬁeld_tag de parameter meegeven. Dit zorgt ervoor dat
de waarde van het veld wordt gezet.
Als we nu naar /login gaan in de applicatie, kom je bij het inlogformulier. Als je dan inlogt
wordt je of naar de root of naar de admin gestuurd. Probeer het maar een keertje.
Nu we een ingelogde gebruiker hebben kunnen we de current_user method maken. Deze
stoppen we in de ApplicationController.

class ApplicationController < ActionController::Base
protect_from_forgery
helper_method :current_user
private
def current_user
@current_user ||= User.find(session[:user_id]) if session[:user_id]
end
end

Nu kunnen we deze method gebruiken in onze applicatie om te kijken of iemand is
ingelogd. Laten we eerst een before_ﬁlter voor de gehele applicatie maken. Je kunt alleen
gebruikmaken van ons systeem als je bent ingelogd. Stop dit in de ApplicationController.

201 - Instappen in Ruby on Rails 3 - Robin Brouwer

before_filter :authenticate_user
private
def authenticate_user
if current_user.blank?
redirect_to(:login, notice: "You have to log in first!")
end
end

We moeten niet vergeten om een skip_before_ﬁlter in de SessionsController te stoppen.

class SessionsController < ApplicationController
skip_before_filter :authenticate_user, only: [:new, :create]
...
end

Als we nu naar de root van onze applicatie gaan en we zijn niet ingelogd, dan worden we
teruggestuurd naar de inlog pagina. Het volgende wat we doen is de admin beveiligen,
zodat alleen de admin daar kan komen. Dit doen we in de BaseController.

class Admin::BaseController < ApplicationController
before_filter :authorize_admin
private
def authorize_admin
unless current_user.admin
redirect_to(:root, notice: "You are not allowed here!")
end
end
end

Probeer nu maar eens in te loggen met een niet-admin account en naar het admin gedeelte
te gaan. Je zult zien dat het niet zal werken. Het laatste wat we nog moeten doen is een
een knop maken voor het uitloggen. Deze willen we alleen laten zien als de gebruiker is
ingelogd. Laten we eerst de destroy actie maken in de SessionsController.

202 - Instappen in Ruby on Rails 3 - Robin Brouwer

def destroy
session[:user_id] = nil
redirect_to(:login, notice: "Logged out!")
end

In de application layout stoppen we het volgende:

<div id="wrapper">
<% if current_user %>
<p><%= link_to("Logout", :logout) %></p>
<% end %>
<%= yield %>
</div>

Als de gebruiker nu inlogt zal deze knop tevoorschijn komen. We hebben nu een heel
simpel systeem gemaakt om in te loggen. Je kunt dit uiteraard zo complex maken als je
wilt. Zo kun je gebruikers laten registreren, een ‘remember me’ functie erin stoppen en een
‘wachtwoord vergeten’ optie toevoegen. Ook zou het zo kunnen zijn dat een gebruiker
alleen hoeft in te loggen om een comment te plaatsen. Dat ligt geheel aan jouw applicatie.
Bij onze applicatie willen we het op deze manier hebben, zodat we alleen to-do’s kunnen
laten zien die voor de gebruiker zijn.

9.6.3 To-do’s koppelen aan gebruikers
We zullen er nu voor zorgen dat to-do’s worden gekoppeld aan een gebruiker. Als een
gebruiker inlogt krijg hij of zij alleen zelfgemaakte to-do’s te zien. Het eerste wat we
moeten doen is een ‘user_id’ kolom toevoegen aan de todos tabel. Je kunt dit ook bij de
comments tabel doen, maar aangezien een comment altijd aan een to-do is gekoppeld
hoeft dit niet per se. Je weet immers al welke gebruiker de to-do heeft aangemaakt. Als je
echter wilt dat verschillende mensen comments kunnen plaatsen op een to-do, dan wil je
dit natuurlijk wel in de comments tabel stoppen. Bij onze applicatie is dit echter niet
nodig.
We maken eerst een nieuwe migration.
rails g migration add_user_id_to_todos

We gebruiken een omschrijvende naam voor de migration en stoppen het volgende erin:

203 - Instappen in Ruby on Rails 3 - Robin Brouwer

class AddUserIdToTodos < ActiveRecord::Migration
def self.up
add_column :todos, :user_id, :integer
end
def self.down
remove_column :todos, :user_id
end
end

Voer de migration uit. Ik ga ervan uit dat je dit nu wel kunt. De volgende stap is de relatie
leggen in de Models.

# user.rb
class User < ActiveRecord::Base
has_many :todos
...
end
# todo.rb
class Todo < ActiveRecord::Base
belongs_to :user
...
end

Nu moeten we de index actie van de TodosController aanpassen. We willen alleen de todo’s van de gebruiker laten zien.

def index
@todos = current_user.todos.order_by_completed
end

Om een to-do daadwerkelijk te koppelen aan de gebruiker moeten we de create actie iets
aanpassen. Dit kan op twee manieren:

204 - Instappen in Ruby on Rails 3 - Robin Brouwer

def create
@todo = Todo.new(params[:todo])
if current_user.todos << @todo
redirect_to(@todo, notice: "To-do has been created.")
else
render("new")
end
end

Of:

def create
@todo = Todo.new(params[:todo])
@todo.user = current_user
if @todo.save
redirect_to(@todo, notice: "To-do has been created.")
else
render("new")
end
end

Beide mogelijkheden doen precies hetzelfde. De eerste is iets korter, dus laten we die maar
gebruiken. Je zou de gebruiker overigens ook mee kunnen geven aan de new method. Dit
doe ik hier niet, omdat ik dit niet via het formulier wil laten gaan. Laten we dit gelijk extra
beveiligen in de Todo Model.

attr_accessible :title, :completed

Alle to-do’s die nu worden gemaakt zullen aan een gebruiker worden gekoppeld. Deze
gebruiker krijgt alleen deze to-do’s te zien en kan er comments op plaatsen. We hebben
echter nog één probleem. Een andere gebruiker kan een to-do van iemand anders bekijken
door de url aan te passen. Hier hebben we weer een before_ﬁlter nodig. Dit moet op elke
actie waar een to-do wordt opgehaald.

205 - Instappen in Ruby on Rails 3 - Robin Brouwer

before_filter :get_todo, except: [:index, :new, :create]
private
def get_todo
@todo = Todo.find(params[:id])
if @todo.user != current_user
redirect_to(:root, notice: "You are not allowed to see this To-do.")
end
end

Vergeet niet om bij alle acties de ﬁnd method weg te halen. Dit doen we nu in de
before_ﬁlter. Als een gebruiker nu via de url naar een to-do gaat die niet van hem/haar is,
dan wordt de gebruiker teruggestuurd naar de root van de applicatie.
Het hele gebruikersgedeelte van de applicatie is nu klaar voor gebruik! Vergeet niet om de
railscast te bekijken die ik in het vorige gedeelte liet zien. Hierin wordt het maken van een
inlogsysteem nog een keer heel duidelijk uitgelegd.

9.7 Samenvatting
Gefeliciteerd, je hebt je eerste echte Ruby on Rails applicatie gemaakt! Je hebt gezien hoe je
alles wat je hebt geleerd kunt samenvoegen om een Rails applicatie te maken waarin
gebruikers to-do’s kunnen beheren en waar een admin gebruikers kan beheren. Ook weet
je hoe je een simpel inlogsysteem kunt maken. Het is een vrij simpele applicatie geworden,
maar het is een heel goed begin. Je kent nu ofﬁcieel de basis van Rails en hebt dit in de
praktijk tot uiting kunnen brengen. In de volgende hoofdstukken gaan we alles een beetje
tweaken en zal ik wat extra dingen laten zien. We duiken iets dieper in Rails.

206 - Instappen in Ruby on Rails 3 - Robin Brouwer

10. Unobtrusive JavaScript
Nu je een simpele Rails applicatie kunt maken kunnen we verder gaan met de wat
diepgaandere dingen binnen Rails. Hetgeen waar we het dit hoofdstuk over zullen hebben
is iets wat niet Rails-speciﬁek is. Het is echter ontzettend belangrijk voor bijna elke
webapplicatie: JavaScript. Het is dé client-side script-taal voor het web en bijna elke
webapplicatie maakt hier gebruik van. Het wordt gebruikt om AJAX requests uit te
voeren, maar ook om leuke effecten in webapplicaties te stoppen. Denk aan een to-do
lijstje waarin je to-do’s kunt verslepen om van plaats te laten verwisselen.
Er zijn een aantal JavaScript frameworks die het werken met JavaScript een stuk
eenvoudiger maken. Je hoeft hiermee veel minder te doen om veel voor elkaar te krijgen.
Het framework wat standaard in Rails wordt gebruikt is Prototype. Dit werkt behoorlijk
goed en je kunt er behoorlijk veel mee voor elkaar krijgen. Naast Prototype heb je het
populaire jQuery. Dit werkt iets gemakkelijker dan Prototype en heeft een stuk meer
plugins die je kunt gebruiken. Zoals je hebt gezien in de vorige hoofdstukken gebruik ik
liever jQuery dan Prototype. Naast deze twee frameworks heb je nog een aantal andere
frameworks die je kunt gebruiken. Zo heb je ook iets genaamd MooTools. Ik heb hier nooit
mee gewerkt en weet dus niet hoe dit staat ten opzichte van jQuery. In dit hoofdstuk
werken we met jQuery.

In Rails 3.1 is het standaard JavaScript framework jQuery geworden.

Ik zal in de eerste twee onderdelen van dit hoofdstuk een aantal voorbeelden geven. Je
hoeft niet per se mee te doen met deze voorbeelden. Je hoeft pas bij 10.3 mee te doen. Dan
gaan we namelijk onze applicatie aanpassen.

10.1 Unobtrusive
Je zult nu misschien wel denken: dit hoofdstuk heet toch geen JavaScript? Dat klopt, dit
hoofdstuk gaat over ‘Unobtrusive’ JavaScript. Vaak wordt JavaScript ‘inline’ in de HTML
gestopt, in bijvoorbeeld een onclick attribuut. Dit kan ervoor zorgen dat je HTML volzit
met allemaal JavaScript, die per pagina opnieuw moet worden ingeladen. Dit zorgt ervoor
dat de HTML groter wordt, onoverzichtelijker, minder ﬂexibel en dat het laden van je
pagina’s net iets trager gaat.
Dat is precies waar Unobtrusive JavaScript tegenover staat. Je stopt geen JavaScript in de
HTML, maar verwijst naar een extern JavaScript bestand waarin alles wordt geregeld. In
dit bestand check je of een bepaald DOM element op de pagina is en op basis hiervan kun
je allerlei events koppelen aan de pagina. De HTML is een stuk kleiner, je webapplicatie
wordt een stuk ﬂexibeler en het JavaScript bestand wordt steeds uit de cache gehaald,

207 - Instappen in Ruby on Rails 3 - Robin Brouwer

waardoor je niet per pagina opnieuw de JavaScript moet inladen. Je webapplicatie werkt
net iets soepeler en pagina’s laden sneller.
Unobtrusive JavaScript is ook iets om ervoor te zorgen dat je applicatie werkt als iemand
JavaScript uit heeft staan. Als je een JavaScript event hebt staan op een link waarmee je een
AJAX request uitvoert, maar de gebruiker heeft JavaScript uitstaan, dan kun je met UJS er
makkelijker voor zorgen dat de link toch naar de juiste url verwijst. Je maakt eerst je
applicatie zonder JavaScript en kunt daarna gemakkelijk JavaScript toevoegen vanuit een
extern bestand. Zo werkt je applicatie ook als iemand geen JavaScript gebruikt. Of je dit
wilt is een heel andere discussie. Zo heeft een applicatie als Basecamp een grote
waarschuwing voor iedereen die zonder JavaScript de applicatie probeert te gebruiken.
Voor veel belangrijke functionaliteiten wordt namelijk JavaScript gebruikt. Je kunt je
applicatie ook laten werken zonder JavaScript, maar je kunt ook degenen die het uit
hebben staan weren van de site.
Het is sowieso altijd belangrijk om niet te overdreven om te gaan met JavaScript. Je moet
het zien als iets extra’s waarmee je applicatie net iets beter wordt en niet iets wat je overal
in je applicatie stopt. Het kan wel, maar dan moet je wel een goede reden hebben.
Om te illustreren hoe Unobtrusive JavaScript werkt zal ik een klein voorbeeld laten zien.
Ik zal hiervoor jQuery gebruiken. Stel we hebben de volgende HTML:

<!DOCTYPE html>
<html>
<head>
<title>UJS Test</title>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/
jquery/1.6.2/jquery.min.js"></script>
<script type="text/javascript" src="application.js"></script>
</head>
<body>
<a href="/andere_pagina.html" id="andere_pagina">Klik hier!</a>
</body>
</html>

De link in deze pagina verwijst naar een andere HTML pagina. Als je er nu op klikt zal je
naar deze pagina gaan. Om hier een JavaScript event op te zetten moet je eerst het
volgende in de application.js stoppen:

$(function(){
	
});

208 - Instappen in Ruby on Rails 3 - Robin Brouwer

Dit is iets binnen jQuery waarmee je kunt checken of de DOM geladen is. Hierbinnen
kunnen we dan een click-event op de link plaatsen.

$(function(){
$("#andere_pagina").click(function(evt){
alert("CLICKED!");
evt.preventDefault();
});
});

Je spreekt het DOM element aan en roept de click functie erop aan. Hierin kun je een
functie opgeven met wat er moet gebeuren. Belangrijk hierbij is ‘evt.preventDefault()’. Dit
zorgt ervoor dat het standaard gedrag van een link niet wordt uitgevoerd na de JavaScript.
Als je nu meerdere pagina’s hebt en je wilt alleen iets uitvoeren als je op een bepaalde
pagina bent kun je een if-statement gebruiken. Stel we hebben op onze pagina een <div>
met als id ‘page1’. Op deze pagina komt speciﬁeke HTML die gebruikt moet worden in
het JavaScript bestand. Hier willen we een check op doen. Dit werkt als volgt:

$(function(){
if($("#page1").length > 0) {
$("#andere_pagina").click(function(evt){
alert("CLICKED!");
evt.preventDefault();
});
}
});

Zo wordt bij ‘page2’ de JavaScript niet uitgevoerd en kun je per pagina regelen wat er
moet gebeuren qua JavaScript. Zo simpel is het dus om aan Unobtrusive JavaScript te
doen. Rails heeft hier overigens een heel handige manier voor. Het rails.js bestand in onze
applicatie is om ervoor te zorgen dat je heel gemakkelijk AJAX links en formulieren kunt
maken. Hier in het volgende gedeelte meer over.

10.2 Rails en UJS
In onze applicatie zit zoals je weet een rails.js bestand. Dit bestand gebruikt jQuery als
framework. Als je een ander framework wilt gebruiken moet je het juiste rails.js bestand
hiervoor vinden. Als je naar het bestand kijkt zie je een heleboel JavaScript erin. Er wordt
echter niet gekeken naar DOM elementen met een bepaalde class of id, maar met een
‘data-’ attribuut. Dit is iets nieuws binnen HTML5 en zorgt ervoor dat je elke HTML tag
een uniek attribuut kunt meegeven. Na ‘data-’ komt een willekeurig woord, waardoor er

209 - Instappen in Ruby on Rails 3 - Robin Brouwer

een zelfgemaakte attribuut ontstaat. Deze attribuut kun je een waarde geven en
aanspreken met JavaScript.
Stel we hebben de volgende link:

<a href="/todos/1" data-confirm="Weet je het zeker?">Confirm!</a>

We hebben een attribuut genaamd ‘data-conﬁrm’ met hierin een bepaalde waarde. We
kunnen de volgende UJS gebruiken om deze link aan te spreken:

$('a[data-confirm]').click(function(e){
return confirm($(this).attr('data-confirm'));
});

Nu zal er eerst een conﬁrm-box komen voordat je naar de link wordt gestuurd. En dit
allemaal zonder JavaScript te gebruiken in de HTML.
Naast ‘click’ heb je ook iets genaamd ‘live’. Bij de live functie wordt het event steeds
opnieuw geplaatst, waardoor na een update aan de pagina de events nog steeds bestaan.
Bij een simpel click event zal deze verdwijnen als het DOM-element wordt overschreven
en hierna wordt teruggezet. Bij de live functie is dit niet het geval en komt het event weer
terug. Vandaar dat je in het rails.js bestand steeds ‘live’ ziet staan. Het is een stuk
ﬂexibeler.

Het rails.js bestand is in Rails 3.1 standaard toegevoegd aan application.js. Je ziet
hierin het volgende staan:
//= require jquery_ujs

Dit zorgt ervoor dat dit bestand wordt ingeladen.

Zoals je weet kun je in Rails de helper ‘link_to’ gebruiken om een link te maken. Dit is
altijd een gewone link, zonder enige JavaScript. De JavaScript hiervoor kun je uiteraard
zelf regelen, maar doordat je een rails.js bestand hebt kun je erg gemakkelijk een AJAX
link maken van de link_to helper. Je gebruikt hiervoor de :remote key.

<%= link_to("Edit product", [:edit, product], remote: true) %>

210 - Instappen in Ruby on Rails 3 - Robin Brouwer

De volgende HTML zal worden gegenereerd.

<a href="/products/1/edit" data-remote="true">Edit product</a>

Er wordt automatisch een data-remote attribuut toegevoegd aan de link. De link zal een
live click event meekrijgen vanuit het rails.js bestand, waardoor het een AJAX link wordt.
AJAX staat voor Asynchronous JavaScript and XML en zorgt ervoor dat je gedeeltes van je
pagina kunt updaten, zonder een nieuwe pagina in te laden. Je kunt een request naar de
server sturen en vanaf de server bepaalde JavaScript terugsturen, zodat de pagina zonder
een hele page-reload wordt aangepast. Je kunt dus heel gemakkelijk nieuwe data uit de
database halen en laten zien, zonder de hele pagina opnieuw te tonen. Het zorgt voor een
stuk minder stress voor de server en maakt de webapplicaties van tegenwoordig mogelijk.
Het zorgt er namelijk voor dat webapplicaties meer op desktop applicaties lijken.
Nu je weet wat AJAX is kunnen we verder gaan met het voorbeeld. Als er op de link
wordt geklikt zal er een request naar de server worden gestuurd zonder dat een nieuwe
pagina wordt geladen. De request zal naar dezelfde Controller actie gaan als bij een
normale request: de edit actie van de ProductsController. Maar hoe zorg je er dan voor dat
er JavaScript wordt teruggegeven?
Dat is in Rails 3 verdomde simpel. Rails weet automatisch wanneer er een AJAX request
wordt verstuurd en zal zoeken naar een ‘.js.erb’ View. In ons geval wordt er gezocht naar
‘edit.js.erb’ in de /app/views/products map. Dit is een bestand waarin je JavaScript kunt
gebruiken én Ruby code kunt uitvoeren binnen de welbekende Ruby-tags. Dit werkt
precies hetzelfde als de html.erb bestanden. Het grote verschil is dus dat er nu JavaScript
moet komen. Wij zouden het volgende kunnen doen:

$('#product_1').html('<%= escape_javascript(render("form")) %>');

In Rails 3.1 kun je escape_javascript aanspreken met ‘j’. Er is dus een gemakkelijkere
manier gekomen om JavaScript te escapen.

Je voert jQuery uit om de HTML in een bepaald DOM object te vervangen. Je gebruikt een
Ruby-tag om een partial in te laden en gebruikt de ‘escape_javascript’ helper om ervoor te
zorgen dat er geen errors komen. Dat is ook gelijk wat er zo handig is aan partials. Je kunt
een gehele partial heel makkelijk via JavaScript in de pagina stoppen. Naast het DRY
houden van je Views is dat een heel belangrijke functie van partials.

211 - Instappen in Ruby on Rails 3 - Robin Brouwer

Naast het inladen van een partial kun je nog veel meer binnen het JavaScript ERB bestand.
Zo kun je alle JavaScript functies en variabelen gebruiken die zijn ingeladen. De speciale
JavaScript Views zorgen er ook voor dat je gemakkelijker AJAX requests en gewone
requests kunt scheiden. Voor de edit actie kun je ook een HTML View maken die dan
wordt getoond als er geen AJAX request is. Rails weet welke View moet worden getoond.
Je hoeft daarom ook geen respond_to te gebruiken in de Controller.
Als je JavaScript wilt uitvoeren tijdens de AJAX request moet je JavaScript toevoegen aan
application.js. Een AJAX request gebeurt namelijk niet gelijk, omdat je moet wachten
totdat de server reageert. Je kunt het volgende doen om een ‘loading’ GIF te laten zien op
de plaats van de AJAX link:

$("a[data-remote]").bind("ajax:loading", function(){
$(this).html('<img src="/images/loader.gif" width="14" height="14"
class="loader" />');
});

In nieuwere versies van jQuery wordt er gebruikgemaakt van andere AJAX events.
Zo zal ‘ajax:loading’ waarschijnlijk niet werken. Je kunt ‘beforeSend’ gebruiken om
hetzelfde resultaat te krijgen.

Je voegt aan de data-remote links een ‘ajax:loading’ event toe die bij het laden een handige
GIF laat zien op de plaats van de link. Dit is jQuery en heeft niet echt iets met Rails te
maken. Je kunt hier dus van alles mee doen. Zo kun je ook een bepaalde AJAX link een
class meegeven en deze een ‘ajax:loading’ event meegeven waar iets speciaals gebeurt. Dat
is geheel aan jou.
De nieuwe manier van AJAX requests in Rails is een welkome verbetering. In Rails 2.3
werd er gebruikgemaakt van speciale ‘link_to_remote’ helpers die inline JavaScript
genereerde. Hiernaast gebruikte je vreemde ‘rjs’ templates om JavaScript te genereren. De
nieuwe manier is een stuk logischer en ook nog een stuk ﬂexibeler.
UJS binnen Rails 3 zorgt er ook voor dat je heel gemakkelijk een andere HTTP method
kunt gebruiken bij een link en een conﬁrm-box kunt laten zien. Hiervoor heb je
de :method en :conﬁrm keys.

<%= link_to("Delete product", product, method: :delete, confirm: "Are you
sure?") %>

Dit geeft dan de volgende HTML:
212 - Instappen in Ruby on Rails 3 - Robin Brouwer

<a href="/products/1" data-method="delete" data-confirm="Are you
sure?">Delete product</a>

De HTTP method DELETE wordt nu gebruikt en je krijgt eerst een conﬁrm-box te zien. Dit
is weer iets wat het rails.js bestand voor je regelt.
Naast de link_to helper kun je ook de :remote, :method en :conﬁrm keys gebruiken bij een
form_for of form_tag helper. Dit werkt precies hetzelfde als bij link_to en wordt
geïnitieerd als op de submit knop wordt gedrukt.
UJS in Rails 3 is ontzettend handig en kan je applicatie erg verrijken. Zorg er echter niet
voor dat je applicatie er van afhankelijk is, tenzij je een hele goede reden hebt hiervoor. In
het volgende gedeelte gaan we onze applicatie verrijken met wat Unobtrusive JavaScript.
Als je meer wilt weten over UJS in Rails 3 kun je de Railscast hierover bekijken:
Railscasts - Unobtrusive JavaScript
http://railscasts.com/episodes/205-unobtrusive-javascript
(TinyURL: http://tinyurl.com/y5exhaw)

10.3 In onze applicatie stoppen
Nu je weet wat UJS is en hoe je een AJAX link kunt maken, gaan we dit in de praktijk tot
uiting brengen door het in onze applicatie te stoppen. Als eerste maken we de edit actie
wat netter door dit met AJAX te regelen. Hierna maken we gebruik van AJAX checkboxes
om het afvinken wat gemakkelijker te maken.

10.3.1 Aanpassen met AJAX
Pak als eerste de index View van de TodosController erbij en focus op het volgende:
<%= div_for(todo, class: todo.completed ? "completed" : nil) do %>
<%= link_to(todo.title, todo) %>
<% end %>

We gaan hier een edit link aan toevoegen die met AJAX zal werken. Aangezien we met
‘div_for’ werken zal er om elke to-do een <div> worden geplaatst met een uniek id. Dit
kunnen we later erg goed gebruiken. Eerst de edit link:

213 - Instappen in Ruby on Rails 3 - Robin Brouwer

<%= div_for(todo, class: todo.completed ? "completed" : nil) do %>
<%= link_to(todo.title, todo) %> |
<%= link_to("Edit", [:edit, todo], remote: true) %>
<% end %>

Het volgende is de ‘edit.js.erb’ toevoegen. Hier laden we de form partial in de <div>.

$("#todo_<%= @todo.id %>").html('<%= escape_javascript(render("form")) %>');

Nu wordt het formulier in de <div> geplaatst en kun je gemakkelijk de to-do aanpassen.
Het probleem is echter dat het formulier een gewone request uitvoert. Dit willen we ook
via AJAX laten gaan. Dit kunnen we doen door een nieuwe form partial aan te maken,
maar we kunnen natuurlijk ook het formulier aanpassen. Probleem hiermee is echter dat
de ‘new’ actie ook gebruikmaakt van dit formulier. En deze actie gebruikt geen AJAX.
Hetzelfde geldt voor de edit link bij de show View. Die willen we een gewone request
laten uitvoeren. Je kunt dus voor elke AJAX request een aparte partial maken, maar dat is
natuurlijk niet DRY. Wij gaan dit anders oplossen.

<%= form_for(@todo, remote: request.xhr?) do |f| %>
...
<% end %>

We gebruiken ‘request.xhr?’ om te kijken of het een AJAX request is. Als het een gewone
request is zal er false worden teruggegeven, waardoor de new actie een gewone request
zal gebruiken bij hetzelfde formulier.
Het volgende wat we moeten doen is update.js.erb toevoegen. Eerst moeten we een partial
hebben voor een enkele to-do. Hiervoor maken we een partial genaamd ‘todo’ aan. We
stoppen het volgende erin:

<%= div_for(todo, class: todo.completed ? "completed" : nil) do %>
<%= link_to(todo.title, todo) %> |
<%= link_to("Edit", [:edit, todo], remote: true) %>
<% end %>

De index View kunnen we dan naar het volgende aanpassen om alles DRY te houden:

214 - Instappen in Ruby on Rails 3 - Robin Brouwer

<h1>To-do overview</h1>
<div id="todos">
<%= render(@todos) %>
</div>
<p class="new_todo"><%= link_to("Create new To-do", [:new, :todo]) %></p>

Nu wordt de todo partial meerdere keren getoond en krijgen we hetzelfde resultaat. Het
handige is dat we nu deze partial kunnen gebruiken in update.js.erb.

$("#todo_<%= @todo.id %>").html('<%= escape_javascript(render(@todo)) %>');

Er is echter nog één ding die we moeten regelen. De update actie voert namelijk een
redirect_to uit. Als je de update actie met AJAX aanspreekt zal er achter de schermen een
redirect worden uitgevoerd. Dit wil je natuurlijk niet. Dit kun je op twee manieren
oplossen.

def update
if @todo.update_attributes(params[:todo])
respond_to do |format|
format.js
format.html do
redirect_to(@todo, notice: "To-do has been updated.")
end
end
else
render("edit")
end
end

Of:

def update
if @todo.update_attributes(params[:todo])
unless request.xhr?
redirect_to(@todo, notice: "To-do has been updated.")
end
else
render("edit")
end
end

215 - Instappen in Ruby on Rails 3 - Robin Brouwer

Welke je gebruikt is geheel aan jou. Je hoeft trouwens niks speciaals te doen als het opslaan
van de to-do mislukt. De render method zal namelijk de edit.js.erb View gebruiken als er
een AJAX request wordt gedaan. Bij een gewone request zal de HTML View worden
gebruikt. Het enige wat je dus moet afvangen is een redirect_to.
Probeer nu maar eens een to-do aan te passen via de index actie. Dit gaat nu allemaal met
AJAX en werkt perfect. Als je nu JavaScript uitzet zul je nog steeds een to-do kunnen
aanpassen.
Wat we nog missen is een cancel link in het formulier. Deze moet alleen worden getoond
bij een AJAX request en moet de to-do weer laten zien. Eerst maken we de link in het
formulier:

<%= form_for(@todo, remote: request.xhr?) do |f| %>
<p>
<%= f.label(:title, "To-do:") %>
<%= f.text_field(:title) %>
<%= f.submit %>
<% if request.xhr? %>
or <%= link_to("cancel", @todo, remote: true) %>
<% end %>
</p>
<% end %>

Nu moeten we voor de show actie een JavaScript View aanmaken. Wat hier echter zal
gebeuren is precies hetzelfde als bij de update actie. We laten de to-do simpelweg zien in
een bepaalde <div>. Wat we daarom doen is update.js.erb hernoemen naar show.js.erb. Nu
zal de cancel knop werken, maar het updaten niet meer. Hiervoor moeten we de update
actie aanpassen.

def update
if @todo.update_attributes(params[:todo])
respond_to do |format|
format.js { render("show") }
format.html do
redirect_to(@todo, notice: "To-do has been updated.")
end
end
else
render("edit")
end
end

216 - Instappen in Ruby on Rails 3 - Robin Brouwer

En dat is alles. Nu hebben we ook een cancel knop en hebben we de update JavaScript
View een logischere naam gegeven. De AJAX edit functionaliteit is klaar en we kunnen
doorgaan met het afvinken van to-do’s.

10.3.2 Afvinken met AJAX
Voor het afvinken zullen we in dit voorbeeld gebruikmaken van een normale checkbox.
Wat je namelijk kunt doen is per to-do een AJAX formulier maken met een checkbox erin
die automatisch wordt verstuurd als er op de checkbox wordt geklikt. Hiervoor moet je
een click-event op de checkbox stoppen die het formulier submit. Dit formulier kan dan
gewoon naar de update actie worden verstuurd, zodat je niet een speciale complete en
incomplete actie nodig hebt. Je kunt natuurlijk een gewone link gebruiken, een checkbox
als plaatje gebruiken en deze naar de complete en incomplete actie verwijzen. Mijn optie is
echter iets leuker. Nadeel is dat het niet zonder JavaScript gaat werken.
Laten we de todo partial erbij pakken en een formulier erin stoppen.
<%= div_for(todo, class: todo.completed ? "completed" : nil) do %>
<%= form_for(todo, remote: true) do |f| %>
<%= f.check_box(:completed) %>
<% end %>
<%= link_to(todo.title, todo) %> |
<%= link_to("Edit", [:edit, todo], remote: true) %>
<% end %>

We moeten niet vergeten om de stijl van het formulier aan te passen, zodat het geen block
element meer is:
form { display: inline; }

Het volgende wat we moeten doen is een class meegeven, zodat we per checkbox
JavaScript kunnen uitvoeren.
<%= f.check_box(:completed, class: "check_todo") %>

Nu kunnen we het volgende in onze JavaScript stoppen:

217 - Instappen in Ruby on Rails 3 - Robin Brouwer

$(function(){
if($(".check_todo").length > 0) {
$(".check_todo").live("change", function(){
$(this).closest("form").submit();
// Zonder jQuery: this.form.submit();
});
}
});

Elke keer als er nu op de checkbox wordt geklikt zal het formulier worden verstuurd.
Aangezien dit steeds naar de update actie gaat, zal dit allemaal perfect verlopen. Het
nadeel is echter dat de afgevinkte to-do’s niet meteen onderaan komen te staan. Dit
gebeurt pas na een refresh. Je kunt dit op verschillende manieren oplossen. Ten eerste kun
je ervoor zorgen dat alle to-do’s opnieuw worden opgehaald bij elke update. Dit doen we
in show.js.erb.

$("#todos").html('<%=
escape_javascript(render(current_user.todos.order_by_completed)) %>');

Nu worden alle to-do’s opnieuw opgehaald en in de #todos <div> gestopt. Het nadeel
hiervan is dat alle to-do’s steeds moeten worden opgehaald en dat als je een andere to-do
aan het aanpassen was het formulier verdwijnt. Het voordeel is dat de volgorde helemaal
goed is en dat nieuwe to-do’s ook gelijk worden opgehaald.
Een andere manier is om JavaScript te gebruiken om de afgevinkte to-do te positioneren.
Je kunt de show.js.erb laten zoals het eerst was, maar moet wel iets extra’s eraan
toevoegen. Het zorgt misschien niet voor exact dezelfde volgorde, maar kan ermee door.

var todo = $("#todo_<%= @todo.id %>");
todo.html('<%= escape_javascript(render(@todo)) %>');
<% if @todo.completed %>
$("#todos").append(todo);
<% else %>
$("#todos").prepend(todo);
<% end %>

Nu wordt een afgevinkte taak altijd aan het einde gestopt en een taak die weer actief
wordt zal helemaal bovenaan komen te staan. Dit kan je natuurlijk helemaal aanpassen
met jQuery om ervoor te zorgen dat de to-do niet helemaal onderaan komt, maar
bijvoorbeeld wordt gesorteerd op naam. Dat is geheel aan jou.

218 - Instappen in Ruby on Rails 3 - Robin Brouwer

Zoals je ziet kun je nu heel gemakkelijk taken afvinken met behulp van AJAX. Het nadeel
hiervan is dat de to-do niet wordt afgevinkt als je JavaScript uit hebt staan. Dit zou wel
gebeuren als je er een gewone link van had gemaakt. Dat is dan ook precies de afweging
die je moet maken. Wanneer laat je iets werken zonder JavaScript en wanneer niet. Dat ligt
aan jou en de gebruiker die je voor ogen hebt. Je kunt natuurlijk altijd een <noscript> tag
gebruiken om een waarschuwing te geven aan de gebruiker, zoals bij Basecamp gebeurt.
Het is altijd handig om een callback te hebben voor de JavaScript requests, maar het zou
niet een obstakel moeten vormen. Bijna iedereen heeft tegenwoordig JavaScript aanstaan,
dus een heel groot probleem zou het niet zijn.

10.4 Samenvatting
Je weet nu hoe je AJAX functionaliteit kunt toevoegen aan je applicatie en wat er nou
precies wordt bedoeld met Unobtrusive JavaScript. Je zal vanaf nu geen inline JavaScript
meer gebruiken en ervoor zorgen dat alles extern wordt geladen. Je weet ook hoe Rails
omgaat met AJAX requests en hoe je AJAX terug kunt sturen naar de gebruiker. Genoeg
geleerd dus!
Hier nog op een rijtje wat je in dit hoofdstuk hebt geleerd:
- Wat UJS nou precies is;
- Wat AJAX precies is;
- Hoe je UJS kunt gebruiken;
- Hoe je data- attributen kunt gebruiken;
- Hoe je een AJAX link en formulier maakt;
- Hoe je AJAX requests afhandelt;
- Hoe je JavaScript terugstuurt vanaf de server;
- Hoe je een applicatie kunt verrijken met JavaScript.

219 - Instappen in Ruby on Rails 3 - Robin Brouwer

11. Locales
Lokalisatie is iets wat behoorlijk belangrijk is bij een internationale webapplicatie. Je
ondersteunt vaak standaard de Engelse taal, maar wilt misschien ook andere talen
ondersteunen. Het zou behoorlijk handig zijn als je applicatie ook in het Nederlands te
bekijken is. Het probleem is echter dat we nu alle teksten in de Views hebben staan. Als we
hier ook Nederlandse vertalingen van willen hebben moeten we per tekst een if-statement
gebruiken. Je krijgt dan ontzettend lelijke Views waarin je niet bepaald gemakkelijk een
nieuwe taal kan introduceren.
Gelukkig heeft Rails hier een goede oplossing voor: locales. Dit zijn bestanden waarin je
alle statische tekst kwijt kunt per taal. Dit zijn YAML bestanden (.yml) die worden
opgeslagen in /conﬁg/locales. Als je bij onze applicatie kijkt zie je een bestand genaamd
‘en.yml’ staan. Hierin kun je Engelse teksten stoppen. Als je dan ‘nl.yml’ toevoegt en
dezelfde teksten vertaalt naar het Nederlands, kun je erg gemakkelijk deze vertalingen
gebruiken. In de View kun je dan aangeven welke tekst je wilt gebruiken en Rails haalt de
tekst uit dit bestand op basis van welke taal is geselecteerd. Het is de bedoeling dat je
statische teksten altijd, maar dan ook echt altijd, in een locale bewaart. Dat is dan ook de
reden waarom je geen :message moet gebruiken bij validatie in de Model. Dit kun je via
een locale automatisch regelen. Hoe dit precies allemaal in zijn werk gaat zal ik in dit
hoofdstuk uitleggen. Het is hierna aan jou om dit in onze applicatie uit te voeren.

11.1 Hiërarchie van locales
Als je en.yml opent zie je het volgende:
en:
hello: "Hello world"

De Engelse vertaling van de locale ‘hello’ zal ‘Hello world’ worden. Hier kunnen we meer
vertalingen aan toevoegen:
en:
hello: "Hello world"
yesterday: "Yesterday"
today: "Today"
tomorrow: "Tomorrow"

Dit zijn globale locales en kun je heel gemakkelijk aanspreken in je applicatie. Hoe dit
precies moet zal ik in het volgende gedeelte uitleggen. Wat voor nu belangrijk is, is hoe je

220 - Instappen in Ruby on Rails 3 - Robin Brouwer

een andere taal toevoegt. Dat is vrij simpel. Voeg een bestand genaamd ‘nl.yml’ toe aan de
locales map. Hier kunnen we dan het volgende in stoppen om het te vertalen:

nl:
hello: "Hallo wereld"
yesterday: "Gisteren"
today: "Vandaag"
tomorrow: "Morgen"

Hierbij moet je opletten dat je ‘nl’ bovenaan zet in plaats van ‘en’. Als de taal dan op
Nederlands staat zal dit bestand worden gebruikt in plaats van en.yml.
Wat je misschien al opvalt is dat alle vertalingen onder ‘nl’ en ‘en’ genest zijn. Dat is ook
hoe je een YAML bestand opbouwt. Je gebruikt twee spaties of een tab om iets te nesten.
Dit werkt hetzelfde als bij de HAML Views die je kunt maken. Ook zie je dat een soort
Hash syntax wordt gebruikt, maar dan zonder komma’s.
Waar je overigens soms mee te maken krijgt is dat een bepaalde locale niet wordt herkend.
Als je bijvoorbeeld het woordje ‘on’ wilt toevoegen moet dit op de volgende manier:

en:
"on": "on"

Je moet dan aanhalingstekens eromheen doen. Dit is bij een aantal woorden zo. Hiernaast
is het ook handig om aanhalingstekens om iets als ‘en-US’ te stoppen, omdat er een
streepje tussenstaat.

"en-US":
...

Naast YAML te gebruiken kun je ook gebruikmaken van Ruby Hashes in een Ruby
bestand.

221 - Instappen in Ruby on Rails 3 - Robin Brouwer

# /config/locales/nl.rb
{ nl: {
hello: "Hallo wereld",
yesterday: "Gisteren",
today: "Vandaag",
tomorrow: "Morgen"
}
}

Ik vind het handiger om YAML hiervoor te gebruiken. Ik ga daarom hiermee verder.
Zoals ik aangaf kun je heel gemakkelijk verschillende vertalingen nesten. Het verschil zit
in hoe je die vertalingen kunt aanroepen. Een vertaling die genest is, is net iets lastiger aan
te roepen.

nl:
notices:
error: "Er is iets fout gegaan"
alert: "Kijk uit!"

In Rails zijn een heleboel vertalingen al voor je genest, waardoor je gemakkelijk
standaarden kunt overschrijven. Zo heb ik het al gehad over de :message key bij validatie
in de Model. Dit kun je beter in een locale regelen. Deze zitten namelijk genest en kun je
overschrijven in de locales.
In Rails zijn voor zowel ActiveRecord als ActiveSupport aan aantal locales die je kunt
overschrijven:
ActiveRecord locales
https://github.com/rails/rails/blob/master/activerecord/lib/active_record/locale/
en.yml
(TinyURL: http://tinyurl.com/46v9u7p)
ActiveSupport locales
https://github.com/rails/rails/blob/master/activesupport/lib/active_support/locale/
en.yml
(TinyURL: http://tinyurl.com/4p7fto8)
Als je naar de ActiveRecord link gaat zie je hoe je bepaalde error messages kunt
overschrijven. Je kunt dit globaal doen voor alle Models, maar ook speciﬁek voor een
Model. Hier een voorbeeld hoe we bij de Todo Model ervoor kunnen zorgen dat er een
ander bericht komt als er geen titel is ingevuld:
222 - Instappen in Ruby on Rails 3 - Robin Brouwer

en:
activerecord:
errors:
models:
todo:
attributes:
title:
blank: "You need to fill in a description for this To-do."

Een heleboel geneste locales. Rails zal nu dit bericht gebruiken als de titel leeg is. Ook kun
je ervoor zorgen dat per formulier de submit knop een bepaalde label krijgt.

en:
helpers:
submit:
todo:
create: "Add To-do"
update: "Update To-do"

Nu wordt de submit knop bij een to-do automatisch gevuld met deze teksten en kun je het
gemakkelijk vertalen. Bekijk de links hierboven om meer van dit soort voorbeelden te
vinden.
Vaak wil je per View een aantal locales tot je beschikking hebben. Hiervoor kun je de
locales op een speciale manier nesten:

en:
todos:
index:
overview: "To-do overview"
new_todo: "Create new To-do"

Eerst geef je de Controller op en hierna de actie. Hierin kun je dan allerlei locales zetten.
Nu kun je heel gemakkelijk deze locales aanspreken vanuit de View. Hoe dit werkt leg ik
zometeen uit.
Rails haalt automatisch alle bestanden in de locales map op. Je kunt daarom ook iets
anders dan ‘en.yml’ gebruiken als bestandsnaam. Alle locales voor de Views zou je
bijvoorbeeld in een ‘views.en.yml’ bestand kunnen stoppen. Rails laadt deze toch in. Als je
het laden van locales wilt aanpassen kun je naar /conﬁg/application.rb kijken. Hierin
staat het volgende:
223 - Instappen in Ruby on Rails 3 - Robin Brouwer

# The default locale is :en and all translations from config/locales/
# *.rb,yml are auto loaded.
# config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.
{rb,yml}').to_s]
# config.i18n.default_locale = :de

Zoals je ziet kun je de standaard locale hier zetten en de load_path aanpassen. Zo kun je
ook mappen aanmaken in de locales map om alles mooi te structureren. Denk aan de
volgende structuur voor de View locales:

locales
views
todos
en.yml
nl.yml
users
en.yml
nl.yml

Dan komen alle locales geordend in deze YAML bestanden te staan. Vergeet deze mappen
dan niet toe te voegen aan de load_path. Je kunt hiervoor het volgende gebruiken:

config.i18n.load_path += Dir[Rails.root.join('config', 'locales', '**', '*.
{rb,yml}')]

Vergeet niet dat als je een nieuw bestand toevoegt de server opnieuw moet worden
gestart. De locales worden namelijk maar één keer ingeladen: bij het starten van de server.
Je kunt wel dingen binnen deze bestanden veranderen zonder de server opnieuw op te
starten.
Nu je weet hoe je locales kunt aanmaken kunnen we doorgaan met het aanroepen van de
locales.

11.2 Locales aanroepen
Het aanroepen van een locale hangt af van hoe deze is genest. Een aantal speciﬁek geneste
locales worden door Rails automatisch weergegevens, zoals de labels en foutmeldingen uit
het vorige gedeelte. Dit regelt Rails en hoef jij niks extra’s voor te doen. Globale locales zijn
vrij simpel aan te spreken. Om een locale te laten zien gebruik je de ‘t’ (translate) method.
Deze kun je in de Controller en View als volgt aanroepen:

224 - Instappen in Ruby on Rails 3 - Robin Brouwer

t(:hello)

Dit werkt niet in de Model. Hiervoor moet je het volgende doen:

I18n.t(:hello)

Nu wordt de tekst getoond die in het locales bestand staat. Welke tekst wordt getoond is
weer afhankelijk van welke taal is geselecteerd. Hoe je een taal kunt selecteren laat ik zien
in het volgende gedeelte van dit hoofdstuk.
Wat iets lastiger is om aan te roepen zijn geneste locales. Het kan op verschillende
manieren en werkt als volgt bij ons ‘notices’ voorbeeld van het vorige gedeelte:

t(:alert, scope: [:notices])
t('notices.alert')

De :scope key zorgt ervoor dat je een Array mee kunt sturen waarin staat hoe de locale
genest is. Hiernaast kun je een String meegeven en met punten aangeven waar de locale
zich precies bevind. De twee voorbeelden hierboven geven dus hetzelfde resultaat. Het
valt dus nog mee hoe je deze geneste locales kunt aanspreken. Het zal er alleen raar
uitzien als je het ontzettend diep gaat nesten en het op deze manier aanspreekt. Als je
ergens diep in gaat nesten is het handig om een helper hiervoor te maken.
Ook kun je een standaardwaarde meegeven. Als de locale dan niet kan worden gevonden
krijg je dat te zien.

t(:missing, default: 'Missing')
t(:missing, default: :also_missing)
t(:missing, default: [:also_missing, 'Missing'])

Je kunt aan de :default key meegeven wat de String is die moet worden getoond of de
locale die dan moet worden gebruikt. Als je een Array meegeeft kun je aangeven waar
eerst naar moeten worden gezocht. Zo laten we bij voorbeeld drie eerst also_missing zien.
Als also_missing niet bestaat krijgen we de String te zien.
Om de speciale View locales te laten zien kun je iets genaamd ‘Lazy Lookup’ gebruiken.
Op de volgende manier kunnen we onze index View voor de to-do’s naar het volgende
vertalen:
225 - Instappen in Ruby on Rails 3 - Robin Brouwer

<h1><%= t(".overview") %></h1>
<div id="todos">
<%= render(@todos) %>
</div>
<p class="new_todo"><%= link_to(t(".new_todo"), [:new, :todo]) %></p>

Je geeft een String mee aan de translate method en begint hierin met een punt. Rails weet
dan dat hij moet zoeken naar ‘todos.index’ en laat de juiste tekst zien. Probeer dit nu in de
rest van de applicatie te stoppen, compleet met Nederlandse vertalingen.
Bedenk ook goed wanneer je View speciﬁeke locales nodig hebt en wanneer niet. Een
‘back’ knop komt vaker voor en kun je misschien beter als globale locale gebruiken. Stop
ook gelijk alle View speciﬁeke locales in ‘views.en.yml’ en ‘views.nl.yml’. Of je kunt zoals
het voorbeeld in het vorige gedeelte alles ordenen in mappen. Dat is geheel aan jou.
Het laatste wat ik over de locales wil zeggen is hoe je een variabele kunt meesturen naar
een locale. Als eerste moet je de locale opgeven. Hierin kun je %{} gebruiken om aan te
geven waar de variabele moet komen. Denk erom: het is een procent-teken. Dit is anders
dan bij een gewone Ruby String.

en:
hello: "Hello %{name}"

Je kunt dan het volgende doen om een naam mee te sturen:

t(:hello, name: "Robin")

Dat is dus ook vrij gemakkelijk om voor elkaar te krijgen. Je kunt hierdoor de locales een
heel stuk ﬂexibeler maken.
Je kunt naast de dingen die ik tot nu toe heb opgenoemd nog veel meer met locales. Alles
hierover kun je in de Ruby on Rails guide vinden. Een link hiernaartoe geef ik aan het
einde van dit hoofdstuk. Laten we nu maar verder gaan met het daadwerkelijk veranderen
van de taal in de applicatie, zodat je ziet hoe gemakkelijk het is om je applicatie te
lokaliseren.

11.3 Verwisselen van taal
In Rails wordt er standaard gebruikgemaakt van de Engelse taal. Om de taal te veranderen
kun je het volgende uitvoeren:
226 - Instappen in Ruby on Rails 3 - Robin Brouwer

I18n.locale = :nl

Elke request die je doet zal zoeken naar de en.yml bestanden en hier de vertalingen uit
halen. Als je bij een request de taal verandert zal bij de volgende request alles weer in het
Engels zijn. Je moet daarom de taal onthouden. Dit kun je in een sessie doen, maar is niet
aan te raden doordat dit nogal tegen het hele REST gebeuren ingaat. Je kunt dit beter via
de url regelen. De gebruiker weet dan ook precies welke taal wordt gebruikt en zou dit
zelfs via de url kunnen aanpassen. Wat ik nu ga laten zien is de meest-gebruikte manier
van lokalisatie binnen Rails.
Eerst moeten we een before_ﬁlter toevoegen aan de Application Controller. Deze zet elke
keer de lokalisatie voor de request.

before_filter :set_locale
private
def set_locale
I18n.locale = params[:locale]
end

Bij elke request zal de taal worden omgezet naar de locale die met de link wordt
meegestuurd. Het enige lastige punt hieraan is dat elke link een extra parameter moet
meesturen. Om dit nou bij elke link te doen is nogal onpraktisch. Laten we dit zo
aanpassen dat dit automatisch gebeurt. Dit kunnen we ook in de Application Controller
regelen. We gebruiken hiervoor de default_url_options method waarmee we de url_for
helper kunnen aanpassen die bij alle paden wordt gebruikt.

private
def default_url_options(options={})
{ locale: I18n.locale }
end

Bij elke link zal nu de huidige locale worden meegestuurd. Het nadeel hiervan is dat je nu
de volgende url’s krijgt:

227 - Instappen in Ruby on Rails 3 - Robin Brouwer

/todos?locale=nl

Het zou veel mooier zijn als de locale niet aan het einde zou zitten, maar er als volgt uit
zou zien:

/nl/todos

Om dit voor elkaar te krijgen moeten we iets aanpassen in de routing. We gebruiken
hiervoor een scope waarin we al onze resources stoppen.

TodoManager::Application.routes.draw do
scope ":locale" do
...
end
root to: "todos#index"
end

Alles wat in routes.rb staat moet je op de plaats van de drie puntjes neerzetten, behalve de
root van de applicatie. Die moet je buiten de scope zetten (er is namelijk één root). Als je
ervoor wilt zorgen dat er niet per se een locale meegestuurd hoeft te worden kun je het
volgende doen:

scope "(:locale)", locale: /en|nl/ do
...
end

Je stopt haakjes eromheen om ervoor te zorgen dat de locale optioneel is. Als je nu naar de
url /todos/1 gaat wordt de Engelse vertaling gebruikt, maar zie je dit niet in de url. Je
krijgt nu ook geen RoutingError, wat ook best handig kan zijn.
Je moet er ook nog voor zorgen dat als je direct naar de locale (/en of /nl) gaat je wel naar
de juiste pagina wordt verwezen.

match ":locale" => "todos#index", as: "locale"

Je moet nu wel uitkijken dat je niet de root_path aanspreekt om terug te gaan naar de root.
Anders krijg je namelijk weer die lelijke url met de locale erachter. De root kan geen locale
228 - Instappen in Ruby on Rails 3 - Robin Brouwer

ervoor krijgen zoals bij de scope. Het is namelijk de root. Gebruik daarom nu locale_path
om naar de root te gaan van de locale.
Als het goed is werkt de lokalisatie in je applicatie nu helemaal perfect. Creëer een aantal
nieuwe YAML bestanden voor verschillende talen en verander de url een aantal keer. Je
zult zien dat de taal daadwerkelijk wordt aangepast. Best handig die vertalingen.
Naast het gebruiken van een scope kun je ook de locale uit de domeinnaam halen. Hoe dit
precies werkt kun je zien in de Ruby on Rails guide. Ook zit in de guide veel extra
informatie over locales binnen Rails.
Rails Internationalization (I18n) API
http://guides.rubyonrails.org/i18n.html
Misschien vraag je je nu af wat voor talen er nou precies allemaal zijn en wat de
afkortingen zijn. Gelukkig hoef je dit niet zelf te verzinnen en is er altijd wel een handige
website die dit soort dingen voor je klaar heeft staan. Zo heeft iemand een I18n plugin
gemaakt waarin de standaard Rails vertalingen in alle andere talen zijn vertaald. Hier een
overzicht van al deze locales:
Github - rails-i18n plugin
https://github.com/svenfuchs/rails-i18n/tree/master/rails/locale
(TinyURL: http://tinyurl.com/4lgtttg)

11.4 Samenvatting
Je weet nu hoe je een internationale applicatie kunt lokaliseren naar andere talen. Je gaat
vanaf nu alle teksten die je in een applicatie stopt in een locale stoppen, zodat je later heel
gemakkelijk alles kunt vertalen. Het is dan namelijk een kwestie van de locale vertalen.
Zelfs mensen zonder technische kennis zouden dat kunnen doen.
Hier nog op een rijtje wat je in dit hoofdstuk hebt geleerd:
- Wat locales precies zijn en wat het nut ervan is;
- Dat je alle teksten in locales moet stoppen;
- Hoe je locales kunt aanmaken en nesten;
- Hoe je View speciﬁeke locales kunt aanmaken;
- Hoe je locales kunt aanspreken;
- Hoe je locales kunt structureren in mappen;
- Hoe je de taal van je applicatie kunt aanpassen;
- Hoe je d.m.v. de url de taal kunt onthouden;
- Hoe je scope kunt gebruiken om de taal te onthouden.

229 - Instappen in Ruby on Rails 3 - Robin Brouwer

12. Mailer
De Mailer was in Rails 2.3 het meest rampzalige onderdeel van Rails. Het was totaal
onlogisch in elkaar gezet en werkte nou niet bepaald geweldig. Ik zag er altijd tegenop om
een Mailer te maken. In Rails 3 heeft de Mailer een grote make-over gekregen en werkt het
een heel stuk beter dan eerst. Het is nu leuk om mails te versturen vanuit Rails.

12.1 Mailer aanmaken
Wij gaan voor onze applicatie een Mailer maken die een mail stuurt naar het e-mailadres
van een nieuwe gebruiker. In dit mailtje krijgt de gebruiker zijn of haar wachtwoord om in
te loggen.
Als eerste moet de Mailer worden gegenereerd. Hiervoor heb je een rails script die je kunt
gebruiken. Dit werkt hetzelfde als bij een Model.
rails g mailer user_mailer

De conventie bij een Mailer is om eerst een omschrijving te geven wat voor Mailer het is
gevolgd door een liggend streepje en het woord ‘mailer’. Aangezien wij een mail
versturen naar een gebruiker noemen wij onze Mailer ‘user_mailer’.
Bij het genereren wordt in de map /app/mailers een nieuw bestand toegevoegd en krijg je
een nieuwe map in /app/views genaamd user_mailer. Hier komen de Views voor de
mails die we zullen maken. Het nieuwe bestand in de mailers map is de Mailer. Deze ziet
er als volgt uit:
class UserMailer < ActionMailer::Base
default :from => "from@example.com"
end

In de mailer kun je een standaardwaarde meegeven voor waar de e-mail vandaan moet
worden gestuurd. Meestal is dit een ‘noreply’ adres. Laten we dit gelijk aanpassen.
class UserMailer < ActionMailer::Base
default from: "noreply@todomanager.com"
end

230 - Instappen in Ruby on Rails 3 - Robin Brouwer

Nu zullen alle mailtjes standaard vanuit dit adres worden gestuurd. Dit kun je ook per
mail actie regelen, maar meestal is het zo dat er alleen uit één adres wordt gestuurd.

12.2 Acties aanmaken
De volgende stap is het maken van de Mailer acties. Dit zijn acties zoals in de Controller
die een speciale View laten zien. Het verschil is dat deze View wordt verstuurd per mail.
Hiernaast moet je wat extra dingen doen in de Mailer actie om naar het juiste adres te
mailen.
Wij maken een actie die het wachtwoord verstuurt naar een gebruiker die is aangemaakt
via de admin. Deze actie noemen we ‘registration’.

class UserMailer < ActionMailer::Base
default from: "noreply@todomanager.com"
def registration(user)
@user = user
end
end

Je kunt naar deze actie een object sturen van een gebruiker. Deze stoppen we in een
instance variabele, zodat we deze later in de View kunnen aanspreken (zoals je ook bij de
Controller doet). Het volgende wat moet gebeuren is aangeven waar het mailtje naartoe
moet gaan en wat het onderwerp is. Dit kunnen we aan de ‘mail’ method meegeven.

def registration(user)
@user = user
mail(to: user.email, subject: "Your To-Do Manager account has been
created!")
end

Deze mail method roep je aan het einde van de Mailer actie aan. Je geeft een Hash mee
met informatie over de mail. Zo gebruiken we de :to key om aan te geven waar het mailtje
naartoe moet en de :subject key om aan te geven wat het onderwerp moet zijn. Als je goed
hebt opgelet bij het vorige hoofdstuk zie je dat we hier iets fout doen. Er is een tekst en die
zetten we hier gelijk in de Mailer. Dit moet natuurlijk in een locale. Laten we dit een beetje
structureren. Eerst de locale:

231 - Instappen in Ruby on Rails 3 - Robin Brouwer

en:
user_mailer:
registration:
subject: "Your To-Do Manager account has been created!"

Deze locale kunnen we dan als volgt gebruiken binnen de Mailer actie:

def registration(user)
@user = user
@scope = [:user_mailer, :registration]
mail(to: user.email, subject: t(:subject, scope: @scope))
end

We voegen een @scope variabele toe waarin we de scope voor de locale gemakkelijk
kunnen opslaan. Omdat dit een instance variabele is kunnen we deze ook gebruiken voor
de teksten in de mail.
Het aanmaken van de Mail Views is vrij gemakkelijk. Dit werkt namelijk ongeveer
hetzelfde als bij de Controller. Stop in /app/views/user_mailer een bestand genaamd
‘registration.html.erb’. Deze View zal dan worden gebruikt als HTML View. Vaak wordt er
bij een e-mail ook een ‘plain text’ alternatief meegestuurd en dat gaan wij dus ook doen.
Stop deze in dezelfde map en noem deze ‘registration.text.erb’. Rails zal zien dat je twee
templates hebt voor de Mailer actie en zal beide templates versturen. Je hoeft niet een
content type of iets dergelijks op te geven.
Ook Mailer Views kunnen een layout gebruiken. Het verschil is dat je zowel een HTML als
text layout nodig hebt en dat je de naam van de Mailer moet gebruiken. Stop de volgende
twee bestanden in /app/views/layouts: user_mailer.html.erb en user_mailer.text.erb.
Deze twee layouts zullen dan standaard gebruikt worden voor deze Mailer. Je kunt ook
bovenaan de Mailer opgeven welke layout gebruikt moet worden.

class UserMailer < ActionMailer::Base
layout "mailer"
...
end

Zo kun je steeds dezelfde layout gebruiken voor alle Mailers in je applicatie. Laten we
even snel een simpele layout maken voor onze actie. Eerst de HTML.

232 - Instappen in Ruby on Rails 3 - Robin Brouwer

<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
</head>
<body>
<%= yield %>
<p>
Best regards,<br />
The To-Do Manager team
</p>
</body>
</html>

En hierna de tekst variant.

<%= yield %>
Best regards,
The To-Do Manager team

Zoals je ziet gebruiken we hier weer gewone tekst. Dit kun je nu in een locale stoppen.
De volgende stap is het maken van de Views van onze actie. Eerst maken we de locales
aan.

en:
user_mailer:
registration:
subject: "Your To-Do Manager account has been created!"
dear: "Dear %{name},"
welcome: "Welcome to To-Do Manager! Your account has been created and
you can log in by using the following password:"
visit: "Visit the link below to login. Have fun creating To-Do's!"

Nu kunnen we deze locales gebruiken in onze Views:

233 - Instappen in Ruby on Rails 3 - Robin Brouwer

# HTML:
<p><%= t(:dear, scope: @scope, name: @user.name) %></p>
<p><%= t(:welcome, scope: @scope) %></p>
<p><strong><%= @user.password %></strong></p>
<p><%= t(:visit, scope: @scope) %></p>
<p><%= link_to("http://todomanager.com", "http://todomanager.com") %></p>
# TEXT:
<%= t(:dear, scope: @scope, name: @user.name) %>
<%= t(:welcome, scope: @scope) %>
============
<%= @user.password %>
============
<%= t(:visit, scope: @scope) %>
http://todomanager.com

Nu kunnen we heel gemakkelijk de e-mail vertalen naar een andere taal zonder te knoeien
met de Mailer Views. Ik gebruik hier overigens ‘@user.name’ om de naam van de
gebruiker op te halen. Als het goed is heb je geen naam van de gebruiker in de database
staan, dus hier zou je een nieuwe kolom voor moeten maken. Ik ga er vanuit dat je weet
hoe dit moet.
Nu de Views klaar zijn kunnen we verder gaan met het mailen. Voordat ik hierop inga wil
ik nog een paar links geven met extra informatie over de Mailer in Rails. Je kunt er
namelijk nog veel meer mee dan dat ik hier heb laten zien. In de Ruby on Rails guide kun
je vinden wat je zoal kunt doen met de ActionMailer. Het versturen van een bijlage is
bijvoorbeeld ook erg gemakkelijk te regelen. Hiernaast is er een railscast over het
versturen van mails in Rails 3 die je zeker moet bekijken.
Action Mailer Basics
http://guides.rubyonrails.org/action_mailer_basics.html
(TinyURL: http://tinyurl.com/y8t7drk)
Railscast - Action Mailer in Rails 3:
http://railscasts.com/episodes/206-action-mailer-in-rails-3
(TinyURL: http://tinyurl.com/2365dcv)

12.3 Mail versturen
Het volgende wat we moeten doen is de mail versturen. Het versturen van een mail werkt
vrij simpel. Als eerste roep je de Mailer aan en hierna de actie.

234 - Instappen in Ruby on Rails 3 - Robin Brouwer

UserMailer.registration(User.first)

Hierna roep je simpelweg de deliver method aan en de mail zal worden verstuurd.

UserMailer.registration(User.first).deliver

De mail zal echter niet gelijk worden verstuurd, omdat we nog wat gegevens in de
applicatie moeten aanpassen. Hier zometeen meer over. Eerst roepen we de Mailer actie
aan in een callback in de User Model. Dit doen we in een after_create callback.

after_create Proc.new { |user| UserMailer.registration(user).deliver }

Nu zal de mail worden verstuurd als de gebruiker wordt opgeslagen. Aangezien het
slechts één regel is die moet worden uitgevoerd heb ik dit in een Procedure gestopt.

12.4 Environment gegevens
Voordat de mail daadwerkelijk verstuurd kan worden moeten we wat gegevens
aanpassen. Deze gegevens kun je in /conﬁg/environments/development.rb stoppen als je
in development mode zit. Ik vind het echter handiger om deze gegevens in een ‘initializer’
te stoppen. Dit is een Ruby script die je kunt uitvoeren als de server start. Deze stop je in
de map /conﬁg/initializers. Maak hierin een bestand genaamd ‘setup_mail.rb’. Hier
kunnen we onze gegevens voor de mail server stoppen. Zo kunnen we het volgende doen
om ‘sendmail’ te gebruiken:

ActionMailer::Base.delivery_method = :sendmail
ActionMailer::Base.perform_deliveries = true
ActionMailer::Base.raise_delivery_errors = false

De delivery_method geeft aan welke methode je wilt gebruiken om mails te versturen. Zo
kun je ook smtp gebruiken. De perform_deliveries method geeft aan of de e-mail moet
worden verstuurd. Deze kan je uitzetten als je de e-mails niet wilt ontvangen. Je kunt dan
in de log kijken hoe de e-mail eruit ziet. Dit is vooral handig als je in development de
Mailer wilt testen, maar niet de mails wilt ontvangen.
De raise_delivery_errors method zorgt ervoor dat er een error komt als er iets fout gaat bij
het versturen. Dit is echter niet helemaal betrouwbaar en kan ervoor zorgen dat de
applicatie crasht bij de gebruiker. Het kan handiger zijn om de gebruiker er niks van te
laten merken, maar zelf wel een bericht ervan te krijgen. Hiernaast wacht Rails totdat de e235 - Instappen in Ruby on Rails 3 - Robin Brouwer

mail is verstuurd, waardoor de gebruiker lang moet wachten. Ik zet deze method daarom
meestal op false. Als je tijdens development echter problemen hebt met het versturen van
mails kan het handig zijn om deze tijdelijk op true te zetten. Dan zie je precies wat er fout
gaat.
Het versturen van e-mails zal nu niet opeens werken. Je moet namelijk wat extra dingen
doen om sendmail lokaal aan de praat te krijgen. Op een productie server zou de e-mail
wel gelijk kunnen worden verstuurd. Dit ligt aan hoe de server is ingesteld. Lokaal
gebruik ik liever SMTP voor het versturen van e-mails. Hier een voorbeeld die
gebruikmaakt van Gmail:

ActionMailer::Base.delivery_method = :smtp
ActionMailer::Base.smtp_settings = {
address:
	 "smtp.gmail.com",
port:
	 587,
domain:
	 "todomanager.com",
user_name:
	 "username",
password:
	 "password",
authentication:
	 "plain",
enable_starttls_auto: 	 true
}

Hier kun je nu jouw SMTP gegevens invullen. De e-mails zullen dan worden verstuurd
via deze SMTP gegevens. Bij 45north gebruiken we onze eigen SMTP server. Wij gebruiken
hiervoor ongeveer de volgende gegevens:

ActionMailer::Base.delivery_method = :smtp
ActionMailer::Base.smtp_settings = {
address:
	 "smtp.45north.nl",
port:
	 25,
domain:
	 45north.nl",
user_name:
	 "username",
password:
	 "password",
authentication:
	 :login,
enable_starttls_auto:	
false
}
ActionMailer::Base.perform_deliveries = true
ActionMailer::Base.raise_delivery_errors = false

Dat is dus net iets anders dan bij Gmail. Jouw SMTP gegevens kunnen ook iets anders in
elkaar zitten. Als je het niet aan de praat krijgt kun je het beste raise_delivery_errors op
true zetten en allerlei gegevens proberen aan te passen. Doe dit totdat het werkt. Kom je er
dan nog niet uit dan kun je vast het antwoord op Google vinden.

236 - Instappen in Ruby on Rails 3 - Robin Brouwer

Als je nu als admin inlogt en een nieuwe gebruiker aanmaakt zal deze gebruiker onze email ontvangen. Gefeliciteerd, je hebt je eerste e-mail verzonden vanuit Rails!

12.5 Samenvatting
Je kunt nu ook e-mails versturen via Rails. Je applicatie begint steeds meer op een echte
webapplicatie te lijken. Het laatste wat nog ontbreekt is bestanden uploaden. Dit gaan we
in het volgende hoofdstuk voor elkaar krijgen.
Hier nog op een rijtje wat je in dit hoofdstuk hebt geleerd:
- Een nieuwe Mailer aanmaken;
- Mailer acties aanmaken;
- Views creëren voor de Mailer acties;
- Een layout maken voor de Mailer;
- Hoe je een mail kunt versturen;
- Hoe je de SMTP gegevens kunt instellen.

237 - Instappen in Ruby on Rails 3 - Robin Brouwer

13. Uploaden
We zijn alweer bij het laatste hoofdstuk waarin we dieper in Rails duiken. We gaan het
hebben over het uploaden van bestanden en hoe je dit het beste kunt doen in Rails. Zoals
je gewend bent zal dit allemaal in de Model gebeuren. Hoe dit precies werkt zal ik je
uitleggen. Ook zal ik het in het kort hebben over ImageMagick en Paperclip.

13.1 Formulier
Het eerste wat moet gebeuren is het formulier klaarmaken om bestanden te versturen. We
gaan bij het aanmaken van een nieuwe to-do de mogelijkheid geven om een bestand mee
te sturen. Let erop dat je niet een bestand kunt uploaden via AJAX. Dit komt omdat het
onmogelijk is om via JavaScript een bestand te uploaden. Daarom laten we de
bestandselectie in het formulier niet zien als er AJAX wordt gebruikt. Je kunt wel een soort
AJAX uploader maken door het formulier naar een iframe te sturen en de iframe bepaalde
JavaScript terug te laten sturen naar de bovenliggende pagina. Ook zijn er een paar andere
manieren om dit voor elkaar te krijgen. Dat ga ik hier echter niet behandelen.
Het eerste wat moet gebeuren is een attr_accessor toevoegen aan de Model, die we kunnen
aanspreken in het formulier. Deze noemen we asset.
class Todo < ActiveRecord::Base
attr_accessor :asset
end

Vergeet niet om :asset ook toe te voegen aan attr_accessible. Nu kunnen we ons formulier
aanpassen. We moeten hier nog iets extra’s toevoegen om een bestand te kunnen
uploaden.
<%= form_for(@todo, remote: request.xhr?, html: { multipart: true }) do |f|
%>

De :multipart key zorgt ervoor dat er een extra attribuut wordt toegevoegd aan het
formulier. Ons formulier ziet er als volgt uit:
<form method="post" id="new_todo" enctype="multipart/form-data"
class="new_todo" action="/nl/todos" accept-charset="UTF-8">

238 - Instappen in Ruby on Rails 3 - Robin Brouwer

De :mulitpart key zorgt ervoor dat de enctype attribuut wordt gezet. Deze attribuut zorgt
ervoor dat je een bestand kunt versturen via het formulier.

In Rails 3.1 hoef je geen :multipart mee te geven. Dit zal automatisch worden meegegeven als er een ﬁle_ﬁeld in het formulier zit.

De volgende stap is een selectieveld maken voor het bestand.

<%= form_for(@todo, remote: request.xhr?, html: { multipart: true }) do |f|
%>
<p>
<%= f.label(:title, "To-do:") %> <%= f.text_field(:title) %>
<% unless request.xhr? %><%= f.file_field(:asset) %><% end %>
<%= f.submit %>
<% if request.xhr? %>
or <%= link_to("cancel", @todo, remote: true) %>
<% end %>
</p>
<% end %>

We voegen een ﬁle_ﬁeld toe als er geen AJAX request is gedaan. Als je nu de new actie
bekijkt zie je een extra veld. Als je hier een bestand selecteert wordt deze meegestuurd
naar de Controller. Deze kunnen we dan in de Model aanspreken met ‘asset’. Op deze
manier kunnen we het bestand gemakkelijk opslaan.

13.2 Model
Het uploaden van de asset regelen we in een after_save callback. We moeten echter iets
opslaan in de database om later deze asset weer aan te kunnen spreken. We hebben de
naam van het bestand nodig. Hiernaast is het handig om de content_type en grootte van
het bestand te onthouden. Hier maken we een migration voor aan:

rails g migration add_asset_to_todos

Open deze migration en stop het volgende erin:

239 - Instappen in Ruby on Rails 3 - Robin Brouwer

class AddAssetToTodos < ActiveRecord::Migration
def self.up
change_table :todos do |t|
t.string :asset_file_name
t.string :asset_content_type
t.integer :asset_file_size
end
end
def self.down
change_table :todos do |t|
t.remove :asset_file_name
t.remove :asset_content_type
t.remove :asset_file_size
end
end
end

We maken drie nieuwe kolommen aan. Hierin zullen we alles bewaren wat we nodig
hebben voor het uploaden van ons bestand. Voer de migration nu uit:

rake db:migrate

We kunnen nu in de Model werken. Zoals ik al aangaf zullen we het uploaden regelen in
een after_save callback. We moeten echter ook de nieuwe kolommen invullen voordat de
data in de database wordt opgeslagen. We maken daarom ook een before_save callback
aan. Beide callbacks mogen alleen worden uitgevoerd als er iets in de asset attribuut zit.
Het worden dus conditionele callbacks. Stop het volgende in de Todo Model:

before_save :set_asset_attributes, if: :asset?
after_save :upload_asset, if: :asset?
def asset?
asset.present?
end

De ‘asset?’ method kijkt of er iets in de asset attribuut zit. Deze method wordt gebruikt
voor de :if key bij de callbacks. We hebben twee callback methods: set_asset_attributes en
upload_asset. Laten we deze toevoegen aan de Model:

240 - Instappen in Ruby on Rails 3 - Robin Brouwer

def set_asset_attributes
self.asset_content_type = asset.content_type
self.asset_file_size = asset.size
self.asset_file_name = asset.original_filename
end
def upload_asset
directory = "#{Rails.root}/public/assets/#{id}/"
FileUtils.mkdir_p(directory)
path = File.join(directory, asset_file_name)
File.delete(path) if File.exist?(path)
File.open(path, "wb") { |f| f.write(asset.read) }
end

De eerste is een before_save callback. Uit de asset kunnen we de content_type, size en
original_ﬁlename halen. Deze gegevens worden in de drie kolommen gestopt voordat de
to-do wordt opgeslagen.
De tweede method is een after_save callback. Deze zorgt ervoor dat de asset
daadwerkelijk wordt opgeslagen. Als eerste deﬁniëren we de map waar de asset moet
komen en stoppen deze in een lokale variabele.

directory = "#{Rails.root}/public/assets/#{id}/"

De ‘Rails.root’ method geeft het pad naar de root van de Rails applicatie op de server.
Deze hebben we nodig om het bestand ergens op de server op te slaan. Hierna geven we
aan dat we het in de public map willen stoppen en hierin een assets map willen hebben.
Hierin komt dan nog een map met de id van de to-do. Zo zorgen we ervoor dat het
bestand niet iets anders kan overschrijven.

Het is in Rails 3.1 nogal onhandig om een ‘assets’ map toe te voegen aan /public.
Deze zal namelijk automatisch worden aangemaakt voor de JavaScript, CSS en
images. Je kunt bestanden die de gebruiker upload beter in een andere map opslaan.
Denk bijvoorbeeld aan een ‘uploads’ map in /public met hierin de map ‘assets’ voor
gewone bestanden en ‘media’ voor andere bestanden.

Het probleem is echter dat de assets map niet bestaat. Ook is er nog geen map met de id
van de to-do. Deze moet worden aangemaakt.

241 - Instappen in Ruby on Rails 3 - Robin Brouwer

FileUtils.mkdir_p(directory)

Deze method zorgt ervoor dat alle mappen in de String worden aangemaakt in de juiste
volgorde. Als de mappen allemaal al bestaan wordt er ook geen foutmelding of iets
dergelijks teruggegeven. Het is een erg handige manier om mappen te maken op de
server. Je kunt ook ‘Dir.mkdir’ gebruiken, maar dat is helaas een stuk minder ﬂexibel.
We zijn nu klaar om het bestand in de nieuwe map te plaatsen. Hiervoor hebben we drie
regels Ruby nodig:

path = File.join(directory, asset_file_name)
File.delete(path) if File.exist?(path)
File.open(path, "wb") { |f| f.write(asset.read) }

De eerste regel zorgt ervoor dat de locatie naar de map en de bestandsnaam worden
samengevoegd. Je krijgt dan een String die direct naar het bestand verwijst op de server.
Deze wordt in de lokale variabele path gestopt. De tweede regel kijkt of dit bestand al
bestaat en als dit zo is wordt deze verwijderd. De laatste regel zorgt ervoor dat het bestand
daadwerkelijk wordt geschreven op de juiste locatie.
De ‘File.open’ method zorgt ervoor dat er een nieuw bestand wordt aangemaakt. We
geven hier het pad mee, zodat Ruby weet waar het bestand moet worden aangemaakt en
hoe dit bestand heet. De ‘w’ in ‘wb’ staat voor ‘write’ en zorgt ervoor dat we er iets in
kunnen schrijven. De ‘b’ staat voor ‘Binary ﬁle mode’ en zorgt ervoor dat we binaire code
ernaartoe kunnen schrijven. We geven een block mee en roepen op de block variabele de
write method aan om iets in het bestand te schrijven. We roepen de read method aan op de
asset, zodat we de binaire code terugkrijgen van de asset. Deze wordt dan via de write
method in het bestand gestopt. En zo hebben we ervoor gezorgd dat het bestand is
geüpload naar de server.
De volgende stap is om terug te kunnen verwijzen naar dit bestand vanuit de View. Je wilt
dat de gebruiker het bestand kan downloaden. Je zou bij elke link het volgende kunnen
doen:

<%= link_to("Download", "/assets/#{todo.id}/#{todo.asset_file_name}") %>

Dit is echter nogal omslachtig. Laten we dit in de Model stoppen:

242 - Instappen in Ruby on Rails 3 - Robin Brouwer

def asset_url
"/assets/#{id}/#{asset_file_name}"
end

Nu kunnen we het volgende in de View stoppen:

<%= link_to("Download", todo.asset_url) %>

We willen deze link alleen laten zien als de asset daadwerkelijk bestaat. In de Model
kunnen we hiervoor een method aanmaken:

def asset_present?
asset_file_name.present?
end

Nu kunnen we een if-statement toevoegen aan onze link:

<%= link_to("Download", todo.asset_url) if todo.asset_present? %>

En zo gemakkelijk is het om het bestand te downloaden. Je kunt de andere kolommen
gebruiken om te laten zien hoe groot het bestand is en wat voor type bestand het is. Dat is
weer geheel aan jou.

13.3 ImageMagick
Als je met beelden werkt is het handig om ImageMagick te gebruiken. Dit is een library
om beelden te kunnen bewerken. Zo kun je heel gemakkelijk thumbnails maken en
bestanden converteren. Er zijn voor ImageMagick een aantal Ruby gems die het
gemakkelijker maken om met ImageMagick te werken. Een gem die ik vaak gebruik is
‘RMagick’. Het is niet de snelste gem, maar kan ermee door.
Het lastige aan ImageMagick is het installeren. Het is namelijk niet heel gemakkelijk om
ImageMagick aan de praat te krijgen op je Mac. Ik heb geen idee of het gemakkelijker is op
een Windows machine. Maar als je het eenmaal aan de praat hebt kan het verdomde
handig zijn. Als iemand een beeld upload kun je deze converteren naar JPG en verkleinen,
zodat je het beeld ook echt kan laten zien aan gebruikers.
Hier een klein voorbeeld hoe dit kan werken met onze assets. We gaan hier nu wel vanuit
dat er altijd een beeld wordt geüpload.
243 - Instappen in Ruby on Rails 3 - Robin Brouwer

directory = "#{Rails.root}/public/assets/#{id}/"
FileUtils.mkdir_p(directory)
original = File.join(directory, asset_file_name)
resized = File.join(directory, "resized_#{asset_file_name}")
img = Magick::Image.from_blob(asset.read)[0]
img.format = "JPG"
img.write(original)
img.resize_to_fit!(780, 400)
img.write(resized)

We slaan nu twee beelden op. De eerste is het originele beeld geconverteerd naar JPG en
de tweede is een JPG die maximaal 780x400 pixels mag zijn. Je kunt nog veel meer met
RMagick doen. Bekijk de documentatie voor meer uitleg hierover.
RMagick Download Page
http://rmagick.rubyforge.org

13.4 Paperclip
Als je bestanden wilt uploaden kun je natuurlijk zelf alle code hiervoor schrijven. Je hebt
echter een aantal handige gems die het meeste werk voor je doen. De gem die ik meestal
gebruik heet ‘Paperclip’. Dit is een ontzettend handige gem waarmee je erg gemakkelijk
bestanden kunt uploaden. Hiernaast kun je erg gemakkelijk meerdere thumbnails
aanmaken als er beelden worden geüpload. Het werkt behoorlijk simpel en zorgt ervoor
dat je niet steeds dezelfde code overnieuw hoeft te schrijven.
Hier een klein voorbeeld van hoe het ongeveer werkt. Zoals je al verwacht moet je alles in
een Model stoppen. Om een gem te installeren moet je iets in de Gemﬁle stoppen. In het
geval van Paperclip doe je het volgende:

gem "paperclip"

Nu moet je in de terminal het volgende uitvoeren om de gem te installeren en toe te
voegen aan de applicatie:

bundle install

244 - Instappen in Ruby on Rails 3 - Robin Brouwer

Als je hierna de server opstart kun je de gem gebruiken in de applicatie. Je kunt dan
bijvoorbeeld het volgende in de Model stoppen:

class Todo < ActiveRecord::Base
has_attached_file :asset, styles: {
medium: "300x300>",
thumb: "100x100>"
}
end

De paperclip gem gaat er vanuit dat je een aantal kolommen in de tabel van de Model hebt
staan:

asset_file_name
asset_content_type
asset_file_size
asset_updated_at

Alleen de ‘asset_ﬁle_name’ kolom is verplicht. Zoals je ziet zijn dit dezelfde kolommen als
ons zelfgemaakte voorbeeld. Dit heb ik gedaan zodat je gemakkelijk Paperclip kunt
uittesten. De has_attached_ﬁle zorgt ervoor dat alles voor je wordt geregeld: de
attr_accessor, het zetten van de kolommen, het uploaden en het maken van thumbnails.
Ook wordt er een speciale mapstructuur gebruikt die je kunt aanpassen door extra opties
mee te geven. Wat ik ook erg handig vind is hoe je de bestanden kunt aanspreken nadat ze
zijn geüpload.

<%= image_tag(@todo.asset.url) %>
<%= image_tag(@todo.asset.url(:medium)) %>
<%= image_tag(@todo.asset.url(:thumb)) %>

De eerste regel geeft de link naar het originele bestand. De tweede en derde regels geven
de link naar de thumbnails. Er is nog veel meer wat je met Paperclip kunt doen. Ik raad je
daarom ook aan om een keer een kijkje te nemen. Alles over deze gem kun je vinden op de
Github pagina ervan:
Github.com - Paperclip
https://github.com/thoughtbot/paperclip

13.5 Samenvatting
Dit was alweer het laatste hoofdstuk waarin we ons verder hebben verdiept in Rails. Je
weet nu hoe je bestanden kunt uploaden en bent klaar om je eigen Rails applicaties te
245 - Instappen in Ruby on Rails 3 - Robin Brouwer

maken. Wat je nu allemaal weet is pas de basis, dus daarom zal ik in het volgende
hoofdstuk je op weg helpen om nog beter te worden in Rails.
Hier nog op een rijtje wat je in dit hoofdstuk hebt geleerd:
- Hoe je via een formulier een bestand kunt sturen naar de server;
- Hoe je dit bestand kunt uploaden naar de server via de Model;
- Hoe je bepaalde data uit een bestand kunt halen;
- Hoe je een bestand kunt opslaan op de server;
- Hoe je het bestand hierna weer kunt downloaden;
- Wat ImageMagick is en hoe je het kunt gebruiken;
- Wat Paperclip is en hoe je het kunt gebruiken.

246 - Instappen in Ruby on Rails 3 - Robin Brouwer

14. Tips
Je bent alweer bij het laatste hoofdstuk van dit boek aangekomen. Ik heb je veel laten zien
en als het goed is heb je ook echt veel geleerd over Ruby en Rails 3. Je begrijpt de ﬁlosoﬁe
achter Rails, snapt de MVC structuur, kunt werken met de routing in Rails, weet hoe je een
CRUD moet maken, kunt AJAX toevoegen aan je applicatie, teksten in locales stoppen en
je kunt gemakkelijk mails versturen en bestanden uploaden. Wat je nu echter allemaal
weet is pas de basis. Het is wel een basiskennis waarmee je goed verder kunt in je Rails
loopbaan.
Er is nog heel veel extra wat je kunt leren over Rails. In dit hoofdstuk zal ik je proberen
verder op weg te helpen. Ik geef handige links en tips hoe je je nog meer kunt verbeteren
en leg uit wat gems en plugins voor je kunnen betekenen. Je hebt nog een lange weg te
gaan om een echte Ruby on Rails pro te worden. We gaan daarom maar snel aan de slag!

14.1 Plugins en gems
Ik heb het al een paar keer gehad over zogenaamde plugins en gems. In dit hoofdstuk zal
ik verder uitleggen wat een plugin of gem is, waarom je ze moet gebruiken en hoe je ze
kunt gebruiken. Ook zal ik een aantal voorbeelden geven van plugins en gems die ik
gebruik en zal ik in het kort vertellen over een aantal gems die ik heb gemaakt.

14.1.1 Wat zijn het?
Wat houdt een plugin nou precies in? En wat is het verschil tussen een plugin en gem?
Beide vragen zijn eigenlijk vrij simpel te beantwoorden.
Plugins en gems zijn brokken functionaliteit die je erg gemakkelijk kunt toevoegen aan je
applicatie. Door het toe te voegen krijg je een heleboel extra mogelijkheden binnen je
applicatie. Zo kun je extra helper methods krijgen en nieuwe methods in de Model
aanspreken. Ook zijn er complete oplossingen voor het inloggen van gebruikers, het
uploaden van bestanden en het toevoegen van paginering in je applicatie. De
mogelijkheden zijn eindeloos.
Het verschil tussen een gem en plugin is dat een gem één keer op je computer wordt
geïnstalleerd en een plugin steeds per applicatie opnieuw moet worden geïnstalleerd. Op
je computer heb je een speciale map voor alle RubyGems (afgekort ‘gem’). Als je in je
applicatie een gem wilt gebruiken zal deze vanaf die locatie worden ingeladen. Bij een
plugin zul je deze per project opnieuw moeten installeren. Deze komt dan in je applicatie
te zitten in de /vendor/plugins map. Als je een plugin vaak gebruikt en er is een gem
hiervan kun je het beste deze gebruiken. Als je dingen wilt aanpassen aan de
functionaliteit kun je het beste een plugin installeren.

247 - Instappen in Ruby on Rails 3 - Robin Brouwer

14.1.2 Waarom zou je ze gebruiken?
Het antwoord op deze vraag zou eigenlijk al duidelijk moeten zijn. Je gebruikt ze om
gemakkelijk extra functionaliteit toe te voegen aan je applicatie. Veel dingen die je wilt
doen zijn al een keer gedaan en vaak zijn deze in een gem of plugin gestopt. Het is een
stuk gemakkelijker en minder tijdrovend om deze brokken functionaliteit te gebruiken.
Vaak zijn het ook betere oplossingen omdat meerdere mensen aan de code hebben
gewerkt. De oplossing die ze geven is vaak ook een stuk beter uitgedacht.
Een gem of plugin gebruiken scheelt dus veel tijd en heeft een aantal andere voordelen. Er
zijn echter een paar kanttekeningen te plaatsen. Allereerst is het niet handig om als
beginnende Rails developer veel gems en plugins te gebruiken. Het is handiger als je eerst
zelf weet hoe je de functionaliteit kunt maken. Daar leer je een heel stuk meer van dan het
werk van iemand anders klakkeloos over te nemen. Vandaar dat ik in dit boek heb laten
zien hoe je een inlog- en uploadsysteem kunt maken. Dit kan ook met een gem, maar als ik
dat alleen zou laten zien had je er niks van geleerd.
De tweede kanttekening die ik wil plaatsen is dat niet alle gems en plugins perfect
werken. Vaak zitten er meerdere bugs in die je of voor lief moet nemen of moet aanpassen.
En als je het als gem hebt geïnstalleerd is het aanpassen iets lastiger, aangezien de gem ook
gebruikt kan worden voor andere projecten.
De laatste kanttekening die ik wil plaatsen is dat je niet voor elk onderdeel een gem nodig
hebt. Soms is het een stuk handiger om de functionaliteit uit te schrijven, zodat je een stuk
meer ﬂexibiliteit hebt. Een gem kan veel van deze ﬂexibiliteit wegnemen. Zo schrijf ik
liever zelf mijn inlogsysteem en gebruik ik hier geen gem voor. Wat ik hiervoor wel handig
vind is het gebruikmaken van een generator. Deze kun je als gem installeren. Vanuit de
terminal kun je dan een aantal bestanden genereren.

14.1.3 Hoe kun je ze gebruiken?
Een gem installeren werkt net iets anders dan een plugin installeren. Een plugin
installeren is vrij simpel. Het enige lastige is dat je de url naar de plugin moet opzoeken.
Als je deze eenmaal weet is het een kwestie van de terminal openen en het volgende
uitvoeren:

rails plugin install git://github.com/RobinBrouwer/gritter.git

Nu wordt de plugin geïnstalleerd in de /vendor/plugins map. Als je de server opnieuw
start zal deze te gebruiken zijn.
Een gem installeren is ook heel gemakkelijk. Er zijn twee manieren waarop je dit kunt
doen. De eerste manier is door RubyGems te gebruiken.

248 - Instappen in Ruby on Rails 3 - Robin Brouwer

gem install gritter

Nu zal de gem op je computer worden geïnstalleerd. Je kunt kijken welke gems je allemaal
hebt door het volgende commando uit te voeren:

gem list

Je krijgt alle gems op een rijtje te zien en ziet bij elke gem welke versies er allemaal zijn
geïnstalleerd. Wil je weten welke gems er allemaal zijn? Dan kun je een kijkje nemen op
rubygems.org.
RubyGems.org | Your community gem host
http://rubygems.org/
De tweede manier is het gebruikmaken van de bundler gem. Deze gem maakt het heel
gemakkelijk om alle gems voor jouw applicaties te bundelen. Je kunt heel gemakkelijk
bepalen welke gems je gebruikt en welke versies hiervoor nodig zijn. De bundler gem
installeert ook gelijk gems die je nog niet op je computer hebt staan.
Het handige hieraan is dat je precies kunt bepalen welke versies van de gems je gebruikt
in je applicatie. Als je een oudere versie van een gem gebruikt en je installeert een nieuwe
versie op je computer, zal nog steeds de oudere versie voor je applicatie in gebruik worden
genomen. Hierdoor krijg je geen irritante conﬂicten als je voor een andere applicatie een
nieuwere versie gebruikt.
Zoals je al hebt gezien in dit boek gebruikt Ruby on Rails bundler om gems te bundelen en
te installeren. Je hebt meerdere keren het volgende commando voorbij zien komen:

bundle install

Als je dit commando uitvoert wordt er gekeken naar de Gemﬁle in je applicatie, worden
de gems gebundeld en - mocht je een gem niet hebben - geïnstalleerd.
Bundler installeren is vrij gemakkelijk. Dit doe je via RubyGems.

gem install bundler

249 - Instappen in Ruby on Rails 3 - Robin Brouwer

Nu kun je de Gemﬁle openen en bepalen welke gems je gaat gebruiken voor je applicatie.
Stop bijvoorbeeld het volgende erin:

gem "gritter"

Je roept de ‘gem’ method aan en geeft de naam van de gem als een String mee. Je kunt hier
ook een versienummer meegeven.

gem 'will_paginate', '~> 3.0.beta'

Hier zal de ‘3.0.beta’ versie worden gebruikt of een nieuwere versie als deze gevonden kan
worden. Je kunt natuurlijk ook een speciﬁeke versie meegeven.
Na het opslaan van de Gemﬁle moet je het volgende in de terminal uitvoeren:

bundle install

Dit zorgt ervoor dat alle gems in de Gemﬁle worden gekoppeld aan je applicatie. Als een
gem niet is geïnstalleerd zal deze ook gelijk worden geïnstalleerd. Als je nu de server
opnieuw start is de gem te gebruiken.
Naast ‘install’ kun je ook andere dingen meegeven aan bundler. Zo heb je ‘update’ om alle
gems die je gebruikt ook gelijk te updaten en kun je alle gebruikte gems opslaan in de
map /vendor/bundle. Voor meer informatie kun je terecht op de website van bundler.
Bundler: The best way to manage Ruby applications
http://gembundler.com/
En zo gemakkelijk is het om een plugin of gem te installeren. Je kunt nu alle
functionaliteit, die in de documentatie van de gem of plugin staat, gebruiken.

14.1.4 Een aantal handige gems
Om je op weg te helpen zal ik in het kort drie handige gems voor Rails behandelen. Ik heb
Paperclip al behandeld, dus deze ga ik hier niet nog een keer behandelen. Paperclip is ook
een erg handige gem, dus ga die zeker een keer bekijken.
Vergeet niet wat ik heb gezegd: eerst zelf proberen de functionaliteit te bouwen voordat je
een gem gaat gebruiken. Dit zorgt er ook voor dat je de gem beter zult begrijpen en kunt
aanpassen als er fouten optreden. Als je wat beter wordt in Rails kun je gems installeren
zonder hierover na te denken. Het gaat vooral om het leerproces in het begin.
250 - Instappen in Ruby on Rails 3 - Robin Brouwer

will_paginate
Paginering in een applicatie is vrij belangrijk en zorgt ervoor dat de gebruiker bij een
overzicht niet een ontzettend lange lijst krijgt te zien. De will_paginate gem zorgt ervoor
dat je heel gemakkelijk paginering kunt toevoegen. Het is één van mijn favoriete gems. Als
ik paginering nodig heb gebruik ik dit.
Stop het volgende in de Gemﬁle:
gem "will_paginate", "~> 3.0.beta"

Het werkt in drie delen: de Model, View en Controller. Allereerst de Model. Hierin kun je
opgeven hoeveel pagina’s er moeten worden getoond.
class Post < ActiveRecord::Base
self.per_page = 50
end

In de Controller moet je dan de ‘paginate’ method aanspreken op de Model.
class PostsController < ApplicationController
def index
@posts = Post.paginate(page: params[:page])
end
end

Hieraan kun je extra argumenten meegeven, zoals :per_page (om hetgeen in de Model te
overschrijven) en :order. De :page key moet je altijd meegeven aan deze method. Hierdoor
weet will_paginate welke pagina moet worden getoond. Deze stopt will_paginate
namelijk standaard in de url.
Het laatste wat je moet doen is iets in de View stoppen.
<%= will_paginate(@posts) %>

Op deze plaats komt nu de paginering te staan. Je kunt hier allerlei extra opties aan
meegeven om bijvoorbeeld van url parameter te wisselen. Dit kun je allemaal vinden op
de Github pagina van deze gem. Naast will_paginate heb je ook een andere gem die sinds
Rails 3.0 veel volgers heeft gekregen: kaminari.
251 - Instappen in Ruby on Rails 3 - Robin Brouwer

Github.com - will_paginate
https://github.com/mislav/will_paginate/tree/rails3
nifty_generators
De maker van Railscasts.com (Ryan Bates) heeft een ontzettend handige gem geschreven
waarmee je heel gemakkelijk CRUD’s en andere dingen kunt genereren. Het is niet een
gem zoals paperclip of will_paginate waarmee je bepaalde methods aanroept in de gem. Je
roept bepaalde generators aan in de terminal die Models, Controllers en Views voor je
genereren. Het zorgt ervoor dat je altijd nog de functionaliteit kunt aanpassen, zonder in
de gem of plugin te duiken.
Stop het volgende in de Gemﬁle:
gem "nifty-generators", group: :development

Hier een voorbeeld die Ryan Bates geeft op zijn Github pagina:
rails g nifty:scaffold recipe name:string index new

Er zal nu een zogenaamde ‘scaffold’ worden gemaakt. Dit zijn allerlei bestanden in je
applicatie die je basisfunctionaliteit bieden. Deze bestanden kun je dan overschrijven. Als
je een beginnende Rails programmeur bent raad ik het je af om scaffolds te gebruiken,
maar als je beter wordt zal dit ontzettend handig blijken.
Het volgende zal worden gegenereerd:
gemfile
create
create
create
create
create
create
create
create
route
create

mocha
app/models/recipe.rb
test/unit/recipe_test.rb
test/fixtures/recipes.yml
db/migrate/20110203202021_create_recipes.rb
app/controllers/recipes_controller.rb
app/helpers/recipes_helper.rb
app/views/recipes/index.html.erb
app/views/recipes/new.html.erb
resources :recipes
test/functional/recipes_controller_test.rb

De scaffold die hier gemaakt wordt is voor een Recipe Model. De Model zal worden
gemaakt en de migration hiervoor zal er ook gelijk zijn. In deze migration zit gelijk een
252 - Instappen in Ruby on Rails 3 - Robin Brouwer

‘name’ kolom. Hiernaast zal er ook gelijk een Controller worden gemaakt met de index,
new en create acties. De Views zullen ook gelijk gegenereerd worden met alle benodigde
HTML erin. Je krijgt dan een overzicht (index) en een formulier om een nieuw recept toe te
voegen (new).
Je kunt er ook heel gemakkelijk voor zorgen dat alle CRUD acties worden gemaakt. Dit
doe je door geen Controller acties mee te geven aan command in de terminal. Je kunt dus
met één regel een heel CRUD maken.

rails g nifty:scaffold recipe name:string

Naast de scaffold voor Model biedt nifty-generators ook de mogelijkheid om authenticatie
toe te voegen aan je applicatie. Zoals ik al aangaf gebruik ik liever zoiets om authenticatie
te regelen dan een gem die het allemaal voor me doet. Als je meer wilt weten over deze
gem kun je de Github pagina bekijken.
Github.com - nifty-generators
https://github.com/ryanb/nifty-generators
inherited_resources
Ik heb in dit boek laten zien hoe je een CRUD kunt maken. Wat je misschien is opgevallen
is dat elke Controller er ongeveer hetzelfde uitziet. Je zou denken: is dit wel volgens het
DRY principe? Ik vind van wel. Vaak moet je in de Controller een klein ding extra doen en
dan kan het handig zijn als alles zo is uitgeschreven. Het is dan ook meestal niet zo dat
hetzelfde moet gebeuren bij alle andere Controllers. Ik kan het mezelf wel voorstellen dat
je niet elke keer de Controller opnieuw wilt uitschrijven. Hier kun je een generator voor
gebruiken zoals nifty_generators, maar er is ook een andere oplossing:
inherited_resources.
Stop het volgende in de Gemﬁle:
gem "inherited_resources", "~> 1.2.1"

Met deze gem kun je een extra abstractielaag over de Controller gooien waar je een stuk
minder code hoeft te stoppen om hetzelfde resultaat te krijgen. Dit werkt als volgt:
class ProjectsController < InheritedResources::Base
actions :all
end

253 - Instappen in Ruby on Rails 3 - Robin Brouwer

Zoals je ziet erf je niet meer van ApplicationController maar van de inherited_resources
gem. Je kunt nu in de Controller de ‘actions’ method aanroepen om aan te geven welke
van de CRUD acties je wilt aanmaken. Met :all kun je aangeven dat je alle acties wilt
gebruiken. Je kunt ook dit doen:

class ProjectsController < InheritedResources::Base
actions :index, show
end

Nu worden alleen de show en index acties voor je gemaakt. Ook kun je een :except key
meegeven als je de :all optie meegeeft.

class ProjectsController < InheritedResources::Base
actions :all, except: [:edit, :update, :destroy]
end

Nu zullen alle acties worden aangemaakt, behalve degene die je opgeeft in de Array. Zoals
je ziet is dit een stuk minder code dan geheel zelf de acties uitschrijven. Het is een
ontzettend handige gem. Het voegt echter wel een extra abstractielaag toe aan je
Controller. Het aanpassen van bepaalde acties werkt net iets anders dan je gewend bent.
Als je echter de gem helemaal begrijpt is het een genot om mee te werken. Zeker een
aanrader als je al veel ervaring hebt met Rails.
Let op: je moet alleen deze gem gebruiken als je al ontzettend veel CRUD’s hebt gemaakt.
Het is bedoeld voor mensen die al een langere tijd met Rails werken. Ga dus niet gelijk
deze gem gebruiken. Maak eerst zelf de CRUD’s. Daar leer je echt veel meer van. Als je
later wat beter bent geworden kun je alle CRUD’s die je hebt gemaakt vervangen met
inherited_resources. Ook gelijk een leuke oefening om inherited_resources beter te leren
kennen.
Er is ontzettend veel meer te vertellen over deze gem. Daar is dit boek niet voor, dus neem
zelf een kijkje door op de onderstaande link te klikken.
Github.com - inherited_resources
https://github.com/josevalim/inherited_resources

14.1.5 Mijn gems
Op het moment van schrijven heb ik drie vrij simpele gems gemaakt: gritter, ie6_ﬁxer en
deﬁne_images. Het kan zo zijn dat op het moment dat jij dit leest ik een aantal extra gems
heb gemaakt. Om te kijken of ik dit ook echt heb gedaan kun je naar mijn Github pagina
afreizen: http://github.com/RobinBrouwer. Hier kun je al mijn open-source git
repositories vinden. Ik zal nu in het kort mijn drie gems behandelen.
254 - Instappen in Ruby on Rails 3 - Robin Brouwer

gritter
Ik zal beginnen met de gem waar ik het meest trots op ben. Dit is een gem die
gebruikmaakt van een jQuery plugin genaamd ‘gritter’. Hiermee kun je heel gemakkelijk
Growl notiﬁcaties laten zien in je applicatie. Erg handig om de gebruiker feedback te
geven op wat hij of zij doet. Ik stop het meestal in mijn applicaties en ben er erg tevreden
over. Deze gem kun je overigens ook als plugin gebruiken.
Stop het volgende in de Gemﬁle:
gem "gritter"

De handigste functionaliteit in gritter is de ‘gﬂash’ helper. Dit is een vervanging voor de
ﬂash notiﬁcaties die in Rails zitten. Het werkt vrij simpel. Allereerst moet je aangeven in
de Controller wat voor bericht je wilt laten zien:
class ProductsController < ApplicationController
def create
gflash(notice: true, success: true)
end
end

Wat je dan moet doen is in een speciaal gegenereerd bestand in de locales map,
‘gﬂash.en.yml’ genaamd, het volgende toevoegen:
en:
gflash:
products:
create:
notice: "The product has no category"
success: "The product has been saved"

Hierbij is ‘products’ de Controller naam en ‘create’ de naam van de actie. Hier kun je dan
voor de notiﬁcaties die je hebt opgegeven in de Controller de teksten zetten. In de layout
kun je dan het volgende stoppen:

255 - Instappen in Ruby on Rails 3 - Robin Brouwer

In de <head>:
<%= include_gritter_and_jquery %>
Net voor </body>:
<%= gflash %>

De eerste helper is om zowel gritter als jQuery in je HTML te stoppen. De tweede helper is
om de gﬂash notiﬁcatie te laten zien. Als je nu de create actie uitvoert krijg je rechts
bovenin twee mooie Growl notiﬁcaties te zien met de teksten uit de locale en een
corresponderend beeld.

In Rails 3.1 werkt dit net iets anders. Hoe dit precies werkt kun je terugvinden in
de README van gritter.

De gem zorgt er dus voor dat je heel gemakkelijk mooie notiﬁcaties kunt laten zien. Er zijn
nog een aantal extra methods die je kunt aanspreken in deze gem, dus neem zeker een
kijkje. Voor meer informatie over gritter kun je de Github pagina bekijken.
Github.com - gritter
https://github.com/RobinBrouwer/gritter
ie6_ﬁxer
Iedereen die websites ontwikkelt is er wel eens tegenaan gelopen: Internet Explorer 6. Er
zijn helaas nog mensen die deze verouderde browser gebruiken en soms willen klanten
heel graag dat je de browser ondersteunt (zij gebruiken immers deze browser). Veel
dingen die in Firefox, Chrome of Safari er goed uitzien kunnen ronduit rampzalig zijn in
IE6. Dit moet je dan oplossen. Dit kan vaak met allerlei CSS hacks. Dit zorgt er echter voor
dat je CSS er nogal lelijk uit gaat zien (tenzij je alles in een apart CSS bestand stopt voor
Internet Explorer). Hiernaast moet je al deze hacks zoeken op het internet en handmatig in
je project stoppen. Daarom heb ik een gem geschreven voor Rails die een aantal bekende
IE6 ﬁxes bundelt. Deze gem zorgt er ook voor dat je heel gemakkelijk deze ﬁxes kunt
toevoegen met Ruby. Deze gem kun je overigens ook als plugin gebruiken.
Stop het volgende in de Gemﬁle:
gem "ie6_fixer"

De gem werkt vrij simpel. Hier een klein voorbeeld van wat je in de layout kunt stoppen:

256 - Instappen in Ruby on Rails 3 - Robin Brouwer

<% ie6_fixer do %>
<%= png_fix("#id_name", ".class_name", "#content img") %>
<%= css3_fix("#content", ".footer") %>
<% end %>

De ie6_ﬁxer helper zorgt ervoor dat alle IE6 ﬁxes die je in het blok meegeeft alleen worden
getoond in IE6. De HTML, CSS en JavaScript die nodig is om de ﬁxes uit te voeren wordt
gegenereerd door de helpers die je aanroept in het blok. Zo zorgt de png_ﬁx helper ervoor
dat de transparante PNG’s goed worden getoond in IE6.
Naast de hierboven genoemde voorbeelden zijn er een aantal andere IE6 ﬁxes die je kunt
gebruiken. Er is zelfs een helper om IE6 gebruikers helemaal niks te laten zien (de ‘kill_ie6’
method) of een waarschuwing te geven (de ‘warn_ie6’ method). Ook kun je heel
gemakkelijk andere versies van Internet Explorer aanspreken. Alles hierover kun je op de
Github pagina vinden. Als je suggesties hebt voor andere hacks kun je het bij de issues
aangeven.
Github.com - ie6_ﬁxer
https://github.com/RobinBrouwer/ie6_ﬁxer
deﬁne_images
Mijn laatste gem is een ontzettend simpele gem die toch erg handig kan zijn. Je kunt
hiermee heel gemakkelijk <img> tags deﬁniëren in de ApplicationHelper en deze
aanspreken in de Views. Vaak heb je namelijk <img> tags met allerlei attributen, zoals de
breedte, hoogte, titel en alternatieve tekst. Als je dan een beeld hebt die op meerdere
pagina’s moet komen wil je natuurlijk niet steeds deze attributen meegeven. Dat is niet
echt DRY. Deze gem lost dat dus op. Deze gem kun je ook als plugin gebruiken.
Stop het volgende in de Gemﬁle:
gem "define_images"

Je stopt het volgende in de ApplicationHelper:
module ApplicationHelper
define_image :rails, "rails.png", alt: "Ruby on Rails logo", width: 50,
height: 64, title: "Ruby on Rails logo"
end

Nu kun je dit beeld heel gemakkelijk aanspreken door het volgende in de View te stoppen:
257 - Instappen in Ruby on Rails 3 - Robin Brouwer

<%= img(:rails) %>

Scheelt een heleboel rotzooi in je View. Meer weten over deze gem of heb je suggesties om
het te verbeteren? Bekijk dan de Github pagina en laat eventueel een bericht achter bij de
issues.
Github.com - deﬁne_images
https://github.com/RobinBrouwer/deﬁne_images

14.1.6 Gem executables
Sommige gems hebben zogenaamde ‘executables’ die je kunt uitvoeren vanuit de terminal.
Je kunt zonder Ruby te schrijven deze gems uitvoeren door een simpel commando in de
terminal te typen. De gem zorgt er dan voor dat er een bepaald script wordt uitgevoerd.
Een gem executable die je al meerdere keren hebt gebruikt is ‘rake’.
rake db:migrate
rake db:seed

Rake wordt veel gebruikt in de Ruby-wereld. Veel gems gebruiken rake om bepaalde
scripts te draaien. Rake is echter niet de enige manier om bepaalde Ruby scripts uit te
voeren. Er zijn genoeg gems die hun eigen executable installeren op je computer, zodat je
vanuit de terminal de functies van die gem kunt gebruiken.
Als je een gem in de bundle van je applicatie hebt gestopt en je wilt de executable van deze
gem uitvoeren in de terminal, dan is het mogelijk dat je een foutmelding krijgt. Vaak heb je
namelijk veel verschillende versies van gems geïnstalleerd op je computer. Als je dan een
gem executable hiervan uitvoert zal altijd de laatste versie op je computer worden
gebruikt. Soms zorgt dit ervoor dat het script niet werkt, omdat jouw applicatie een
andere versie in gebruik heeft.
Rake is hier een goed voorbeeld van. Voer eens het volgende uit in de terminal:
gem list rake

Als het goed is krijg je te zien welke versies van rake je allemaal hebt geïnstalleerd. De
nieuwste versie van rake is 0.9.2. Veel Ruby programmeurs gebruiken echter versie 0.8.7 in
hun Rails 3 applicaties. Als ze de nieuwste versie van rake hebben geïnstalleerd en ze
voeren een migrate uit, dan krijgen ze de volgende foutmelding te zien:
258 - Instappen in Ruby on Rails 3 - Robin Brouwer

You have already activated rake 0.9.2, but your Gemfile requires
rake 0.8.7. Consider using bundle exec.

De nieuwste versie van rake wordt gebruikt, waardoor het niet werkt. Wat je moet doen is
ervoor zorgen dat de rake versie wordt gebruikt van de applicatie. Hiervoor gebruik je
‘bundle exec’.

bundle exec rake db:migrate

De ‘bundle exec’ command zorgt ervoor dat de gem wordt gebruikt die in de bundle van
de applicatie staat. Zorg er dus voor dat je ‘bundle exec’ gebruikt als je een gem uit je
bundle wilt uitvoeren. Je weet dan tenminste zeker dat alles goed zal werken.

14.2 Debuggen
Programmeren bestaat voor een groot gedeelte uit het debuggen van de code. Kleine
foutjes zorgen ervoor dat je applicatie niet correct werkt en jij moet dan maar zoeken waar
die fout zit. Dat is nou niet bepaald leuk werk en gelukkig hebben Ruby en Rails een
aantal handige manieren om de fouten op te sporen. Ik zal hier de belangrijkste van laten
zien.

14.2.1 raise
De eerste is de raise method. Hiermee kan je je applicatie of script expres laten crashen. Zo
kun je kijken of het script wel een bepaald stuk code uitvoert. Dit is vooral handig als je
meerdere if-statements hebt. Dan kun je precies kijken waar je script wel en niet komt.
if awesome == "Rails 3"
puts "Alles gaat goed"
else
raise
end

De raise method geeft ook een heleboel extra informatie mee, zoals waar de raise precies
gebeurt, wat voor parameters er zijn meegestuurd en langs welke classes het script is
gegaan. Probeer maar eens een pagina in je applicatie te laten crashen en bekijk wat voor
informatie er allemaal wordt gegeven.
Het handige aan de raise method is dat je ook iets mee kunt geven. Dit wordt dan getoond
op de pagina waar de foutmelding komt. Het enige wat je moet weten is dat je hetgeen

259 - Instappen in Ruby on Rails 3 - Robin Brouwer

wat je wilt laten zien altijd naar een String moet converteren. Hier heb je twee methods
voor: inspect en to_yaml.

if @todo.save
raise @todo.inspect
else
raise @todo.to_yaml
end

De inspect method zorgt ervoor dat het object naar een String wordt geconverteerd op één
regel. Dit kan handig zijn als je iets wilt bekijken waar weinig data inzit. Als dit niet zo is
kun je beter ‘to_yaml’ gebruiken. Dit zorgt ervoor dat alle data in het object wordt
omgezet naar YAML (zoals de locales). Dit geeft een stuk meer overzicht over het object.
Met deze twee methods kun je dus heel gemakkelijk kijken wat er precies fout gaat in een
object. Samen met de raise method kun je dan goed achterhalen wat er fout gaat in de
applicatie.

14.2.2 debug
Als je allerlei informatie uit een object wilt halen, maar niet de applicatie wilt crashen kun
je de debug method gebruiken. Deze gebruik je in de View.
<%= debug(@todo) %>

Nu zal op die plaats in de View het object worden getoond. Ook zal hier gelijk de
‘to_yaml’ method worden gebruikt. Erg handig om objecten even snel te bekijken in de
View.

14.2.3 logger
De laatste methode om te debuggen in Rails is het logger object. Hierop kun je
verschillende methods aanroepen om data in je logbestand te stoppen. Zoals je weet
worden de logs bewaard in de /log map. De data die je meegeeft aan de logger method
zal dan hierin worden gestopt en kun je zien in de terminal als je de server hebt gestart.
Er zijn een aantal verschillende logger methods.

260 - Instappen in Ruby on Rails 3 - Robin Brouwer

logger.debug
logger.info
logger.warn
logger.error
logger.fatal

Het verschil tussen deze methods is hoe belangrijk het bericht is dat in het logbestand
komt. De debug method is de minst belangrijke en de fatal method is de belangrijkste.
Standaard zullen de berichten van de debug method niet in de production log worden
getoond. Je kunt deze levels nog wel aanpassen. Hoe dit precies werkt kun je in de Ruby
on Rails guide bekijken.
Debugging Rails Applications
http://guides.rubyonrails.org/debugging_rails_applications.html
(TinyURL: http://tinyurl.com/kplpyn)
Aan de verschillende logger methods kun je gewoon een String meegeven. Ook kun je
weer to_yaml of inspect gebruiken om het wat op te schonen.

logger.debug("Er gaat iets fout...")
logger.info(@todo.to_yaml)
logger.fatal("Er is iets goed mis: #{@todo.to_yaml}")

De logger methods zijn vooral handig om extra informatie in je log te stoppen, zodat je in
production gemakkelijker iets kan debuggen als het fout gaat. De raise en debug methods
zijn vooral handig tijdens het maken van de applicatie. Bekijk nog even de link die ik
hierboven heb genoemd. Daar zit wat extra informatie in over het debuggen binnen Rails.

14.5 Testen
Testen binnen Ruby on Rails is ontzettend belangrijk. En dan heb ik het niet over het testen
van je applicatie in de browser. Ik heb het over het schrijven van ‘automated tests’ die
automatisch je applicatie voor je testen. Je schrijft deze tests naast je normale code om te
testen of je code goed functioneert. Als je dan iets verandert aan je code kan het ervoor
zorgen dat je applicatie niet meer werkt. Doordat je een test hebt geschreven kun je veel
gemakkelijker kijken of alles wel correct werkt. Daarom moet je ook je tests aanpassen als
je een aanpassing doet of nieuwe functionaliteit toevoegt.
Vaak wordt er binnen de Rails community gesproken over ‘Test Driven Development’ en
‘Behaviour Driven Development’. Bij deze manier van werken zorg je ervoor dat je eerst
een aantal tests schrijft voor je functionaliteit, voordat je de functionaliteit toevoegt. Het is
een enorm populaire manier van werken binnen de Rails community. Hoe je precies op
zo’n manier kunt werken heb ik expres achterwege gelaten in dit boek. Ik vind dat het
261 - Instappen in Ruby on Rails 3 - Robin Brouwer

schrijven van tests iets is voor programmeurs die al wat ervaring hebben met Rails. Het
zou volgens mij alleen maar nieuwe Rails developers afschrikken. Het past mijns inziens
daarom niet echt in een boek voor beginners. Er zijn complete boeken over hoe je binnen
Rails kunt testen. Je kunt deze boeken lezen, maar kunt natuurlijk ook tutorials op internet
volgen en dingen uittesten.
Het gebruiken van tests heeft vele voordelen. Zo kun je veel beter bugs opvangen en je
applicatie heel gemakkelijk grondig testen. Er kleeft echter een groot nadeel aan: tijd. Het
kost ontzettend veel tijd om (goede) tests te schrijven. Soms ben je bijna net zoveel tijd
kwijt aan het schrijven van tests als dat je bezig bent met de functionaliteit. Als je een
spoedproject hebt zou ik het logisch vinden als je het testen in eerste instantie achterwege
laat. Als je echter een groot project hebt is het zeker aan te raden om tests hiervoor te
schrijven. Het zal je dan misschien meer tijd kosten, maar uiteindelijk zul je een stuk
minder fouten hoeven oplossen en kan het zelfs zo zijn dat je minder tijd kwijt bent dan
normaal.
Het testen binnen Rails kan op veel verschillende manieren. Ook wordt er een onderscheid
gemaakt tussen het testen van de Model en de User-Interface. Het testen van de UI kan in
Rails heel gemakkelijk met een gem als ‘Cucumber’. Hiermee schrijf je tests uit in tekst. Dit
is bijvoorbeeld een Cucumber test:

Feature: Search courses
In order to ensure better utilization of courses
Potential students should be able to search for courses
Scenario: Search by topic
Given there are 240 courses which do not have the topic "biology"
And there are 2 courses A001, B205 that each have "biology" as one
of the topics
When I search for "biology"
Then I should see the following courses:
| Course code |
| A001
|
| B205
|

Het gebruikmaken van Cucumber is erg handig, maar is niet de enige manier van testen.
Je schrijft meestal ook tests voor de Model. Dit doe je niet met Cucumber, maar meestal
met zogenaamde ‘Unit Tests’. Dit werkt totaal anders dan Cucumber. Hoe dit precies
werkt kun je uitzoeken door boeken erover te lezen of tutorials op het internet te volgen.
Ik zal nu niet meer aandacht besteden aan het testen binnen Rails. Je kunt het beste nu zelf
op onderzoek uitgaan. Ik zal je hier een aantal links geven om je een beetje op weg te
helpen. Ik raad je echter wel aan om hieraan te beginnen als je Rails echt goed begrijpt. Als
je nog nooit met Rails hebt gewerkt kun je nu beter een paar kleine projecten doen om
262 - Instappen in Ruby on Rails 3 - Robin Brouwer

jezelf wat te verbeteren. Hierna ben je wel klaar om aan de slag te gaan met het schrijven
van tests voor je applicatie.
A Guide to Testing Rails Applications
http://guides.rubyonrails.org/testing.html
Github.com - cucumber
https://github.com/cucumber/cucumber
Cucumber homepage
http://cukes.info
Railscasts.com - Beginning with Cucumber
http://railscasts.com/episodes/155-beginning-with-cucumber
Railscasts.com - Testing Controllers wit RSpec
http://railscasts.com/episodes/71-testing-controllers-with-rspec
Github.com - shoulda
https://github.com/thoughtbot/shoulda
Rails Test Prescriptions: Keeping Your Application Healthy
http://pragprog.com/titles/nrtest/rails-test-prescriptions
Rails 3, RSpec, and Cucumber
http://blog.notahat.com/posts/43

14.4 Handige links om verder te gaan
Ik heb je al een aantal links gegeven om verder te gaan met testen. Testen is natuurlijk niet
het enige in Rails waar je meer over te weten kunt komen. Daarom zal ik hier een aantal
handige links geven om verder te gaan met Ruby on Rails.

14.4.1 Try Ruby
Nog nooit met Ruby gewerkt en heb je geen zin om het te installeren? Dan kun je het beste
deze website bezoeken. Dit is een interactieve tutorial waarbij je Ruby kunt schrijven in de
browser om opdrachten te voltooien. Een erg leuke manier om Ruby te leren.
http://tryruby.org

14.4.2 Rails for Zombies
Als je op een leuke manier snel Rails wilt leren kun je deze tutorial volgen. Het is een
interactieve tutorial zoals tryruby, maar dan speciaal voor Rails. Hiernaast heb je meerdere
video’s waarin wordt uitgelegd hoe bepaalde zaken binnen Rails werken. Heel erg handig
en vooral leuk om deze tutorial te volgen.
http://railsforzombies.org
263 - Instappen in Ruby on Rails 3 - Robin Brouwer

14.4.3 Ruby on Rails
Dit is de ofﬁciële Ruby on Rails website. Hier kun je veel handige informatie vinden over
Rails.
http://rubyonrails.org

14.4.4 Ruby on Rails Weblog
Dit is de ofﬁciële blog van Ruby on Rails. Hier komen alle aankondigingen op het gebied
van Rails te staan. Stop het dus in je RSS reader!
http://weblog.rubyonrails.org

14.4.5 Ruby on Rails Guides
Dit is de ofﬁciële Ruby on Rails guide. Ik heb in dit boek al een aantal keer naar deze
guide verwezen. Er zijn echter nog genoeg andere tutorials te vinden in deze guide.
http://guides.rubyonrails.org

14.4.6 Rails 3 Screencasts
De makers van Rails hebben een aantal screencasts gemaakt om Rails 3 uit te leggen. Zeker
het bekijken waard.
http://rubyonrails.org/screencasts/rails3

14.4.7 Rails 3 Cheatsheet
Een heel handige cheatsheet van Envylabs (makers van Rails for Zombies). Het is een PDF,
dus draai het uit en leg het papier naast je tijdens het maken van je Rails applicaties.
http://blog.envylabs.com/2010/12/rails-3-cheat-sheets/
(TinyURL: http://tinyurl.com/39zpl9q)

14.4.8 Railscasts
Dit is dé website om screencasts te bekijken over Rails. Elke maandag plaatst Ryan Bates
(degene die alle railscasts maakt) een video over een bepaald onderwerp binnen Rails. Van
video’s voor beginners tot video’s voor experts. Hij heeft al meer dan 250 aﬂeveringen
gemaakt, dus er is genoeg te bekijken. Alle eerste railscasts zijn echter voor oudere versies
van Rails, waardoor het misschien een beetje verouderd kan zijn. Toch is het zeker handig
om deze screencasts te bekijken.
http://railscasts.com

14.4.9 Asciicasts
Dit is een website waarin alle railscasts zijn uitgeschreven in tekst. Als je dus niet een
video wilt bekijken kun je de tutorials op deze website bekijken.
http://asciicasts.com

14.4.10 Rails API
De ofﬁciële API van Rails. Alles wat je over Rails wilt weten staat hierin.
http://api.rubyonrails.org

264 - Instappen in Ruby on Rails 3 - Robin Brouwer

14.4.11 Ruby API
De ofﬁciële API van Ruby. Alles over Ruby kun je hier vinden.
http://ruby-doc.org/ruby-1.9/index.html

14.4.12 Ruby and Rails
Elk jaar wordt er in Amsterdam een evenement georganiseerd voor de Ruby én Rails
community in Europa. Dit evenement heet ‘Ruby and Rails’. Het is een erg leuk
evenement om meer te leren over Rails en interessante presentaties aan te horen. Zeker een
aanrader.
http://rubyandrails.eu

14.4.13 45north Atoms
Dit is de weblog van het bedrijf waar ik werk: 45north. Hier plaatsen mijn collega’s en ik
regelmatig berichten over variërende, vaak technische, onderwerpen. Ik schrijf meestal
over Ruby on Rails, dus het kan handig zijn om deze weblog te volgen.
http://45north.nl/atoms

14.5 Rails 3.1
Ik heb vooral aan dit boek gewerkt in het weekend en op dagen dat ik even niks te doen
had bij 45north. Hiernaast moest ik tijdens het schrijven van dit boek ook nog eens
afstuderen, waardoor het me bijna een jaar heeft gekost om dit boek te schrijven. Dit heeft
ervoor gezorgd dat Rails versie 3.1 al gelanceerd is. Deze nieuwe versie van Rails biedt een
aantal nieuwe functies en lost een heleboel bugs op. Gelukkig is de nieuwe versie niet zo
drastisch veranderd dat ik alles in het boek moet aanpassen. Er zijn wel een aantal
belangrijke veranderingen waarvan je op de hoogte moet zijn.
Ik heb je al tussen de hoofdstukken door wat verteld over Rails 3.1. Ik zal hier nu wat
dieper op ingaan. Voor de complete release notes kun je in de Ruby on Rails guide kijken:
http://guides.rubyonrails.org/3_1_release_notes.html

14.5.1 jQuery default
Vanaf Rails 3.1 is jQuery het standaard JavaScript framework van Rails. Prototype is dus
vervangen! Ik ben zelf een jQuery aanhanger, dus wat mij betreft is het een erg goede
beslissing. Het zorgt ook gelijk voor wat minder stappen om een Rails applicatie met
jQuery aan te maken.
Het verwisselen van framework is ook een stuk simpeler geworden. Mocht je toch
Prototype willen gebruiken, dan kun je dat erg gemakkelijk aanpassen.

rails new my_app -j prototype

265 - Instappen in Ruby on Rails 3 - Robin Brouwer

Je kunt aan de -j optie meegeven welk framework je wilt gebruiken. In de Gemﬁle wordt
dan een gem toegevoegd om dit gemakkelijk voor elkaar te krijgen en later weer aan te
passen.

gem "prototype-rails"

Als je jQuery gebruikt komt hier ‘jquery-rails’ te staan. Zo kun je achteraf ook erg
gemakkelijk van framework wisselen. Vergeet echter niet ‘bundle install’ uit te voeren. De
gem moet uiteraard eerst gebundeld worden.

14.5.2 Sass en CoﬀeeScript
Een andere welkome verbetering is dat Sass en CoffeeScript standaard worden gebruikt in
Rails 3.1. Zo zie je de volgende twee dingen standaard in de Gemﬁle staan:
group
gem
gem
gem
end

:assets do
'sass-rails', " ~> 3.1.0"
'coffee-rails', "~> 3.1.0"
'uglifier'

Sass is een taal, van de maker van Haml, waarmee CSS schrijven een stuk leuker wordt.
CoffeeScript maakt het schrijven van JavaScript een stuk gemakkelijker. Voor meer
informatie over deze twee nieuwe talen kun je het beste de websites ervan bekijken
Sass - Syntactically Awesome Stylesheets
http://sass-lang.com/
CoffeeScript
http://jashkenas.github.com/coffee-script/
Het is echter niet zo dat je vanaf nu deze twee talen moet gebruiken in Rails. Je kunt nog
steeds reguliere CSS en JavaScript schrijven. Je kunt de twee gems ook gemakkelijk uit je
Gemﬁle verwijderen. Het zijn wel twee hele toffe talen, dus ik raad je zeker aan om een
kijkje te nemen. En nu je toch bezig bent: bekijk ook Haml.
#haml
http://haml-lang.com/
Er was nogal wat controversie rondom deze nieuwe functie in Rails 3.1. De commit die
ervoor zorgde dat het in Rails 3.1 werd gestopt heeft een enorme storm aan reacties
opgeleverd. Veel ervan negatief, maar ook een heleboel positief. Er zitten ook veel
grappige reacties tussen, waardoor het leuk is om een keer door te lezen.
266 - Instappen in Ruby on Rails 3 - Robin Brouwer

Github.com - Sass and CoffeeScript commit
https://github.com/rails/rails/commit/9f09aeb8273177fc2d09ebdafcc76ee8eb56fe33
(TinyURL: http://tinyurl.com/6ejannj)

14.5.3 Assets
Als je een kijkje neemt in de public map zie je dat er iets mist. De javascripts en stylesheets
mappen zijn verdwenen. Dit is ook iets nieuws in Rails 3.1. Alle JavaScript en CSS is
verplaatst naar een nieuwe map: /app/assets. Hierin zal je vanaf nu alle JavaScript en CSS
schrijven. Ook alle images staan hier nu in.
Standaard zit er een javascripts map, met een application.js bestand, en een stylesheets
map, met een application.css bestand, in de assets map. Zoals de bestandsnaam al zegt zijn
dit de bestanden voor de gehele applicatie. Als je Sass of CoffeeScript wilt gebruiken, dan
verander je simpelweg de bestandsnaam.
application.css 	
applications.js 	

=> application.css.scss
=> application.js.coffee

Elke keer als je een nieuwe resource aanmaakt (een Controller), zal er ook automatisch een
nieuw JavaScript en CSS bestand worden gegenereerd.
rails g controller products

Dit zorgt ervoor dat de volgende twee bestanden worden aangemaakt:
javascripts
- products.js.coffee
stylesheets
- products.css.scss

Je kunt nu alle CSS en JavaScript die speciﬁek is voor de producten goed scheiden in
verschillende bestanden. Dit houdt je code een stuk overzichtelijker.
Maar wat gebeurt er met deze bestanden? Het zou raar zijn als de gebruiker tien
verschillende JavaScript en CSS bestanden moet inladen. Gelukkig heeft Rails 3.1 hier iets
handigs voor: Sprockets.
Met Sprockets kun je erg gemakkelijk meerdere JavaScript en CSS bestanden samenvoegen
tot één bestand. Alle bestanden in de javascripts en stylesheets mappen worden
267 - Instappen in Ruby on Rails 3 - Robin Brouwer

samengevoegd. Er wordt automatisch een assets map aangemaakt in de public map met
de volgende twee bestanden:

application.css
application.js

Het scheelt weer een heleboel HTTP requests. Waar Rails 3.1 dus voor zorgt is dat je
gemakkelijker JavaScript en CSS kunt schrijven, dit goed kunt organiseren en dat dit alles
in één bestand wordt gestopt.
JavaScript dependency management and concatenation: Sprockets
http://getsprockets.org/

Als je in de Gemﬁle kijkt zie je nog een extra gem die wordt gebruikt in Rails 3.1.

gem "uglifier"

Deze gem zorgt ervoor dat in production zowel de JavaScript als de CSS kleiner wordt
gemaakt. Alle witregels worden weggehaald en er gebeuren nog wat andere dingen om de
bestanden een stuk kleiner te maken. Je hebt dus nu maar twee HTTP requests met zo min
mogelijk KB aan data.

14.5.4 Migrations
Een andere welkome verbetering is hoe de migrations zijn veranderd in Rails 3.1. Er zijn
geen ‘up’ en ‘down’ methods meer, waarin je speciﬁek moet aangeven wat er moet
gebeuren als er een migration is en wat als er een rollback is. Het is vervangen voor één
method: change.

268 - Instappen in Ruby on Rails 3 - Robin Brouwer

class CreateProducts < ActiveRecord::Migration
def change
create_table :products do |t|
t.string :title
t.timestamps
end
end
end

De change method zal automatisch de rollback regelen. Je hoeft dit niet meer expliciet op
te geven. Je kunt nog wel ‘up’ en ‘down’ gebruiken. Waar je nu wel op moet letten is dat
het geen class methods meer zijn. Je hoeft er geen ‘self’ voor te zetten.

14.5.5 Identity Mapping
Een andere toevoeging aan ActiveRecord is Identity Mapping. Dit houdt in dat er wordt
onthouden welke objecten je al een keer hebt gezocht in de database.
p = Product.create!(title: "Instappen in Ruby on Rails 3")
p2 = Product.find(1)
# => Product Loaded From Identity Map (id: 1)

Zoals je ziet maak ik een nieuw product aan en zoek ik hierna naar ditzelfde product. Er
wordt geen extra query gedaan om dit product op te halen, omdat deze al in het geheugen
van Ruby staat. Dit zorgt voor een stuk minder onnodige queries.
Iets anders wat handig is aan Rails 3.1 is dat je in de console (rails c) ook gelijk alle SQL
queries te zien krijgt. Het maakt het wat makkelijker om te kijken wat voor SQL er wordt
gegenereerd.

14.5.6 Nested has_many :through
Ik heb je al laten zien hoe ‘has_many :through’ werkt. Wat er echter ontbrak aan deze
functionaliteit was dat je ‘has_many :through’ niet kon nesten. In Rails 3.1 kan dit wel.
Ook kon je has_and_belongs_to_many niet nested met ‘has_many :through’. Dat kan nu
wel in Rails 3.1.

has_many :tasks
has_many :assignments, through: :tasks
has_many :users, through: :assignments

269 - Instappen in Ruby on Rails 3 - Robin Brouwer

14.5.7 Roles voor attr_accessible
Ik heb je ook al uitgelegd wat attr_accessible precies doet. Er ontbrak echter iets aan deze
handige method: je kon geen rollen meegeven. Ik heb vaak genoeg meegemaakt dat een
admin wel bepaalde attributen zou moeten kunnen aanpassen, maar een gewone
gebruiker weer niet. Dit kon niet zomaar in Rails. In Rails 3.1 is dit gelukkig opgelost.
class User < ActiveRecord::Base
attr_accessible :name, is_admin, as: :admin
attr_accessible :name, as: :user
end

Een admin kan nu wel bepalen of een gebruiker een admin is, maar een gewone gebruiker
kan dit niet. Je kunt aan de new, create en update_attributes methods nu een rol
meegeven:
@user.update_attributes(params[:user], as: :admin)

14.5.8 Multipart
Bij het hoofdstuk over het uploaden van bestanden heb ik laten zien dat je ‘multipart’
moest meegeven aan het formulier, om ervoor te zorgen dat je bestanden kunt uploaden.

<%= form_for(@user, html: { multipart: true }) do |f| %>
<%= f.file_field(:avatar) %>
<% end %>

In Rails 3.1 is dit niet meer nodig. Het formulier weet automatisch of je een bestand wilt
uploaden doordat je een ﬁle_ﬁeld meegeeft.

<%= form_for(@user) do |f| %>
<%= f.file_field(:avatar) %>
<% end %>

14.5.9 Nog veel meer
Naast deze vernieuwingen zijn er een heleboel andere dingen die zijn veranderd in Rails
3.1. Zo heb je ‘automated streaming’, ‘view inheritance’ en nog veel meer. Over een aantal
van deze onderwerpen zijn al railscasts gemaakt, dus ik raad je zeker aan om daar een
kijkje naar te nemen. Hiernaast is er een Railscast over hetgeen wat ik hierboven heb
behandeld, is er een uitgebreide changelog met alles wat veranderd is in Rails 3.1 en een
ofﬁciële pagina met de release notes.
270 - Instappen in Ruby on Rails 3 - Robin Brouwer

Railscasts.com - Rails 3.1 Overview
http://railscasts.com/episodes/265-rails-3-1-overview
The Changelogs for Rails 3.1
https://gist.github.com/958283
Rails 3.1 Release Notes
http://guides.rubyonrails.org/3_1_release_notes.html

14.6 Ingestapt!
Gefeliciteerd! Je bent nu ofﬁcieel ingestapt in de Ruby on Rails wereld. Je bent ook op het
perfecte moment ingestapt: Rails 3 heeft het werken met Ruby én Rails een heel stuk
aangenamer gemaakt. Ik zou het leuk vinden om te horen hoe het instappen je is vergaan
en hoe het verdiepen in de materie je vergaat. Als je een vraag hebt sta ik ook klaar om een
antwoord te geven. Als je feedback wilt geven zodat ik in een latere versie wat fouten kan
corrigeren, dan is dat natuurlijk ook van harte welkom. Stuur dit allemaal naar
robin@45north.nl en ik zal zo snel mogelijk proberen te reageren.
Wil je van Ruby on Rails je nieuwe baan maken? Dan is 45north misschien wat voor jou.
Dit is een webdevelopment bureau in Amsterdam die zich voornamelijk bezighoudt met
weboplossingen maken in Ruby on Rails. Ik werk er zelf ook en hebt het erg naar mijn zin
bij het bedrijf. Ik raad je daarom aan om een kijkje te nemen op http://www.45north.nl en
contact met ons op te nemen.
Als je andere programmeurs kent die misschien Ruby on Rails willen leren en ze zijn
toevallig jarig, dan is dit boek misschien een leuk cadeau. Ik wil de Nederlandse Ruby on
Rails community vergroten en daar heb ik jouw hulp ook bij nodig. Als je dus enthousiast
bent geworden over Rails, zou ik het erg op prijs stellen als je dit enthousiasme naar
anderen uit. Gaat voort en vertel het door!
Hartelijk bedankt voor het lezen van mijn boek en veel plezier met je verdere Ruby
avonturen!

271 - Instappen in Ruby on Rails 3 - Robin Brouwer

